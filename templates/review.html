<!DOCTYPE html>
<html lang="{{ html_lang }}" data-bs-theme="auto">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ translate('document.title', project=project_name) }}</title>
    <link href="{{ url_for('static', filename='vendor/bootstrap/bootstrap.min.css') }}" rel="stylesheet">
    <script src="{{ url_for('static', filename='vendor/bootstrap/bootstrap.bundle.min.js') }}"></script>
    <link rel="stylesheet" href="{{url_for('static', filename='css/style.css')}}">
    {% if theme_colors %}
    <script id="themeColorsData" type="application/json">
        {{ theme_colors | tojson | safe }}
    </script>
    {% endif %}
    <script>
        (function() {
            const root = document.documentElement;
            const storageKey = 'theme';
            const systemMedia = window.matchMedia('(prefers-color-scheme: dark)');
            const themeColors = (() => {
                const el = document.getElementById('themeColorsData');
                if (!el) {
                    return null;
                }
                try {
                    return JSON.parse(el.textContent);
                } catch {
                    return null;
                }
            })();

            const getStoredPreference = () => localStorage.getItem(storageKey) || 'auto';

            const resolveTheme = preference => {
                if (preference === 'light' || preference === 'dark') {
                    return preference;
                }
                return systemMedia.matches ? 'dark' : 'light';
            };

            const applyThemeColors = effectiveTheme => {
                if (!themeColors) {
                    return;
                }

                const lightVars = themeColors.light || {};
                const darkVars = themeColors.dark || {};

                Object.entries(lightVars).forEach(([name, value]) => {
                    root.style.setProperty(`--${name}`, value);
                });

                if (effectiveTheme === 'dark') {
                    Object.entries(darkVars).forEach(([name, value]) => {
                        root.style.setProperty(`--${name}`, value);
                    });
                }
            };

            const applyTheme = preference => {
                const effectiveTheme = resolveTheme(preference);
                root.setAttribute('data-bs-theme', effectiveTheme);
                root.dataset.themePreference = preference;
                applyThemeColors(effectiveTheme);
            };

            const handleSystemChange = () => {
                const preference = root.dataset.themePreference || getStoredPreference();
                if (preference === 'auto') {
                    applyTheme('auto');
                }
            };

            if (typeof systemMedia.addEventListener === 'function') {
                systemMedia.addEventListener('change', handleSystemChange);
            } else if (typeof systemMedia.addListener === 'function') {
                systemMedia.addListener(handleSystemChange);
            }

            window.toggleTheme = function() {
                const currentPreference = root.dataset.themePreference || getStoredPreference();
                let nextPreference = 'auto';
                if (currentPreference === 'auto') {
                    nextPreference = 'light';
                } else if (currentPreference === 'light') {
                    nextPreference = 'dark';
                }
                localStorage.setItem(storageKey, nextPreference);
                applyTheme(nextPreference);
            };

            applyTheme(getStoredPreference());
        })();
    </script>
    <style>
        .floating-help-button {
            position: fixed;
            bottom: 1.5rem;
            right: 6.5rem;
            z-index: 1040;
        }

        @media (max-width: 576px) {
            .floating-help-button {
                bottom: 1rem;
                right: 5rem;
            }
        }

        #waveform-time-scale {
            position: relative;
            height: 32px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.15);
            font-size: 0.75rem;
            color: var(--bs-secondary-color);
        }

        [data-bs-theme="dark"] #waveform-time-scale {
            border-bottom-color: rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.7);
        }

        .waveform-second-tick {
            position: absolute;
            width: 1px;
            top: 14px;
            bottom: 0;
            background-color: currentColor;
            opacity: 0.45;
        }

        .waveform-second-tick.major {
            top: 8px;
            opacity: 0.8;
        }

        .waveform-second-label {
            position: absolute;
            top: 0;
            transform: translateX(-50%);
            white-space: nowrap;
        }
    </style>
</head>
<body>
    <div class="theme-controls">
        {% if language_options %}
        <div class="language-selector">
            <label for="languageSelect" class="visually-hidden">{{ translate('general.language_selector_label') }}</label>
            <select id="languageSelect" class="form-select form-select-sm" aria-label="{{ translate('general.language_selector_aria') }}">
                {% for option in language_options %}
                <option value="{{ option.code }}" {% if option.code == active_language %}selected{% endif %}>{{ option.label }}</option>
                {% endfor %}
            </select>
        </div>
        {% endif %}
        <button class="theme-toggle" onclick="toggleTheme()" aria-label="{{ translate('general.theme_toggle_aria') }}">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16">
            <path d="M8 11a3 3 0 1 1 0-6 3 3 0 0 1 0 6zm0 1a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z"/>
        </svg>
        </button>
    </div>

    <div class="modal fade" id="audioPreviewModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-lg modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="audioPreviewTitle">{{ translate('audio_modal.title') }}</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="{{ translate('general.close_aria') }}"></button>
                </div>
                <div class="modal-body">
                    <div class="audio-waveform mb-3">
                        <div id="audioWaveform"></div>
                        <div id="audioWaveformLoading" class="waveform-loading-overlay d-none">{{ translate('audio_modal.loading') }}</div>
                    </div>
                    <div class="small text-muted">
                        {{ translate('audio_modal.instructions') }}
                    </div>
                    <div class="audio-trim-info d-flex flex-wrap align-items-center gap-3 mt-3">
                        <div>{{ translate('audio_modal.start_label') }} <span id="trimStartDisplay">—</span></div>
                        <div>{{ translate('audio_modal.end_label') }} <span id="trimEndDisplay">—</span></div>
                        <div>{{ translate('audio_modal.duration_label') }} <span id="trimDurationDisplay">—</span></div>
                    </div>
                    <div class="mt-3">
                        <label for="trimStartRange" class="form-label mb-1">{{ translate('audio_modal.start_slider') }}</label>
                        <input type="range" class="form-range" id="trimStartRange" min="0" max="0" step="0.01" value="0" disabled>
                    </div>
                    <div class="mt-3">
                        <label for="trimEndRange" class="form-label mb-1">{{ translate('audio_modal.end_slider') }}</label>
                        <input type="range" class="form-range" id="trimEndRange" min="0" max="0" step="0.01" value="0" disabled>
                    </div>
                    <div class="d-flex flex-wrap gap-2 align-items-center mt-3">
                        <button type="button" class="btn btn-outline-secondary btn-sm" id="trimResetSelectionBtn" disabled>{{ translate('audio_modal.reset_selection') }}</button>
                        <span class="small text-muted">{{ translate('audio_modal.reset_hint') }}</span>
                    </div>
                    <div class="alert alert-danger py-2 px-3 small mt-3 d-none" id="trimErrorAlert"></div>
                </div>
                <div class="modal-footer">
                    <div class="me-auto d-flex align-items-center gap-2">
                        <div class="spinner-border spinner-border-sm text-primary d-none" role="status" id="trimSaveSpinner"></div>
                        <span class="small text-muted" id="trimStatusText"></span>
                    </div>
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">{{ translate('buttons.close') }}</button>
                    <button type="button" class="btn btn-primary" id="trimSaveBtn" disabled>{{ translate('buttons.save') }}</button>
                </div>
            </div>
        </div>
    </div>

    <div class="container-fluid mt-4">
    <div class="d-flex justify-content-between align-items-center mb-3">
        <h1>{{ translate('header.title', project=project_name) }}</h1>
        <div>
            <a href="{{url_for('show_project', project_name=project_name)}}" class="btn btn-secondary me-2">{{ translate('header.back_button') }}</a>
        </div>
    </div>

        {%if audio_url and segments_data%}
            <div class="mb-3">
                <p class="mb-1">{{ translate('header.audio_file_label') }} <strong>{{audio_file_name}}</strong></p>
                <p class="mb-1">{{ translate('header.json_file_label') }} <strong>{{json_file_name}}</strong> ({{ translate('header.segment_count', count=segments_data|length) }})</p>
            </div>
            <button id="playPauseBtn" class="btn btn-primary mb-3">{{ translate('header.play_button') }}</button>
            <div id="waveform-scroll-wrapper">
                <div id="waveform-content-area">
                    <div id="waveform-time-scale"></div>
                    <div id="waveform"></div>
                    <div id="segments-timeline"></div>
                </div>
            </div>
        {%elif audio_url and not segments_data%}
            <div class="alert alert-warning" role="alert">
                {{ translate('alerts.audio_without_segments', audio=audio_file_name, json=json_file_name if json_file_name else translate('alerts.associated_json')) }}
            </div>
        {%elif not audio_url%}
            <div class="alert alert-danger" role="alert">
                {{ translate('alerts.audio_missing') }}
            </div>
        {%endif%}
    </div>

    <div class="container-fluid mb-5 px-4">
        <div class="alert alert-info mb-0" role="alert">
            {{ translate('alerts.help_cta') | safe }}
        </div>
    </div>

    <button type="button"
            class="btn btn-outline-info shadow floating-help-button"
            data-bs-toggle="modal"
            data-bs-target="#reviewHelpModal"
            aria-label="{{ translate('help.button_aria') }}">
        {{ translate('help.button_label') }}
    </button>

    <script src="{{ url_for('static', filename='vendor/wavesurfer/wavesurfer.min.js') }}"></script>
    <script src="{{ url_for('static', filename='vendor/wavesurfer/regions.min.js') }}"></script>
    <script src="{{ url_for('static', filename='js/audio-trimmer.js') }}"></script>
    <!-- Felugró menü HTML struktúrája -->
    <div id="segment-context-menu" class="custom-context-menu">
        <ul>
            <li id="menu-insert-segment">{{ translate('context_menu.insert') }}</li>
            <li id="menu-delete-segment">{{ translate('context_menu.delete') }}</li>
            <li id="menu-regenerate-segment">{{ translate('context_menu.regenerate') }}</li>
        </ul>
    </div>

    <div class="modal fade" id="reviewHelpModal" tabindex="-1" aria-labelledby="reviewHelpModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg modal-dialog-scrollable">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="reviewHelpModalLabel">{{ translate('help.title') }}</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="{{ translate('general.close_aria') }}"></button>
                </div>
                <div class="modal-body">
                    <p class="mb-3">
                        {{ translate('help.intro') }}
                    </p>
                    <h6 class="fw-bold">{{ translate('help.navigation.title') }}</h6>
                    <ul class="mb-4">
                        {% for item in translate('help.navigation.items') %}
                        <li>{{ item | safe }}</li>
                        {% endfor %}
                    </ul>
                    <h6 class="fw-bold">{{ translate('help.playback.title') }}</h6>
                    <ul class="mb-4">
                        {% for item in translate('help.playback.items') %}
                        <li>{{ item | safe }}</li>
                        {% endfor %}
                    </ul>
                    <h6 class="fw-bold">{{ translate('help.editing.title') }}</h6>
                    <ul class="mb-4">
                        {% for item in translate('help.editing.items') %}
                        <li>{{ item | safe }}</li>
                        {% endfor %}
                    </ul>
                    <h6 class="fw-bold">{{ translate('help.operations.title') }}</h6>
                    <ul class="mb-4">
                        {% for item in translate('help.operations.items') %}
                        <li>{{ item | safe }}</li>
                        {% endfor %}
                    </ul>
                    <h6 class="fw-bold">{{ translate('help.tts.title') }}</h6>
                    <ul class="mb-4">
                        {% for item in translate('help.tts.items') %}
                        <li>{{ item | safe }}</li>
                        {% endfor %}
                    </ul>
                    <h6 class="fw-bold">{{ translate('help.regeneration.title') }}</h6>
                    <ul class="mb-4">
                        {% for item in translate('help.regeneration.items') %}
                        <li>{{ item | safe }}</li>
                        {% endfor %}
                    </ul>
                    <h6 class="fw-bold">{{ translate('help.tips.title') }}</h6>
                    <ul class="mb-0">
                        {% for item in translate('help.tips.items') %}
                        <li>{{ item | safe }}</li>
                        {% endfor %}
                    </ul>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">{{ translate('buttons.close') }}</button>
                </div>
            </div>
        </div>
</div>

    <!-- Regeneráció napló modal -->
    <div class="modal fade" id="regenerateLogModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-lg modal-dialog-scrollable">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">{{ translate('regenerate_modal.title') }}</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="{{ translate('general.close_aria') }}" id="regenerateLogCloseBtn"></button>
                </div>
                <div class="modal-body">
                    <div class="log-modal-status mb-2" id="regenerateLogStatus">{{ translate('regenerate_modal.preparing') }}</div>
                    <pre class="log-modal-pre" id="regenerateLogContent">{{ translate('regenerate_modal.initial_log') }}</pre>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">{{ translate('buttons.close') }}</button>
                </div>
            </div>
        </div>
    </div>

    <script id="ui-translations-data" type="application/json">{{ translations | tojson }}</script>
    <script>
        (function() {
            const dataElement = document.getElementById('ui-translations-data');
            let dictionary = {};
            if (dataElement) {
                try {
                    dictionary = JSON.parse(dataElement.textContent || '{}') || {};
                } catch (error) {
                    console.warn('Failed to parse UI translations:', error);
                }
            }

            function resolveKey(key) {
                if (!key) {
                    return undefined;
                }
                return key.split('.').reduce((acc, part) => {
                    if (acc && typeof acc === 'object' && part in acc) {
                        return acc[part];
                    }
                    return undefined;
                }, dictionary);
            }

            window.translateText = function(key, replacements = {}, fallback) {
                const template = resolveKey(key);
                if (typeof template === 'string') {
                    return template.replace(/\{(\w+)\}/g, (match, token) => {
                        if (Object.prototype.hasOwnProperty.call(replacements, token)) {
                            return replacements[token];
                        }
                        return match;
                    });
                }
                if (template !== undefined) {
                    return template;
                }
                return typeof fallback === 'string' ? fallback : key;
            };

            window.getUiTranslations = function() {
                return dictionary;
            };
        })();
    </script>

    <script>
        console.log('[DEBUG 01] Script tag processing started.');
        document.addEventListener('DOMContentLoaded', function () {
            console.log('[DEBUG 02] DOMContentLoaded event handler started.');
            
            const languageSelect = document.getElementById('languageSelect');
            const t = typeof window.translateText === 'function'
                ? window.translateText
                : (key, replacements = {}, fallback) => (fallback || key);

            if (languageSelect) {
                languageSelect.addEventListener('change', event => {
                    const selected = event.target.value;
                    const targetUrl = new URL(window.location.href);
                    if (selected) {
                        targetUrl.searchParams.set('lang', selected);
                    } else {
                        targetUrl.searchParams.delete('lang');
                    }
                    window.location.assign(targetUrl.toString());
                });
            }

            const audioUrl = "{{audio_url|safe if audio_url else ''}}";
            const audioFileName = {{ audio_file_name|tojson if audio_file_name else '""' }};
            const translatedSplitsDir = "{{ app_config.PROJECT_SUBDIRS.translated_splits | e }}";
            const currentProjectName = "{{project_name|safe}}";
            let segmentsDataString = '{{segments_data|tojson if segments_data else "[]"}}';
            let segmentsData = JSON.parse(segmentsDataString);
            const regenerateLogModalElement = document.getElementById('regenerateLogModal');
            let regenerateLogModal = null;
            let regenerateLogContent = document.getElementById('regenerateLogContent');
            let regenerateLogStatusText = document.getElementById('regenerateLogStatus');
            let regenerateLogPollTimer = null;
            let regenerateActiveJobId = null;
            let regenerateAutoCloseTimeout = null;
            let regenerateHasRefreshed = false;

            if (regenerateLogModalElement && typeof bootstrap !== 'undefined') {
                regenerateLogModal = new bootstrap.Modal(regenerateLogModalElement, {
                    backdrop: 'static',
                    keyboard: false
                });
            }

            const buildWorkdirUrl = (relativePath) => {
                const segments = [currentProjectName];
                if (relativePath) {
                    String(relativePath)
                        .replace(/^\/+/, '')
                        .split('/')
                        .forEach(part => {
                            if (part) {
                                segments.push(part);
                            }
                        });
                }
                const encoded = segments.map(part => encodeURIComponent(part));
                return `/workdir/${encoded.join('/')}`;
            };

            function ensureAudioTrimmer() {
                if (window.AudioTrimmer && typeof window.AudioTrimmer.init === 'function') {
                    window.AudioTrimmer.init({
                        projectName: currentProjectName,
                        buildWorkdirUrl,
                        refreshDirectory: () => {},
                        reloadFileBrowser: () => {},
                        cssEscape: (value) => value
                    });
                }
            }

            function generateSegmentAudioRelativePath(segment) {
                if (!translatedSplitsDir || !segment || !segment.has_translated_split) {
                    return null;
                }
                const startTimeFormatted = formatTimeForFilename(segment.start);
                const endTimeFormatted = formatTimeForFilename(segment.end);
                const wavFilename = `${startTimeFormatted}_${endTimeFormatted}.wav`;
                return `${translatedSplitsDir}/${wavFilename}`;
            }

            function openSegmentAudioModal(segment) {
                ensureAudioTrimmer();
                const relativePath = generateSegmentAudioRelativePath(segment);
                if (!relativePath) {
                    return;
                }
                const fileUrl = buildWorkdirUrl(relativePath);
                const fileName = relativePath.split('/').pop();
                if (window.AudioTrimmer && typeof window.AudioTrimmer.showPreview === 'function') {
                    try {
                        window.AudioTrimmer.showPreview(fileName, fileUrl, relativePath);
                        return;
                    } catch (error) {
                        console.error('AudioTrimmer előnézeti hiba:', error);
                    }
                }
                window.open(fileUrl, '_blank');
            }

            function configurePlaybackButton(button, segment) {
                if (!button) {
                    return;
                }
                const hasAudio = Boolean(segment && segment.has_translated_split && translatedSplitsDir);
                button.disabled = !hasAudio;
                button.classList.toggle('btn-outline-primary', hasAudio);
                button.classList.toggle('btn-outline-secondary', !hasAudio);
                button.textContent = hasAudio ? t('segments.play_button') : t('segments.no_tts');
                button.title = hasAudio ? t('segments.play_tooltip') : t('segments.no_tts_tooltip');
            }

            ensureAudioTrimmer();
            function sanitizeSegmentTexts(segments) {
                if (!Array.isArray(segments)) {
                    return;
                }
                segments.forEach(segment => {
                    if (!segment || typeof segment !== 'object') {
                        return;
                    }
                    ['text', 'translated_text'].forEach(key => {
                        if (typeof segment[key] === 'string') {
                            segment[key] = segment[key].replace(/\\"/g, '"');
                        }
                    });
                    segment.has_translated_split = Boolean(segment.has_translated_split);
                });
            }
            sanitizeSegmentTexts(segmentsData);
            const positionsCache = new Map();

            function invalidateSegmentPositionCache() {
                positionsCache.clear();
            }

            function stopRegeneratePolling() {
                if (regenerateLogPollTimer) {
                    clearInterval(regenerateLogPollTimer);
                    regenerateLogPollTimer = null;
                }
                if (regenerateAutoCloseTimeout) {
                    clearTimeout(regenerateAutoCloseTimeout);
                    regenerateAutoCloseTimeout = null;
                }
                regenerateActiveJobId = null;
                regenerateHasRefreshed = false;
            }

            if (regenerateLogModalElement) {
                regenerateLogModalElement.addEventListener('hidden.bs.modal', () => {
                    stopRegeneratePolling();
                });
            }

            function updateRegenerateStatus(status, message) {
                const statusMap = {
                    queued: t('regenerate_modal.status.queued'),
                    running: t('regenerate_modal.status.running'),
                    cancelling: t('regenerate_modal.status.cancelling'),
                    cancelled: t('regenerate_modal.status.cancelled'),
                    completed: t('regenerate_modal.status.completed'),
                    failed: t('regenerate_modal.status.failed')
                };
                const statusLabel = statusMap[status] || t('regenerate_modal.status.default');
                const combined = message ? `${statusLabel} ${message}` : statusLabel;
                if (regenerateLogStatusText) {
                    regenerateLogStatusText.textContent = combined;
                }
            }

            function startRegeneratePolling(jobId) {
                stopRegeneratePolling();
                regenerateActiveJobId = jobId;
                if (regenerateLogContent) {
                    regenerateLogContent.textContent = t('regenerate_modal.initial_log');
                }
                updateRegenerateStatus('queued', '');
                const poll = () => pollRegenerateJob();
                poll();
                regenerateLogPollTimer = setInterval(poll, 3000);
            }

            function pollRegenerateJob() {
                if (!regenerateActiveJobId) {
                    return;
                }
                fetch(`/api/workflow-log/${regenerateActiveJobId}`)
                    .then(res => res.json())
                    .then(data => {
                        if (!data.success) {
                            if (regenerateLogContent) {
                                const errorText = data.error || t('errors.unknown');
                                regenerateLogContent.textContent = t('regenerate_modal.log_fetch_error', { error: errorText });
                            }
                            updateRegenerateStatus('failed', '');
                            stopRegeneratePolling();
                            return;
                        }
                        if (regenerateLogContent) {
                            if (data.log_available && data.log) {
                                regenerateLogContent.textContent = data.log;
                                regenerateLogContent.scrollTop = regenerateLogContent.scrollHeight;
                            } else if (!data.log_available) {
                                regenerateLogContent.textContent = t('regenerate_modal.preparing_log');
                            }
                        }
                        updateRegenerateStatus(data.status, data.message);
                        if (data.completed) {
                            stopRegeneratePolling();
                            if (!regenerateHasRefreshed) {
                                regenerateHasRefreshed = true;
                                refreshSegmentsFromServer();
                            }
                            if (data.status === 'completed' && regenerateLogModal) {
                                regenerateAutoCloseTimeout = setTimeout(() => {
                                    regenerateLogModal.hide();
                                }, 2000);
                            }
                        }
                    })
                    .catch(err => {
                        if (regenerateLogContent) {
                            regenerateLogContent.textContent = t('regenerate_modal.log_fetch_error', { error: err.message });
                        }
                        updateRegenerateStatus('failed', '');
                        stopRegeneratePolling();
                    });
            }

            function refreshSegmentsFromServer() {
                if (currentJsonFileName === null || currentJsonFileName === undefined) {
                    return;
                }
                fetch(`/api/get-segments/${currentProjectName}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ json_file_name: currentJsonFileName })
                })
                .then(res => res.json())
                .then(data => {
                    if (!data.success || !Array.isArray(data.segments)) {
                        console.warn('Nem sikerült frissíteni a szegmenseket:', data.error);
                        return;
                    }
                    segmentsData = data.segments;
                    sanitizeSegmentTexts(segmentsData);
                    invalidateSegmentPositionCache();
                    ensureAudioTrimmer();
                    fullRefreshUI();
                })
                .catch(err => console.error('Szegmens frissítés hiba:', err));
            }

            function getSegmentPositions(currentPxPerSec) {
                const cacheKey = currentPxPerSec.toFixed(2);
                if (!positionsCache.has(cacheKey)) {
                    positionsCache.set(cacheKey, calculateSegmentPositions(segmentsData, currentPxPerSec));
                }
                return positionsCache.get(cacheKey);
            }
            
            let currentJsonFileNameString = '{{json_file_name|tojson if json_file_name else "null"}}';
            let currentJsonFileName = (currentJsonFileNameString && currentJsonFileNameString !== 'null') ? JSON.parse(currentJsonFileNameString) : null;

            if (!audioUrl) {
                console.error('[DEBUG 03] Audio URL hiányzik.');
                const playButton = document.getElementById('playPauseBtn');
                if(playButton) playButton.disabled = true;
                return;
            }
            console.log('[DEBUG 03] Audio URL:', audioUrl);

            if (segmentsData.length === 0 && audioUrl) {
                console.info('[DEBUG 04] Nincsenek szegmensek.');
            } else if (segmentsData.length > 0) {
                console.log('[DEBUG 04] Segments count:', segmentsData.length);
            }

            let wavesurfer;
            let regionsPlugin;
            let regionIdToOriginalIndexMap = {}; 
            let activelyLoopingRegionId = null;

            const waveformLoaderElement = document.getElementById('audioWaveformLoading');
            const waveformChunkSizeSeconds = 60;
            let waveformSamplesPerSecond = 40;
            let waveformPeaksBuffer = null;
            let waveformTotalDuration = 0;
            let waveformStreamingInitialized = false;
            let waveformStreamingCancelled = false;
            let waveformFallbackTriggered = false;
            let waveformChunkRequestInFlight = false;
            let waveformTotalChunks = null;
            let updateWaveformPeaksDebounced = null;

            const contextMenu = document.getElementById('segment-context-menu');
            let currentContextMenuSegmentIndex = -1;

            // ---- ÚJ FÜGGVÉNYEK ----
            /**
             * Egy textarea elem magasságát a tartalmához igazítja.
             * @param {HTMLTextAreaElement} textarea - Az átméretezendő szövegdoboz.
             */
            function autoResizeTextarea(textarea) {
                textarea.style.height = 'auto';
                textarea.style.height = (textarea.scrollHeight) + 'px';
            }

            /**
             * Frissíti az idővonal konténerének magasságát a benne lévő elemek alapján.
             */
            function updateTimelineContainerHeight() {
                const segmentsTimelineContainer = document.getElementById('segments-timeline');
                if (!segmentsTimelineContainer) return;
                const timelineChildren = segmentsTimelineContainer.children;
                let maxBottom = 0;
                if (timelineChildren.length > 0) {
                    for (let i = 0; i < timelineChildren.length; i++) {
                        const child = timelineChildren[i];
                        if (child.style.display === 'none') continue;
                        const childBottom = parseFloat(child.style.top) + child.offsetHeight;
                        if (childBottom > maxBottom) {
                            maxBottom = childBottom;
                        }
                    }
                    segmentsTimelineContainer.style.height = `${maxBottom + 20}px`;
                } else {
                    segmentsTimelineContainer.style.height = '50px';
                }
            }

            /**
             * Formats time in seconds to HH-MM-SS-mmm string for filenames.
             * @param {number} timeInSeconds - The time value in seconds.
             * @returns {string} The formatted time string.
             */
            function formatTimeForFilename(timeInSeconds) {
                if (typeof timeInSeconds !== 'number' || isNaN(timeInSeconds)) {
                    console.error("Invalid time provided to formatTimeForFilename:", timeInSeconds);
                    return '00-00-00-000';
                }
                // Handle potential floating point inaccuracies by rounding to nearest millisecond
                const totalMilliseconds = Math.round(timeInSeconds * 1000);
                const hours = Math.floor(totalMilliseconds / 3600000);
                const minutes = Math.floor((totalMilliseconds % 3600000) / 60000);
                const seconds = Math.floor((totalMilliseconds % 60000) / 1000);
                const milliseconds = totalMilliseconds % 1000;

                return [
                    String(hours).padStart(2, '0'),
                    String(minutes).padStart(2, '0'),
                    String(seconds).padStart(2, '0'),
                    String(milliseconds).padStart(3, '0')
                ].join('-');
            }

            function formatSecondsForLabel(totalSeconds) {
                if (typeof totalSeconds !== 'number' || !isFinite(totalSeconds)) {
                    return '00:00';
                }
                const rounded = Math.max(0, Math.floor(totalSeconds));
                const hours = Math.floor(rounded / 3600);
                const minutes = Math.floor((rounded % 3600) / 60);
                const seconds = rounded % 60;
                if (hours > 0) {
                    return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                }
                return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }

            function formatTimecodeForTooltip(timeInSeconds) {
                if (typeof timeInSeconds !== 'number' || !isFinite(timeInSeconds)) {
                    return '00:00:00.00';
                }
                const totalMilliseconds = Math.max(0, Math.round(timeInSeconds * 1000));
                const hours = Math.floor(totalMilliseconds / 3600000);
                const minutes = Math.floor((totalMilliseconds % 3600000) / 60000);
                const seconds = Math.floor((totalMilliseconds % 60000) / 1000);
                const hundredths = Math.floor((totalMilliseconds % 1000) / 10);
                const base = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}.${String(hundredths).padStart(2, '0')}`;
                if (hours <= 0) {
                    return base;
                }
                return `${String(hours).padStart(2, '0')}:${base}`;
            }

            function formatSegmentTooltip(segment) {
                if (!segment) {
                    return '00:00:00.00 → 00:00:00.00';
                }
                const start = formatTimecodeForTooltip(segment.start);
                const end = formatTimecodeForTooltip(segment.end);
                return `${start} → ${end}`;
            }
            // ---- FÜGGVÉNYEK VÉGE ----

            // Függvények definíciói
            function setWaveformZoom() {
                const scrollWrapper = document.getElementById('waveform-scroll-wrapper');
                if (wavesurfer && scrollWrapper) {
                    const audioDuration = wavesurfer.getDuration();
                    const containerWidth = scrollWrapper.clientWidth;
                    const secondsToShow = 20;

                    if (audioDuration > 0 && containerWidth > 0) {
                        let newMinPxPerSec = containerWidth / Math.min(secondsToShow, audioDuration);
                        newMinPxPerSec = Math.max(10, newMinPxPerSec);
                        wavesurfer.zoom(newMinPxPerSec);
                    } else if (containerWidth > 0) {
                        wavesurfer.zoom(10);
                    }
                }
            }
            
            const segmentsTimelineContainer = document.getElementById('segments-timeline');
            const waveformTimeScale = document.getElementById('waveform-time-scale');
            const waveformContentArea = document.getElementById('waveform-content-area');
            const scrollWrapper = document.getElementById('waveform-scroll-wrapper');

            function updateWidths() {
                if (!wavesurfer || !wavesurfer.getWrapper() || !waveformContentArea || !segmentsTimelineContainer) return;
                try {
                    const fullAudioPixelWidth = wavesurfer.getWrapper().scrollWidth;
                    waveformContentArea.style.width = `${fullAudioPixelWidth}px`;
                    segmentsTimelineContainer.style.width = `${fullAudioPixelWidth}px`;
                    if (waveformTimeScale) {
                        waveformTimeScale.style.width = `${fullAudioPixelWidth}px`;
                    }
                    renderWaveformTimeScale(wavesurfer.options?.minPxPerSec || 0);
                } catch (e) {
                    console.error("Error in updateWidths:", e);
                }
            }
            
            // ---- OPTIMALIZÁLT FÜGGVÉNYEK ----
            
            // Virtualizáció és teljesítmény optimalizálás
            let segmentElementsCache = new Map();
            let visibleSegments = new Set();
            let renderQueue = [];
            let isRendering = false;
            let lastScrollLeft = 0;
            let lastZoomLevel = 0;
            
            // Debounce függvény
            function debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const context = this;
                    const later = () => {
                        clearTimeout(timeout);
                        func.apply(context, args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }

            updateWaveformPeaksDebounced = debounce(() => {
                if (!wavesurfer || !waveformPeaksBuffer || !waveformTotalDuration) return;
                wavesurfer.setOptions({
                    peaks: [waveformPeaksBuffer],
                    duration: waveformTotalDuration
                });
            }, 180);

            function focusPlaybackAt(timeInSeconds) {
                if (!wavesurfer) return;
                const duration = wavesurfer.getDuration() || 0;
                const clampedTime = Math.max(0, Math.min(timeInSeconds, duration));
                wavesurfer.setTime(clampedTime);
                wavesurfer.play();
            }

            function getWaveformClickTime(event) {
                if (!wavesurfer || !scrollWrapper) return null;
                const wrapper = wavesurfer.getWrapper();
                if (!wrapper) return null;
                const rect = scrollWrapper.getBoundingClientRect();
                const relativeX = (event.clientX - rect.left) + scrollWrapper.scrollLeft;
                const fullWidth = wrapper.scrollWidth || rect.width;
                const duration = wavesurfer.getDuration();
                if (!fullWidth || !duration) return null;
                const normalized = Math.min(Math.max(relativeX / fullWidth, 0), 1);
                return normalized * duration;
            }

            function handleWaveformAreaClick(event) {
                if (!wavesurfer) return;
                if (typeof event.button === 'number' && event.button !== 0) return;
                if (wavesurfer.isPlaying()) {
                    wavesurfer.pause();
                    return;
                }
                const clickTime = getWaveformClickTime(event);
                if (typeof clickTime === 'number') {
                    focusPlaybackAt(clickTime);
                }
            }

            function handleSegmentTimelineClick(event) {
                if (!segmentsTimelineContainer || !wavesurfer) return;
                if (typeof event.button === 'number' && event.button !== 0) return;
                if (event.target.closest('.segment-audio-trigger')) return;
                const segmentContainer = event.target.closest('.timeline-segment-container');
                if (!segmentContainer || !segmentContainer.dataset.segmentIndex) return;
                if (wavesurfer.isPlaying()) {
                    wavesurfer.pause();
                    return;
                }
                const segmentIndex = parseInt(segmentContainer.dataset.segmentIndex, 10);
                if (Number.isNaN(segmentIndex) || segmentIndex < 0 || segmentIndex >= segmentsData.length) return;
                const segment = segmentsData[segmentIndex];
                if (!segment) return;
                focusPlaybackAt(segment.start || 0);
            }

            function renderWaveformTimeScale(currentPxPerSec) {
                if (!waveformTimeScale || !wavesurfer || !currentPxPerSec) {
                    if (waveformTimeScale) {
                        waveformTimeScale.innerHTML = '';
                    }
                    return;
                }
                const duration = wavesurfer.getDuration() || 0;
                waveformTimeScale.innerHTML = '';
                if (duration <= 0) {
                    return;
                }
                const totalSeconds = Math.ceil(duration);
                const fragment = document.createDocumentFragment();
                for (let second = 0; second <= totalSeconds; second++) {
                    const positionPx = second * currentPxPerSec;
                    const tick = document.createElement('div');
                    tick.className = 'waveform-second-tick' + (second % 5 === 0 ? ' major' : '');
                    tick.style.left = `${positionPx}px`;
                    fragment.appendChild(tick);

                    if (second % 5 === 0) {
                        const label = document.createElement('div');
                        label.className = 'waveform-second-label';
                        label.style.left = `${positionPx}px`;
                        label.textContent = formatSecondsForLabel(second);
                        fragment.appendChild(label);
                    }
                }
                waveformTimeScale.appendChild(fragment);
            }

            function startProgressiveWaveformLoading() {
                if (!audioUrl) {
                    return;
                }
                if (!audioFileName) {
                    fallbackToDirectWaveformLoad();
                    return;
                }
                if (waveformStreamingCancelled || waveformChunkRequestInFlight || waveformStreamingInitialized) {
                    return;
                }
                toggleWaveformLoader(true, t('audio_modal.loading'));
                requestWaveformChunk(0);
            }

            function requestWaveformChunk(chunkIndex) {
                if (waveformStreamingCancelled) {
                    return;
                }
                waveformChunkRequestInFlight = true;
                const params = new URLSearchParams({
                    audio_file: audioFileName,
                    chunk_index: chunkIndex,
                    chunk_size: waveformChunkSizeSeconds,
                    samples_per_second: waveformSamplesPerSecond
                });
                fetch(`/api/waveform-chunk/${currentProjectName}?${params.toString()}`)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        waveformChunkRequestInFlight = false;
                        if (!data.success) {
                            throw new Error(data.error || 'waveform_chunk_error');
                        }
                        waveformTotalChunks = data.totalChunks || waveformTotalChunks;
                        toggleWaveformLoader(true, buildWaveformLoaderText(chunkIndex, waveformTotalChunks));
                        processWaveformChunkResponse(data);
                        if (!data.isLastChunk && !waveformStreamingCancelled) {
                            requestWaveformChunk(chunkIndex + 1);
                        } else {
                            toggleWaveformLoader(false);
                        }
                    })
                    .catch(error => {
                        waveformChunkRequestInFlight = false;
                        console.error('Waveform chunk fetch failed:', error);
                        fallbackToDirectWaveformLoad();
                    });
            }

            function buildWaveformLoaderText(chunkIndex, totalChunks) {
                if (!waveformLoaderElement) {
                    return '';
                }
                if (!totalChunks) {
                    return t('audio_modal.loading');
                }
                return `${t('audio_modal.loading')} (${chunkIndex + 1}/${totalChunks})`;
            }

            function processWaveformChunkResponse(data) {
                const peaks = Array.isArray(data.peaks) ? data.peaks : [];
                if (!peaks.length) {
                    if (!waveformStreamingInitialized) {
                        fallbackToDirectWaveformLoad();
                    }
                    return;
                }

                if (!waveformPeaksBuffer) {
                    waveformSamplesPerSecond = data.samplesPerSecond || waveformSamplesPerSecond;
                    waveformTotalDuration = data.totalDuration || ((data.chunkStart || 0) + (data.chunkDuration || 0));
                    const estimateSeconds = Math.max(
                        waveformTotalDuration,
                        (data.chunkStart || 0) + (data.chunkDuration || 0)
                    );
                    const initialLength = Math.max(
                        1,
                        Math.ceil(estimateSeconds * waveformSamplesPerSecond) + waveformSamplesPerSecond
                    );
                    waveformPeaksBuffer = new Float32Array(initialLength);
                }

                if (data.totalDuration && data.totalDuration > waveformTotalDuration) {
                    waveformTotalDuration = data.totalDuration;
                }

                const chunkStartIndex = Math.max(0, Math.round((data.chunkStart || 0) * waveformSamplesPerSecond));
                ensureWaveformBufferCapacity(chunkStartIndex + peaks.length + waveformSamplesPerSecond);

                for (let i = 0; i < peaks.length; i++) {
                    const bufferIndex = chunkStartIndex + i;
                    if (bufferIndex < waveformPeaksBuffer.length) {
                        waveformPeaksBuffer[bufferIndex] = peaks[i];
                    }
                }

                if (!waveformStreamingInitialized) {
                    waveformStreamingInitialized = true;
                    try {
                        const durationForLoad = waveformTotalDuration || ((data.chunkStart || 0) + (data.chunkDuration || 0)) || 1;
                        wavesurfer.load(audioUrl, [waveformPeaksBuffer], durationForLoad);
                    } catch (error) {
                        console.error('Progressive waveform init failed:', error);
                        fallbackToDirectWaveformLoad();
                        return;
                    }
                } else if (updateWaveformPeaksDebounced) {
                    updateWaveformPeaksDebounced();
                }
            }

            function ensureWaveformBufferCapacity(requiredLength) {
                if (!waveformPeaksBuffer || waveformPeaksBuffer.length >= requiredLength) {
                    return;
                }
                const expanded = new Float32Array(requiredLength);
                expanded.set(waveformPeaksBuffer);
                waveformPeaksBuffer = expanded;
            }

            function toggleWaveformLoader(show, labelText) {
                if (!waveformLoaderElement) {
                    return;
                }
                if (show) {
                    waveformLoaderElement.classList.remove('d-none');
                    if (labelText) {
                        waveformLoaderElement.textContent = labelText;
                    }
                } else {
                    waveformLoaderElement.classList.add('d-none');
                }
            }

            function fallbackToDirectWaveformLoad() {
                if (waveformFallbackTriggered) {
                    return;
                }
                waveformFallbackTriggered = true;
                waveformStreamingCancelled = true;
                if (!wavesurfer || !audioUrl) {
                    toggleWaveformLoader(false);
                    return;
                }
                toggleWaveformLoader(true, t('audio_modal.loading'));
                wavesurfer.load(audioUrl)
                    .catch(error => console.error('Waveform fallback load error:', error))
                    .finally(() => toggleWaveformLoader(false));
            }
            
            // Optimalizált collision detection - O(n log n) helyett O(n²)
            function calculateSegmentPositions(segments, currentPxPerSec) {
                const verticalGap = 5;
                const positions = [];
                const rows = [];
                
                // Szegmensek rendezése start idő szerint
                const sortedSegments = segments.map((segment, index) => ({
                    ...segment,
                    originalIndex: index,
                    leftPx: segment.start * currentPxPerSec,
                    widthPx: Math.max((segment.end - segment.start) * currentPxPerSec - 10, 150)
                })).sort((a, b) => a.start - b.start);
                
                sortedSegments.forEach(segment => {
                    let rowIndex = 0;
                    let placed = false;
                    
                    while (!placed) {
                        if (!rows[rowIndex]) {
                            rows[rowIndex] = [];
                        }
                        
                        // Ellenőrizzük az ütközést az aktuális sorban
                        let hasCollision = false;
                        for (const existingSegment of rows[rowIndex]) {
                            if (segment.leftPx < existingSegment.rightPx &&
                                segment.leftPx + segment.widthPx > existingSegment.leftPx) {
                                hasCollision = true;
                                break;
                            }
                        }
                        
                        if (!hasCollision) {
                            const segmentData = {
                                leftPx: segment.leftPx,
                                rightPx: segment.leftPx + segment.widthPx,
                                rowIndex: rowIndex
                            };
                            rows[rowIndex].push(segmentData);
                            positions[segment.originalIndex] = {
                                top: rowIndex * (80 + verticalGap), // Becsült sor magasság
                                left: segment.leftPx,
                                width: segment.widthPx
                            };
                            placed = true;
                        } else {
                            rowIndex++;
                        }
                    }
                });
                
                return positions;
            }
            
            // Viewport alapú virtualizáció
            function getVisibleSegmentIndices(scrollLeft, viewportWidth, currentPxPerSec) {
                const buffer = viewportWidth * 0.5; // 50% buffer mindkét oldalon
                const startTime = Math.max(0, (scrollLeft - buffer) / currentPxPerSec);
                const endTime = (scrollLeft + viewportWidth + buffer) / currentPxPerSec;
                
                const visibleIndices = [];
                segmentsData.forEach((segment, index) => {
                    if (segment.end >= startTime && segment.start <= endTime) {
                        visibleIndices.push(index);
                    }
                });
                
                return visibleIndices;
            }
            
            // Aszinkron DOM elem létrehozás
            function createSegmentElement(segment, index, position, currentPxPerSec) {
                return new Promise((resolve) => {
                    requestAnimationFrame(() => {
                        const segmentContainer = document.createElement('div');
                        segmentContainer.className = 'timeline-segment-container';
                        segmentContainer.style.position = 'absolute';
                        segmentContainer.style.left = `${position.left}px`;
                        segmentContainer.style.top = `${position.top}px`;
                        segmentContainer.style.width = `${position.width}px`;
                        segmentContainer.dataset.segmentIndex = index;
                        const hasTranslatedSplit = Boolean(segment.has_translated_split);

                        const originalTextarea = document.createElement('textarea');
                        originalTextarea.className = 'timeline-segment form-control form-control-sm original-text';
                        originalTextarea.value = segment.text;
                        originalTextarea.placeholder = t('segments.original_placeholder');
                        originalTextarea.style.resize = 'none';
                        originalTextarea.style.overflowY = 'hidden';
                        originalTextarea.title = formatSegmentTooltip(segment);

                        const translatedTextarea = document.createElement('textarea');
                        translatedTextarea.className = 'timeline-segment form-control form-control-sm translated-text';
                        translatedTextarea.value = segment.translated_text || '';
                        translatedTextarea.placeholder = segment.translated_text ? t('segments.translated_placeholder') : t('segments.translation_missing');
                        translatedTextarea.style.resize = 'none';
                        translatedTextarea.style.overflowY = 'hidden';
                        translatedTextarea.title = formatSegmentTooltip(segment);

                        segmentContainer.appendChild(originalTextarea);
                        segmentContainer.appendChild(translatedTextarea);

                        const playbackWrapper = document.createElement('div');
                        playbackWrapper.className = 'd-flex flex-wrap gap-2 align-items-center';

                        const playbackButton = document.createElement('button');
                        playbackButton.type = 'button';
                        playbackButton.className = 'btn btn-sm btn-outline-primary segment-audio-trigger';
                        playbackButton.addEventListener('click', () => {
                            const latestSegment = segmentsData[index] || segment;
                            if (latestSegment && latestSegment.has_translated_split) {
                                openSegmentAudioModal(latestSegment);
                            }
                        });
                        configurePlaybackButton(playbackButton, segment);
                        playbackWrapper.appendChild(playbackButton);

                        segmentContainer.appendChild(playbackWrapper);

                        autoResizeTextarea(originalTextarea);
                        autoResizeTextarea(translatedTextarea);
                        
                        resolve({ element: segmentContainer, index, originalTextarea, translatedTextarea, playbackButton });
                    });
                });
            }
            
            // Batch DOM műveletek
            async function renderVisibleSegments(currentPxPerSec) {
                if (isRendering) return;
                isRendering = true;
                
                try {
                    const scrollWrapper = document.getElementById('waveform-scroll-wrapper');
                    const scrollLeft = scrollWrapper ? scrollWrapper.scrollLeft : 0;
                    const viewportWidth = scrollWrapper ? scrollWrapper.clientWidth : 1000;
                    
                    const visibleIndices = getVisibleSegmentIndices(scrollLeft, viewportWidth, currentPxPerSec);
                    const positions = getSegmentPositions(currentPxPerSec);
                    
                    // Eltávolítjuk a már nem látható szegmenseket
                    const elementsToRemove = [];
                    visibleSegments.forEach(index => {
                        if (!visibleIndices.includes(index)) {
                            const element = segmentElementsCache.get(index);
                            if (element && element.parentNode) {
                                elementsToRemove.push(element);
                            }
                            visibleSegments.delete(index);
                        }
                    });
                    
                    // Batch removal
                    elementsToRemove.forEach(element => {
                        segmentsTimelineContainer.removeChild(element);
                    });
                    
                    // Új látható szegmensek hozzáadása
                    const newSegments = visibleIndices.filter(index => !visibleSegments.has(index));
                    const renderPromises = [];
                    
                    for (const index of newSegments) {
                        if (!segmentElementsCache.has(index)) {
                            const segment = segmentsData[index];
                            const position = positions[index];
                            if (segment && position) {
                                renderPromises.push(createSegmentElement(segment, index, position, currentPxPerSec));
                            }
                        } else {
                            // Ha már van cache-elt elem, de nem látható, hozzáadjuk a láthatókhoz
                            const cachedElement = segmentElementsCache.get(index);
                            if (cachedElement && !cachedElement.parentNode) {
                                visibleSegments.add(index);
                                const position = positions[index];
                                if (position) {
                                    cachedElement.style.left = `${position.left}px`;
                                    cachedElement.style.top = `${position.top}px`;
                                    cachedElement.style.width = `${position.width}px`;
                                    const cachedButton = cachedElement.querySelector('.segment-audio-trigger');
                                    configurePlaybackButton(cachedButton, segmentsData[index]);
                                    segmentsTimelineContainer.appendChild(cachedElement);
                                }
                            }
                        }
                    }
                    
                    // Várjuk meg az összes új elem létrehozását
                    const newElements = await Promise.all(renderPromises);
                    
                    // Batch DOM insertion
                    const fragment = document.createDocumentFragment();
                    newElements.forEach(({ element, index, originalTextarea, translatedTextarea, playbackButton }) => {
                        segmentElementsCache.set(index, element);
                        visibleSegments.add(index);
                        configurePlaybackButton(playbackButton, segmentsData[index]);
                        fragment.appendChild(element);
                        
                        // Event listeners hozzáadása az új elemekhez
                        attachSegmentEventListeners(originalTextarea, translatedTextarea, index);
                    });
                    
                    segmentsTimelineContainer.appendChild(fragment);
                    
                    // Meglévő elemek pozíciójának frissítése
                    visibleIndices.forEach(index => {
                        if (segmentElementsCache.has(index) && !newSegments.includes(index)) {
                            const element = segmentElementsCache.get(index);
                            const position = positions[index];
                            element.style.left = `${position.left}px`;
                            element.style.top = `${position.top}px`;
                            element.style.width = `${position.width}px`;
                            const playbackButton = element.querySelector('.segment-audio-trigger');
                            configurePlaybackButton(playbackButton, segmentsData[index]);
                        }
                    });
                    
                    updateTimelineContainerHeight();
                    
                } finally {
                    isRendering = false;
                }
            }
            
            // Event listener csatolás
            function attachSegmentEventListeners(originalTextarea, translatedTextarea, index) {
                [originalTextarea, translatedTextarea].forEach(textarea => {
                    textarea.addEventListener('input', debounce(function() {
                        autoResizeTextarea(this);
                        updateTimelineContainerHeight();
                    }, 100));
                    
                    textarea.addEventListener('keydown', function(event) {
                        if (event.key === 'Enter') {
                            event.preventDefault();
                            this.blur();
                        }
                    });
                    
                    textarea.addEventListener('focus', function() {
                        autoResizeTextarea(this);
                        updateTimelineContainerHeight();
                    });

                    textarea.addEventListener('click', function() {
                        wavesurfer.pause();
                        autoResizeTextarea(this);
                        updateTimelineContainerHeight();
                    });
                    // Double-click esemény eltávolítva - event delegation használjuk helyette
                });
                
                originalTextarea.addEventListener('blur', function() {
                    const newText = this.value;
                    const segment = segmentsData[index];
                    if (newText !== segment.text) {
                        updateSegmentOnServer(index, segment.start, segment.end, newText, segment.translated_text || '');
                    }
                });

                translatedTextarea.addEventListener('blur', function() {
                    const newTranslated = this.value;
                    const segment = segmentsData[index];
                    if (newTranslated !== (segment.translated_text || '')) {
                        updateSegmentOnServer(index, segment.start, segment.end, segment.text, newTranslated);
                    }
                });
            }
            
            // Optimalizált fő függvény
            const debouncedRenderSegments = debounce(renderVisibleSegments, 50);
            
            function createTimelineSegments(currentPxPerSec) {
                console.log(`[TIMELINE] Creating timeline segments, count: ${segmentsData.length}, pxPerSec: ${currentPxPerSec}`);
                
                if (!segmentsTimelineContainer || !wavesurfer || segmentsData.length === 0) {
                    if (segmentsTimelineContainer) {
                        segmentsTimelineContainer.innerHTML = '';
                        console.log('[TIMELINE] Cleared timeline container - no segments or missing dependencies');
                    }
                    return;
                }
                
                // Ha a zoom szint jelentősen változott, tisztítsuk a cache-t
                if (Math.abs(currentPxPerSec - lastZoomLevel) > 1) {
                    console.log(`[TIMELINE] Zoom level changed significantly: ${lastZoomLevel} -> ${currentPxPerSec}, clearing cache`);
                    segmentElementsCache.clear();
                    visibleSegments.clear();
                    segmentsTimelineContainer.innerHTML = '';
                    invalidateSegmentPositionCache();
                    lastZoomLevel = currentPxPerSec;
                }
                
                debouncedRenderSegments(currentPxPerSec);
            }
            // ---- OPTIMALIZÁLT FÜGGVÉNYEK VÉGE ----

            function updateSegmentOnServer(segmentIndex, newStart, newEnd, newText, newTranslatedText) {
                // Validáció
                if (segmentIndex < 0 || segmentIndex >= segmentsData.length) {
                    console.error('Invalid segment index:', segmentIndex);
                    return;
                }
                
                const originalSegment = JSON.parse(JSON.stringify(segmentsData[segmentIndex]));
                const previousHasSplit = Boolean(originalSegment.has_translated_split);
                const payload = {
                    json_file_name: currentJsonFileName,
                    segment_index: segmentIndex,
                    new_start: parseFloat(newStart.toFixed(3)),
                    new_end: parseFloat(newEnd.toFixed(3)),
                    new_text: newText,
                    new_translated_text: newTranslatedText
                };
                const startChanged = originalSegment.start !== payload.new_start || originalSegment.end !== payload.new_end;
                
                // Optimista frissítés
                segmentsData[segmentIndex].start = payload.new_start;
                segmentsData[segmentIndex].end = payload.new_end;
                segmentsData[segmentIndex].text = newText;
                segmentsData[segmentIndex].translated_text = newTranslatedText;
                if (startChanged) {
                    invalidateSegmentPositionCache();
                    if (wavesurfer && wavesurfer.options) {
                        debouncedRenderSegments(wavesurfer.options.minPxPerSec);
                    }
                }

                fetch(`/api/update-segment/${currentProjectName}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                })
                .then(response => response.ok ? response.json() : response.json().then(err => Promise.reject(err)))
                .then(data => {
                    if (!data.success) {
                        console.error('Szerver oldali hiba a mentéskor:', data.error);
                        alert(t('errors.segment_save', { error: data.error || t('errors.unknown') }));
                        // Rollback
                        segmentsData[segmentIndex] = originalSegment;
                        // Frissítjük a cache-t és a UI-t
                        segmentElementsCache.clear();
                        visibleSegments.clear();
                        invalidateSegmentPositionCache();
                        createTimelineSegments(wavesurfer.options.minPxPerSec);
                    } else {
                        if (typeof data.segment_index === 'number' && data.segment_index === segmentIndex && data.segment) {
                            sanitizeSegmentTexts([data.segment]);
                            segmentsData[segmentIndex].has_translated_split = data.segment.has_translated_split;
                        } else {
                            segmentsData[segmentIndex].has_translated_split = Boolean(segmentsData[segmentIndex].has_translated_split);
                        }
                        sanitizeSegmentTexts([segmentsData[segmentIndex]]);
                        const hasSplitChanged = previousHasSplit !== Boolean(segmentsData[segmentIndex].has_translated_split);
                        // Sikeres mentés esetén frissítjük a látható elemeket
                        if (visibleSegments.has(segmentIndex)) {
                            const element = segmentElementsCache.get(segmentIndex);
                            if (element) {
                                const originalTextarea = element.querySelector('.original-text');
                                const translatedTextarea = element.querySelector('.translated-text');
                                if (originalTextarea && originalTextarea.value !== newText) {
                                    originalTextarea.value = newText;
                                }
                                if (translatedTextarea && translatedTextarea.value !== newTranslatedText) {
                                    translatedTextarea.value = newTranslatedText;
                                }
                                const playbackButton = element.querySelector('.segment-audio-trigger');
                                configurePlaybackButton(playbackButton, segmentsData[segmentIndex]);
                            }
                        }
                        if (hasSplitChanged) {
                            fullRefreshUI();
                        }
                    }
                })
                .catch(error => {
                    console.error('Hálózati vagy egyéb hiba a mentéskor:', error);
                    alert(t('errors.segment_save', { error: error.error || error.message || t('errors.unknown') }));
                    // Rollback
                    segmentsData[segmentIndex] = originalSegment;
                    segmentElementsCache.clear();
                    visibleSegments.clear();
                    invalidateSegmentPositionCache();
                    createTimelineSegments(wavesurfer.options.minPxPerSec);
                });
            }


            try {
                wavesurfer = WaveSurfer.create({
                    container: '#waveform',
                    waveColor: 'rgb(200, 200, 200)',
                    progressColor: 'rgb(100, 100, 100)',
                    height: 128,
                    minPxPerSec: 10 
                });

                wavesurfer.on('ready', function () {
                    regionsPlugin = wavesurfer.registerPlugin(WaveSurfer.Regions.create());

                    regionsPlugin.on('region-updated', (region) => {
                        const originalIndex = regionIdToOriginalIndexMap[region.id];
                        if (typeof originalIndex === 'undefined') {
                            console.warn('Region updated but no mapping found for region ID:', region.id);
                            return;
                        }
                        if (originalIndex >= segmentsData.length) {
                            console.warn('Region index out of bounds:', originalIndex, 'segments length:', segmentsData.length);
                            return;
                        }
                        const segment = segmentsData[originalIndex];
                        const newStart = parseFloat(region.start.toFixed(3));
                        const newEnd = parseFloat(region.end.toFixed(3));
                        updateSegmentOnServer(originalIndex, newStart, newEnd, segment.text, segment.translated_text || '');
                    });

                    regionsPlugin.on('region-clicked', (region, e) => {
                        e.stopPropagation();
                        if (!wavesurfer) return;
                        if (wavesurfer.isPlaying()) {
                            wavesurfer.pause();
                            return;
                        }
                        focusPlaybackAt(region.start || 0);
                    });

                    setWaveformZoom(); 
                    updateWidths();    
                    
                    if (segmentsData.length > 0) {
                        segmentsData.forEach((segment, index) => {
                            try {
                                const region = regionsPlugin.addRegion({
                                    start: segment.start,
                                    end: segment.end,
                                    color: 'rgba(0, 123, 255, 0.1)',
                                    resize: true
                                });
                                regionIdToOriginalIndexMap[region.id] = index;
                            } catch (e) {
                                console.error(`Error adding region ${index}:`, e);
                            }
                        });
                    }
                    createTimelineSegments(wavesurfer.options.minPxPerSec); 
                });

                wavesurfer.on('zoom', (newMinPxPerSec) => {
                    updateWidths();
                    createTimelineSegments(newMinPxPerSec);
                });

                wavesurfer.on('error', (err) => console.error("Wavesurfer error:", err));

            } catch (e) {
                console.error('WaveSurfer core init error:', e);
            }

            const waveformElement = document.getElementById('waveform');
            waveformElement?.addEventListener('click', handleWaveformAreaClick);
            
            document.getElementById('playPauseBtn')?.addEventListener('click', () => wavesurfer.playPause());
            wavesurfer.on('play', () => document.getElementById('playPauseBtn').textContent = t('player.pause'));
            wavesurfer.on('pause', () => document.getElementById('playPauseBtn').textContent = t('header.play_button'));
            wavesurfer.on('finish', () => document.getElementById('playPauseBtn').textContent = t('header.play_button'));

            startProgressiveWaveformLoading();

            // Optimalizált scroll kezelés
            if (scrollWrapper) {
                // Wheel scroll optimalizálás
                scrollWrapper.addEventListener('wheel', (event) => {
                    if (event.deltaY !== 0) {
                        event.preventDefault();
                        event.currentTarget.scrollLeft += event.deltaY;
                    }
                }, { passive: false });
                
                // Scroll-alapú virtualizáció
                const debouncedScrollHandler = debounce(() => {
                    if (wavesurfer && wavesurfer.options) {
                        debouncedRenderSegments(wavesurfer.options.minPxPerSec);
                    }
                }, 16); // ~60fps
                
                scrollWrapper.addEventListener('scroll', debouncedScrollHandler);
            }
            
            if (segmentsTimelineContainer) {
                segmentsTimelineContainer.addEventListener('click', handleSegmentTimelineClick);
                // Event delegation a context menühöz
                segmentsTimelineContainer.addEventListener('contextmenu', function(event) {
                    const segmentContainer = event.target.closest('.timeline-segment-container');
                    if (segmentContainer && segmentContainer.dataset.segmentIndex) {
                        event.preventDefault();
                        event.stopPropagation();
                        currentContextMenuSegmentIndex = parseInt(segmentContainer.dataset.segmentIndex);
                        contextMenu.style.left = `${event.pageX}px`;
                        contextMenu.style.top = `${event.pageY}px`;
                        contextMenu.style.display = 'block';
                    }
                });
            }

            function fullRefreshUI() {
                regionsPlugin.clearRegions();
                regionIdToOriginalIndexMap = {};
                
                // Cache és látható szegmensek törlése
                segmentElementsCache.clear();
                visibleSegments.clear();
                segmentsTimelineContainer.innerHTML = '';
                lastZoomLevel = 0; // Reset zoom level to force cache clear
                invalidateSegmentPositionCache();
                
                // Regions újra létrehozása
                segmentsData.forEach((segment, index) => {
                    try {
                        const region = regionsPlugin.addRegion({
                            start: segment.start,
                            end: segment.end,
                            color: 'rgba(0, 123, 255, 0.1)',
                            resize: true
                        });
                        regionIdToOriginalIndexMap[region.id] = index;
                    } catch (e) {
                        console.error(`Error adding region ${index}:`, e);
                    }
                });
                
                createTimelineSegments(wavesurfer.options.minPxPerSec);
                updateWidths();
            }

            function insertNewSegmentAfter(clickedSegmentIndex) {
                const clickedSegment = segmentsData[clickedSegmentIndex];
                const newSegmentStartTime = clickedSegment.end;
                let nextExistingSegmentStartTime = wavesurfer.getDuration();
                for (let i = 0; i < segmentsData.length; i++) {
                    if (segmentsData[i].start > newSegmentStartTime && segmentsData[i].start < nextExistingSegmentStartTime) {
                        nextExistingSegmentStartTime = segmentsData[i].start;
                    }
                }
                let newSegmentEndTime = Math.min(newSegmentStartTime + 0.5, nextExistingSegmentStartTime, wavesurfer.getDuration());
                if (newSegmentEndTime - newSegmentStartTime < 0.05) {
                    alert(t('errors.segment_space'));
                    return;
                }
                const newSegmentPayload = {
                    json_file_name: currentJsonFileName,
                    start: parseFloat(newSegmentStartTime.toFixed(3)),
                    end: parseFloat(newSegmentEndTime.toFixed(3)),
                    text: ""
                };
                fetch(`/api/add-segment/${currentProjectName}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(newSegmentPayload)
                })
                .then(res => res.json())
                .then(data => {
                    if (data.success && data.segments) {
                        segmentsData = data.segments;
                        sanitizeSegmentTexts(segmentsData);
                        fullRefreshUI();
                    } else {
                        alert(t('errors.segment_add', { error: data.error || t('errors.unknown') }));
                    }
                })
                .catch(err => alert(t('errors.generic', { error: err.message })));
            }

            function deleteSegmentOnServer(segmentIndex) {
                fetch(`/api/delete-segment/${currentProjectName}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ json_file_name: currentJsonFileName, segment_index: segmentIndex })
                })
                .then(res => res.json())
                .then(data => {
                    if (data.success && data.segments) {
                        segmentsData = data.segments;
                        sanitizeSegmentTexts(segmentsData);
                        fullRefreshUI();
                    } else {
                        alert(t('errors.segment_delete', { error: data.error || t('errors.unknown') }));
                    }
                })
                .catch(err => alert(t('errors.generic', { error: err.message })));
            }

            function regenerateSegmentOnServer(segmentIndex) {
                if (currentJsonFileName === null || currentJsonFileName === undefined) {
                    alert(t('errors.missing_json'));
                    return;
                }
                const payload = {
                    json_file_name: currentJsonFileName,
                    segment_index: segmentIndex
                };
                fetch(`/api/regenerate-segment/${currentProjectName}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                })
                .then(res => res.json())
                .then(data => {
                    if (!data.success) {
                        alert(t('errors.regenerate_failed', { error: data.error || t('errors.unknown') }));
                        return;
                    }
                    const message = data.message || t('messages.regeneration_started');
                    if (regenerateLogModal) {
                        if (regenerateLogContent) {
                            regenerateLogContent.textContent = t('regenerate_modal.initial_log');
                        }
                        updateRegenerateStatus('queued', message);
                        regenerateLogModal.show();
                    } else {
                        alert(message);
                    }
                    if (data.job_id) {
                        startRegeneratePolling(data.job_id);
                    } else if (regenerateLogModal) {
                        if (regenerateAutoCloseTimeout) {
                            clearTimeout(regenerateAutoCloseTimeout);
                            regenerateAutoCloseTimeout = null;
                        }
                        regenerateLogContent.textContent = `${message}\n${t('regenerate_modal.no_job')}`;
                        regenerateAutoCloseTimeout = setTimeout(() => {
                            regenerateLogModal.hide();
                        }, 2000);
                    }
                })
                .catch(err => alert(t('errors.regenerate_error', { error: err.message || t('errors.unknown') })));
            }

            document.getElementById('menu-insert-segment').addEventListener('click', () => {
                if (currentContextMenuSegmentIndex !== -1) insertNewSegmentAfter(currentContextMenuSegmentIndex);
                contextMenu.style.display = 'none';
            });

            document.getElementById('menu-delete-segment').addEventListener('click', () => {
                if (
                    currentContextMenuSegmentIndex !== -1
                    && confirm(t('prompts.delete_confirm', { index: currentContextMenuSegmentIndex + 1 }))
                ) {
                    deleteSegmentOnServer(currentContextMenuSegmentIndex);
                }
                contextMenu.style.display = 'none';
            });

            document.getElementById('menu-regenerate-segment').addEventListener('click', () => {
                if (currentContextMenuSegmentIndex !== -1) {
                    regenerateSegmentOnServer(currentContextMenuSegmentIndex);
                }
                contextMenu.style.display = 'none';
            });

            document.addEventListener('click', (event) => {
                if (contextMenu.style.display === 'block' && !contextMenu.contains(event.target)) {
                    contextMenu.style.display = 'none';
                }
            });

        });
        console.log('[DEBUG 99] Script tag processing finished.');
    </script>

</body>
</html>
