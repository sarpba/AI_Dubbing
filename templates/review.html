<!DOCTYPE html>
<html lang="hu" data-bs-theme="auto">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aktív projekt: {{project_name}}</title>
    <link href="{{ url_for('static', filename='vendor/bootstrap/bootstrap.min.css') }}" rel="stylesheet">
    <script src="{{ url_for('static', filename='vendor/bootstrap/bootstrap.bundle.min.js') }}"></script>
    <link rel="stylesheet" href="{{url_for('static', filename='css/style.css')}}">
    {% if theme_colors %}
    <script id="themeColorsData" type="application/json">
        {{ theme_colors | tojson | safe }}
    </script>
    {% endif %}
    <script>
        (function() {
            const root = document.documentElement;
            const storageKey = 'theme';
            const systemMedia = window.matchMedia('(prefers-color-scheme: dark)');
            const themeColors = (() => {
                const el = document.getElementById('themeColorsData');
                if (!el) {
                    return null;
                }
                try {
                    return JSON.parse(el.textContent);
                } catch {
                    return null;
                }
            })();

            const getStoredPreference = () => localStorage.getItem(storageKey) || 'auto';

            const resolveTheme = preference => {
                if (preference === 'light' || preference === 'dark') {
                    return preference;
                }
                return systemMedia.matches ? 'dark' : 'light';
            };

            const applyThemeColors = effectiveTheme => {
                if (!themeColors) {
                    return;
                }

                const lightVars = themeColors.light || {};
                const darkVars = themeColors.dark || {};

                Object.entries(lightVars).forEach(([name, value]) => {
                    root.style.setProperty(`--${name}`, value);
                });

                if (effectiveTheme === 'dark') {
                    Object.entries(darkVars).forEach(([name, value]) => {
                        root.style.setProperty(`--${name}`, value);
                    });
                }
            };

            const applyTheme = preference => {
                const effectiveTheme = resolveTheme(preference);
                root.setAttribute('data-bs-theme', effectiveTheme);
                root.dataset.themePreference = preference;
                applyThemeColors(effectiveTheme);
            };

            const handleSystemChange = () => {
                const preference = root.dataset.themePreference || getStoredPreference();
                if (preference === 'auto') {
                    applyTheme('auto');
                }
            };

            if (typeof systemMedia.addEventListener === 'function') {
                systemMedia.addEventListener('change', handleSystemChange);
            } else if (typeof systemMedia.addListener === 'function') {
                systemMedia.addListener(handleSystemChange);
            }

            window.toggleTheme = function() {
                const currentPreference = root.dataset.themePreference || getStoredPreference();
                let nextPreference = 'auto';
                if (currentPreference === 'auto') {
                    nextPreference = 'light';
                } else if (currentPreference === 'light') {
                    nextPreference = 'dark';
                }
                localStorage.setItem(storageKey, nextPreference);
                applyTheme(nextPreference);
            };

            applyTheme(getStoredPreference());
        })();
    </script>
    <style>
        .floating-help-button {
            position: fixed;
            bottom: 1.5rem;
            right: 6.5rem;
            z-index: 1040;
        }

        @media (max-width: 576px) {
            .floating-help-button {
                bottom: 1rem;
                right: 5rem;
            }
        }
    </style>
</head>
<body>
    <div class="theme-controls">
        <button class="theme-toggle" onclick="toggleTheme()" aria-label="Téma váltása">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16">
            <path d="M8 11a3 3 0 1 1 0-6 3 3 0 0 1 0 6zm0 1a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z"/>
        </svg>
        </button>
    </div>

    <div class="modal fade" id="audioPreviewModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-lg modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="audioPreviewTitle">Audió szerkesztése</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Bezárás"></button>
                </div>
                <div class="modal-body">
                    <div class="audio-waveform mb-3">
                        <div id="audioWaveform"></div>
                        <div id="audioWaveformLoading" class="waveform-loading-overlay d-none">Betöltés...</div>
                    </div>
                    <div class="small text-muted">
                        Húzd az egeret a hullámformán a kijelöléshez, vagy állítsd a csúszkákkal a kezdő és záró pontot.
                    </div>
                    <div class="audio-trim-info d-flex flex-wrap align-items-center gap-3 mt-3">
                        <div>Kezdet: <span id="trimStartDisplay">—</span></div>
                        <div>Vége: <span id="trimEndDisplay">—</span></div>
                        <div>Hossz: <span id="trimDurationDisplay">—</span></div>
                    </div>
                    <div class="mt-3">
                        <label for="trimStartRange" class="form-label mb-1">Kezdőpont</label>
                        <input type="range" class="form-range" id="trimStartRange" min="0" max="0" step="0.01" value="0" disabled>
                    </div>
                    <div class="mt-3">
                        <label for="trimEndRange" class="form-label mb-1">Végpont</label>
                        <input type="range" class="form-range" id="trimEndRange" min="0" max="0" step="0.01" value="0" disabled>
                    </div>
                    <div class="d-flex flex-wrap gap-2 align-items-center mt-3">
                        <button type="button" class="btn btn-outline-secondary btn-sm" id="trimResetSelectionBtn" disabled>Teljes fájl kijelölése</button>
                        <span class="small text-muted">Mentéskor az eredeti fájl felülíródik.</span>
                    </div>
                    <div class="alert alert-danger py-2 px-3 small mt-3 d-none" id="trimErrorAlert"></div>
                </div>
                <div class="modal-footer">
                    <div class="me-auto d-flex align-items-center gap-2">
                        <div class="spinner-border spinner-border-sm text-primary d-none" role="status" id="trimSaveSpinner"></div>
                        <span class="small text-muted" id="trimStatusText"></span>
                    </div>
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Bezárás</button>
                    <button type="button" class="btn btn-primary" id="trimSaveBtn" disabled>Mentés</button>
                </div>
            </div>
        </div>
    </div>

    <div class="container-fluid mt-4">
    <div class="d-flex justify-content-between align-items-center mb-3">
        <h1>Aktív projekt: {{project_name}}</h1>
        <div>
            <a href="{{url_for('show_project', project_name=project_name)}}" class="btn btn-secondary me-2">Vissza a projekthez</a>
        </div>
    </div>

        {%if audio_url and segments_data%}
            <div class="mb-3">
                <p class="mb-1">Audio fájl: <strong>{{audio_file_name}}</strong></p>
                <p class="mb-1">JSON fájl: <strong>{{json_file_name}}</strong> ({{segments_data|length}} szegmens)</p>
            </div>
            <button id="playPauseBtn" class="btn btn-primary mb-3">Lejátszás</button>
            <div id="waveform-scroll-wrapper">
                <div id="waveform-content-area">
                    <div id="waveform"></div>
                    <div id="segments-timeline"></div>
                </div>
            </div>
        {%elif audio_url and not segments_data%}
            <div class="alert alert-warning" role="alert">
                Audio fájl betöltve ({{audio_file_name}}), de nincsenek megjeleníthető szegmensek a {{json_file_name if json_file_name else 'társított JSON fájlban'}}.
            </div>
        {%elif not audio_url%}
            <div class="alert alert-danger" role="alert">
                Nem található audio fájl a felülvizsgálathoz.
            </div>
        {%endif%}
    </div>

    <div class="container-fluid mb-5 px-4">
        <div class="alert alert-info mb-0" role="alert">
            Útmutatóra van szükséged? Kattints a jobb alsó sarokban lévő <strong>Súgó</strong> gombra a felülvizsgálati nézet részletes ismertetéséhez.
        </div>
    </div>

    <button type="button"
            class="btn btn-outline-info shadow floating-help-button"
            data-bs-toggle="modal"
            data-bs-target="#reviewHelpModal"
            aria-label="Felülvizsgálati nézet súgója">
        Súgó
    </button>

    <script src="{{ url_for('static', filename='vendor/wavesurfer/wavesurfer.min.js') }}"></script>
    <script src="{{ url_for('static', filename='vendor/wavesurfer/regions.min.js') }}"></script>
    <script src="{{ url_for('static', filename='js/audio-trimmer.js') }}"></script>
    <!-- Felugró menü HTML struktúrája -->
    <div id="segment-context-menu" class="custom-context-menu">
        <ul>
            <li id="menu-insert-segment">Szegmens beszúrása mögé</li>
            <li id="menu-delete-segment">Szegmens törlése</li>
            <li id="menu-regenerate-segment">Regenerálás (TTS)</li>
        </ul>
    </div>

    <div class="modal fade" id="reviewHelpModal" tabindex="-1" aria-labelledby="reviewHelpModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg modal-dialog-scrollable">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="reviewHelpModalLabel">Felülvizsgálati nézet súgó</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Bezárás"></button>
                </div>
                <div class="modal-body">
                    <p class="mb-3">
                        Ez a felület a kiválasztott projekt audió- és szöveg-szegmenseinek felülvizsgálatára szolgál. Itt ellenőrizheted, szerkesztheted és újragenerálhatod a tartalmakat, miközben folyamatosan visszajelzést kapsz az állapotokról.
                    </p>
                    <h6 class="fw-bold">Navigáció és fájlinformációk</h6>
                    <ul class="mb-4">
                        <li>A fejlécben látható az aktuális projekt neve, valamint a <em>Vissza a projekthez</em> gomb a projektoldalra ugráshoz.</li>
                        <li>A fájlinformációs blokk jelzi, mely audió és JSON fájl van betöltve, illetve hány szegmens áll rendelkezésre.</li>
                    </ul>
                    <h6 class="fw-bold">Lejátszás és idővonal</h6>
                    <ul class="mb-4">
                        <li>A felső <strong>Lejátszás</strong> gombbal indíthatod vagy állíthatod meg az audiót; lejátszás közben <em>Szünet</em>-re vált.</li>
                        <li>A hullámforma vízszintesen görgethető az egérgörgővel vagy az érintőpad vízszintes mozdulataival; a rendszer automatikusan alkalmazkodik a nagyobb felvételekhez.</li>
                        <li>A kék kiemelések a Wavesurfer régiói: kattintásra az adott szakasz játszódik le, az élek húzásával pedig a szegmens kezdő- és végpontja finomhangolható. A változtatások automatikusan mentésre kerülnek.</li>
                    </ul>
                    <h6 class="fw-bold">Szegmens szerkesztése</h6>
                    <ul class="mb-4">
                        <li>Minden szegmenshez két szövegmező tartozik: az eredeti és a fordított szöveg. A mezők mérete a tartalomhoz igazodik, így könnyen áttekinthetők a hosszabb mondatok is.</li>
                        <li>Kattintáskor a lejátszás megáll, a mező elhagyásakor (vagy Enter megnyomásával) a módosítás azonnal mentésre kerül a szerverre.</li>
                        <li>A rendszer a virtuális görgetésnek köszönhetően nagy projektek esetén is csak a látható szegmenseket tölti be, így a felület gyors marad.</li>
                    </ul>
                    <h6 class="fw-bold">Szegmens műveletek</h6>
                    <ul class="mb-4">
                        <li>Jobb gombbal a színes idővonalsávokra kattintva megjelenik a helyi menü, ahol új szegmens beszúrása, meglévő törlése vagy TTS regenerálás indítása érhető el.</li>
                        <li>Új szegmens beszúrásakor a rendszer automatikusan frissíti a sorszámozást, és szükség esetén lekéri az aktuális adatokat a szerverről.</li>
                        <li>Törléskor a kapcsolódó vizuális elemek és a Wavesurfer régiók is frissülnek, így a nézet mindig a naprakész állapotot mutatja.</li>
                    </ul>
                    <h6 class="fw-bold">TTS és audió kezelése</h6>
                    <ul class="mb-4">
                        <li>A szegmensek jobb oldalán található <strong>Lejátszás</strong> gomb akkor aktív, ha a szakaszhoz tartozik legenerált TTS. Kattintva megnyílik az audió előnézet, ahol az AudioTrimmer segítségével vághatod a hangot.</li>
                        <li>Ha még nincs TTS a szegmenshez, a gomb szürke és <em>Nincs TTS</em> feliratot kap, jelezve, hogy előbb regenerálni kell a hangot.</li>
                        <li>A TTS regenerálás után a rendszer automatikusan frissíti a gomb állapotát és elérhetővé teszi az új hangfájlt.</li>
                    </ul>
                    <h6 class="fw-bold">Regenerációs folyamat követése</h6>
                    <ul class="mb-4">
                        <li>A <em>Regenerálás (TTS)</em> művelet indításakor megjelenik a napló modal, amely folyamatosan mutatja a feldolgozás állapotát.</li>
                        <li>Sikeres befejezés után a napló automatikusan bezárul, szükség esetén manuálisan is zárható.</li>
                    </ul>
                    <h6 class="fw-bold">Hasznos tippek</h6>
                    <ul class="mb-0">
                        <li>Hosszú felvételeknél hagyd, hogy a görgetés pillanatnyilag betöltse a szegmenseket – a háttérben futó optimalizáció gondoskodik arról, hogy a teljesítmény ne csökkenjen.</li>
                        <li>Hibajelzés esetén a felület visszajelzést ad, a <em>Frissítés</em> műveletek pedig újratöltik a legfrissebb adatokat a szerverről.</li>
                    </ul>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Bezárás</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Regeneráció napló modal -->
    <div class="modal fade" id="regenerateLogModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-lg modal-dialog-scrollable">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">TTS regeneráció napló</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Bezárás" id="regenerateLogCloseBtn"></button>
                </div>
                <div class="modal-body">
                    <div class="log-modal-status mb-2" id="regenerateLogStatus">Feldolgozás előkészítése...</div>
                    <pre class="log-modal-pre" id="regenerateLogContent">Log inicializálása...</pre>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Bezárás</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        console.log('[DEBUG 01] Script tag processing started.');
        document.addEventListener('DOMContentLoaded', function () {
            console.log('[DEBUG 02] DOMContentLoaded event handler started.');
            
            const audioUrl = "{{audio_url|safe if audio_url else ''}}";
            const translatedSplitsDir = "{{ app_config.PROJECT_SUBDIRS.translated_splits | e }}";
            const currentProjectName = "{{project_name|safe}}";
            let segmentsDataString = '{{segments_data|tojson if segments_data else "[]"}}';
            let segmentsData = JSON.parse(segmentsDataString);
            const regenerateLogModalElement = document.getElementById('regenerateLogModal');
            let regenerateLogModal = null;
            let regenerateLogContent = document.getElementById('regenerateLogContent');
            let regenerateLogStatusText = document.getElementById('regenerateLogStatus');
            let regenerateLogPollTimer = null;
            let regenerateActiveJobId = null;
            let regenerateAutoCloseTimeout = null;
            let regenerateHasRefreshed = false;

            if (regenerateLogModalElement && typeof bootstrap !== 'undefined') {
                regenerateLogModal = new bootstrap.Modal(regenerateLogModalElement, {
                    backdrop: 'static',
                    keyboard: false
                });
            }

            const buildWorkdirUrl = (relativePath) => {
                const segments = [currentProjectName];
                if (relativePath) {
                    String(relativePath)
                        .replace(/^\/+/, '')
                        .split('/')
                        .forEach(part => {
                            if (part) {
                                segments.push(part);
                            }
                        });
                }
                const encoded = segments.map(part => encodeURIComponent(part));
                return `/workdir/${encoded.join('/')}`;
            };

            function ensureAudioTrimmer() {
                if (window.AudioTrimmer && typeof window.AudioTrimmer.init === 'function') {
                    window.AudioTrimmer.init({
                        projectName: currentProjectName,
                        buildWorkdirUrl,
                        refreshDirectory: () => {},
                        reloadFileBrowser: () => {},
                        cssEscape: (value) => value
                    });
                }
            }

            function generateSegmentAudioRelativePath(segment) {
                if (!translatedSplitsDir || !segment || !segment.has_translated_split) {
                    return null;
                }
                const startTimeFormatted = formatTimeForFilename(segment.start);
                const endTimeFormatted = formatTimeForFilename(segment.end);
                const wavFilename = `${startTimeFormatted}_${endTimeFormatted}.wav`;
                return `${translatedSplitsDir}/${wavFilename}`;
            }

            function openSegmentAudioModal(segment) {
                ensureAudioTrimmer();
                const relativePath = generateSegmentAudioRelativePath(segment);
                if (!relativePath) {
                    return;
                }
                const fileUrl = buildWorkdirUrl(relativePath);
                const fileName = relativePath.split('/').pop();
                if (window.AudioTrimmer && typeof window.AudioTrimmer.showPreview === 'function') {
                    try {
                        window.AudioTrimmer.showPreview(fileName, fileUrl, relativePath);
                        return;
                    } catch (error) {
                        console.error('AudioTrimmer előnézeti hiba:', error);
                    }
                }
                window.open(fileUrl, '_blank');
            }

            function configurePlaybackButton(button, segment) {
                if (!button) {
                    return;
                }
                const hasAudio = Boolean(segment && segment.has_translated_split && translatedSplitsDir);
                button.disabled = !hasAudio;
                button.classList.toggle('btn-outline-primary', hasAudio);
                button.classList.toggle('btn-outline-secondary', !hasAudio);
                button.textContent = hasAudio ? 'Lejátszás' : 'Nincs TTS';
                button.title = hasAudio ? 'Megnyitja a szegmens audióját a modális lejátszóban' : 'Ehhez a szegmenshez még nincs TTS hang.';
            }

            ensureAudioTrimmer();
            function sanitizeSegmentTexts(segments) {
                if (!Array.isArray(segments)) {
                    return;
                }
                segments.forEach(segment => {
                    if (!segment || typeof segment !== 'object') {
                        return;
                    }
                    ['text', 'translated_text'].forEach(key => {
                        if (typeof segment[key] === 'string') {
                            segment[key] = segment[key].replace(/\\"/g, '"');
                        }
                    });
                    segment.has_translated_split = Boolean(segment.has_translated_split);
                });
            }
            sanitizeSegmentTexts(segmentsData);
            const positionsCache = new Map();

            function invalidateSegmentPositionCache() {
                positionsCache.clear();
            }

            function stopRegeneratePolling() {
                if (regenerateLogPollTimer) {
                    clearInterval(regenerateLogPollTimer);
                    regenerateLogPollTimer = null;
                }
                if (regenerateAutoCloseTimeout) {
                    clearTimeout(regenerateAutoCloseTimeout);
                    regenerateAutoCloseTimeout = null;
                }
                regenerateActiveJobId = null;
                regenerateHasRefreshed = false;
            }

            if (regenerateLogModalElement) {
                regenerateLogModalElement.addEventListener('hidden.bs.modal', () => {
                    stopRegeneratePolling();
                });
            }

            function updateRegenerateStatus(status, message) {
                const statusMap = {
                    queued: 'Feladat sorban áll...',
                    running: 'Feldolgozás folyamatban...',
                    cancelling: 'Megszakítás folyamatban...',
                    cancelled: 'Feladat megszakítva.',
                    completed: 'Feldolgozás sikeresen befejeződött.',
                    failed: 'Feldolgozás sikertelen.'
                };
                const statusLabel = statusMap[status] || 'Állapot frissítése...';
                const combined = message ? `${statusLabel} ${message}` : statusLabel;
                if (regenerateLogStatusText) {
                    regenerateLogStatusText.textContent = combined;
                }
            }

            function startRegeneratePolling(jobId) {
                stopRegeneratePolling();
                regenerateActiveJobId = jobId;
                if (regenerateLogContent) {
                    regenerateLogContent.textContent = 'Log inicializálása...';
                }
                updateRegenerateStatus('queued', '');
                const poll = () => pollRegenerateJob();
                poll();
                regenerateLogPollTimer = setInterval(poll, 3000);
            }

            function pollRegenerateJob() {
                if (!regenerateActiveJobId) {
                    return;
                }
                fetch(`/api/workflow-log/${regenerateActiveJobId}`)
                    .then(res => res.json())
                    .then(data => {
                        if (!data.success) {
                            if (regenerateLogContent) {
                                regenerateLogContent.textContent = `Log lekérdezési hiba: ${data.error || 'Ismeretlen hiba'}`;
                            }
                            updateRegenerateStatus('failed', '');
                            stopRegeneratePolling();
                            return;
                        }
                        if (regenerateLogContent) {
                            if (data.log_available && data.log) {
                                regenerateLogContent.textContent = data.log;
                                regenerateLogContent.scrollTop = regenerateLogContent.scrollHeight;
                            } else if (!data.log_available) {
                                regenerateLogContent.textContent = 'A log előkészítése folyamatban...';
                            }
                        }
                        updateRegenerateStatus(data.status, data.message);
                        if (data.completed) {
                            stopRegeneratePolling();
                            if (!regenerateHasRefreshed) {
                                regenerateHasRefreshed = true;
                                refreshSegmentsFromServer();
                            }
                            if (data.status === 'completed' && regenerateLogModal) {
                                regenerateAutoCloseTimeout = setTimeout(() => {
                                    regenerateLogModal.hide();
                                }, 2000);
                            }
                        }
                    })
                    .catch(err => {
                        if (regenerateLogContent) {
                            regenerateLogContent.textContent = `Log lekérdezési hiba: ${err.message}`;
                        }
                        updateRegenerateStatus('failed', '');
                        stopRegeneratePolling();
                    });
            }

            function refreshSegmentsFromServer() {
                if (currentJsonFileName === null || currentJsonFileName === undefined) {
                    return;
                }
                fetch(`/api/get-segments/${currentProjectName}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ json_file_name: currentJsonFileName })
                })
                .then(res => res.json())
                .then(data => {
                    if (!data.success || !Array.isArray(data.segments)) {
                        console.warn('Nem sikerült frissíteni a szegmenseket:', data.error);
                        return;
                    }
                    segmentsData = data.segments;
                    sanitizeSegmentTexts(segmentsData);
                    invalidateSegmentPositionCache();
                    ensureAudioTrimmer();
                    fullRefreshUI();
                })
                .catch(err => console.error('Szegmens frissítés hiba:', err));
            }

            function getSegmentPositions(currentPxPerSec) {
                const cacheKey = currentPxPerSec.toFixed(2);
                if (!positionsCache.has(cacheKey)) {
                    positionsCache.set(cacheKey, calculateSegmentPositions(segmentsData, currentPxPerSec));
                }
                return positionsCache.get(cacheKey);
            }
            
            let currentJsonFileNameString = '{{json_file_name|tojson if json_file_name else "null"}}';
            let currentJsonFileName = (currentJsonFileNameString && currentJsonFileNameString !== 'null') ? JSON.parse(currentJsonFileNameString) : null;

            if (!audioUrl) {
                console.error('[DEBUG 03] Audio URL hiányzik.');
                const playButton = document.getElementById('playPauseBtn');
                if(playButton) playButton.disabled = true;
                return;
            }
            console.log('[DEBUG 03] Audio URL:', audioUrl);

            if (segmentsData.length === 0 && audioUrl) {
                console.info('[DEBUG 04] Nincsenek szegmensek.');
            } else if (segmentsData.length > 0) {
                console.log('[DEBUG 04] Segments count:', segmentsData.length);
            }

            let wavesurfer;
            let regionsPlugin;
            let regionIdToOriginalIndexMap = {}; 
            let activelyLoopingRegionId = null;

            const contextMenu = document.getElementById('segment-context-menu');
            let currentContextMenuSegmentIndex = -1;

            // ---- ÚJ FÜGGVÉNYEK ----
            /**
             * Egy textarea elem magasságát a tartalmához igazítja.
             * @param {HTMLTextAreaElement} textarea - Az átméretezendő szövegdoboz.
             */
            function autoResizeTextarea(textarea) {
                textarea.style.height = 'auto';
                textarea.style.height = (textarea.scrollHeight) + 'px';
            }

            /**
             * Frissíti az idővonal konténerének magasságát a benne lévő elemek alapján.
             */
            function updateTimelineContainerHeight() {
                const segmentsTimelineContainer = document.getElementById('segments-timeline');
                if (!segmentsTimelineContainer) return;
                const timelineChildren = segmentsTimelineContainer.children;
                let maxBottom = 0;
                if (timelineChildren.length > 0) {
                    for (let i = 0; i < timelineChildren.length; i++) {
                        const child = timelineChildren[i];
                        if (child.style.display === 'none') continue;
                        const childBottom = parseFloat(child.style.top) + child.offsetHeight;
                        if (childBottom > maxBottom) {
                            maxBottom = childBottom;
                        }
                    }
                    segmentsTimelineContainer.style.height = `${maxBottom + 20}px`;
                } else {
                    segmentsTimelineContainer.style.height = '50px';
                }
            }

            /**
             * Formats time in seconds to HH-MM-SS-mmm string for filenames.
             * @param {number} timeInSeconds - The time value in seconds.
             * @returns {string} The formatted time string.
             */
            function formatTimeForFilename(timeInSeconds) {
                if (typeof timeInSeconds !== 'number' || isNaN(timeInSeconds)) {
                    console.error("Invalid time provided to formatTimeForFilename:", timeInSeconds);
                    return '00-00-00-000';
                }
                // Handle potential floating point inaccuracies by rounding to nearest millisecond
                const totalMilliseconds = Math.round(timeInSeconds * 1000);
                const hours = Math.floor(totalMilliseconds / 3600000);
                const minutes = Math.floor((totalMilliseconds % 3600000) / 60000);
                const seconds = Math.floor((totalMilliseconds % 60000) / 1000);
                const milliseconds = totalMilliseconds % 1000;

                return [
                    String(hours).padStart(2, '0'),
                    String(minutes).padStart(2, '0'),
                    String(seconds).padStart(2, '0'),
                    String(milliseconds).padStart(3, '0')
                ].join('-');
            }
            // ---- FÜGGVÉNYEK VÉGE ----

            // Függvények definíciói
            function setWaveformZoom() {
                const scrollWrapper = document.getElementById('waveform-scroll-wrapper');
                if (wavesurfer && scrollWrapper) {
                    const audioDuration = wavesurfer.getDuration();
                    const containerWidth = scrollWrapper.clientWidth;
                    const secondsToShow = 20;

                    if (audioDuration > 0 && containerWidth > 0) {
                        let newMinPxPerSec = containerWidth / Math.min(secondsToShow, audioDuration);
                        newMinPxPerSec = Math.max(10, newMinPxPerSec);
                        wavesurfer.zoom(newMinPxPerSec);
                    } else if (containerWidth > 0) {
                        wavesurfer.zoom(10);
                    }
                }
            }
            
            const segmentsTimelineContainer = document.getElementById('segments-timeline');
            const waveformContentArea = document.getElementById('waveform-content-area');

            function updateWidths() {
                if (!wavesurfer || !wavesurfer.getWrapper() || !waveformContentArea || !segmentsTimelineContainer) return;
                try {
                    const fullAudioPixelWidth = wavesurfer.getWrapper().scrollWidth;
                    waveformContentArea.style.width = `${fullAudioPixelWidth}px`;
                    segmentsTimelineContainer.style.width = `${fullAudioPixelWidth}px`;
                } catch (e) {
                    console.error("Error in updateWidths:", e);
                }
            }
            
            // ---- OPTIMALIZÁLT FÜGGVÉNYEK ----
            
            // Virtualizáció és teljesítmény optimalizálás
            let segmentElementsCache = new Map();
            let visibleSegments = new Set();
            let renderQueue = [];
            let isRendering = false;
            let lastScrollLeft = 0;
            let lastZoomLevel = 0;
            
            // Debounce függvény
            function debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const context = this;
                    const later = () => {
                        clearTimeout(timeout);
                        func.apply(context, args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }
            
            // Optimalizált collision detection - O(n log n) helyett O(n²)
            function calculateSegmentPositions(segments, currentPxPerSec) {
                const verticalGap = 5;
                const positions = [];
                const rows = [];
                
                // Szegmensek rendezése start idő szerint
                const sortedSegments = segments.map((segment, index) => ({
                    ...segment,
                    originalIndex: index,
                    leftPx: segment.start * currentPxPerSec,
                    widthPx: Math.max((segment.end - segment.start) * currentPxPerSec - 10, 150)
                })).sort((a, b) => a.start - b.start);
                
                sortedSegments.forEach(segment => {
                    let rowIndex = 0;
                    let placed = false;
                    
                    while (!placed) {
                        if (!rows[rowIndex]) {
                            rows[rowIndex] = [];
                        }
                        
                        // Ellenőrizzük az ütközést az aktuális sorban
                        let hasCollision = false;
                        for (const existingSegment of rows[rowIndex]) {
                            if (segment.leftPx < existingSegment.rightPx &&
                                segment.leftPx + segment.widthPx > existingSegment.leftPx) {
                                hasCollision = true;
                                break;
                            }
                        }
                        
                        if (!hasCollision) {
                            const segmentData = {
                                leftPx: segment.leftPx,
                                rightPx: segment.leftPx + segment.widthPx,
                                rowIndex: rowIndex
                            };
                            rows[rowIndex].push(segmentData);
                            positions[segment.originalIndex] = {
                                top: rowIndex * (80 + verticalGap), // Becsült sor magasság
                                left: segment.leftPx,
                                width: segment.widthPx
                            };
                            placed = true;
                        } else {
                            rowIndex++;
                        }
                    }
                });
                
                return positions;
            }
            
            // Viewport alapú virtualizáció
            function getVisibleSegmentIndices(scrollLeft, viewportWidth, currentPxPerSec) {
                const buffer = viewportWidth * 0.5; // 50% buffer mindkét oldalon
                const startTime = Math.max(0, (scrollLeft - buffer) / currentPxPerSec);
                const endTime = (scrollLeft + viewportWidth + buffer) / currentPxPerSec;
                
                const visibleIndices = [];
                segmentsData.forEach((segment, index) => {
                    if (segment.end >= startTime && segment.start <= endTime) {
                        visibleIndices.push(index);
                    }
                });
                
                return visibleIndices;
            }
            
            // Aszinkron DOM elem létrehozás
            function createSegmentElement(segment, index, position, currentPxPerSec) {
                return new Promise((resolve) => {
                    requestAnimationFrame(() => {
                        const segmentContainer = document.createElement('div');
                        segmentContainer.className = 'timeline-segment-container';
                        segmentContainer.style.position = 'absolute';
                        segmentContainer.style.left = `${position.left}px`;
                        segmentContainer.style.top = `${position.top}px`;
                        segmentContainer.style.width = `${position.width}px`;
                        segmentContainer.dataset.segmentIndex = index;
                        const hasTranslatedSplit = Boolean(segment.has_translated_split);

                        const originalTextarea = document.createElement('textarea');
                        originalTextarea.className = 'timeline-segment form-control form-control-sm original-text';
                        originalTextarea.value = segment.text;
                        originalTextarea.placeholder = "Original text";
                        originalTextarea.style.resize = 'none';
                        originalTextarea.style.overflowY = 'hidden';
                        originalTextarea.title = `[${segment.start.toFixed(2)}s - ${segment.end.toFixed(2)}s]`;

                        const translatedTextarea = document.createElement('textarea');
                        translatedTextarea.className = 'timeline-segment form-control form-control-sm translated-text';
                        translatedTextarea.value = segment.translated_text || '';
                        translatedTextarea.placeholder = segment.translated_text ? "Fordított szöveg" : "Nincs fordítás";
                        translatedTextarea.style.resize = 'none';
                        translatedTextarea.style.overflowY = 'hidden';
                        translatedTextarea.title = `[${segment.start.toFixed(2)}s - ${segment.end.toFixed(2)}s]`;

                        segmentContainer.appendChild(originalTextarea);
                        segmentContainer.appendChild(translatedTextarea);

                        const playbackWrapper = document.createElement('div');
                        playbackWrapper.className = 'd-flex flex-wrap gap-2 align-items-center';

                        const playbackButton = document.createElement('button');
                        playbackButton.type = 'button';
                        playbackButton.className = 'btn btn-sm btn-outline-primary segment-audio-trigger';
                        playbackButton.addEventListener('click', () => {
                            const latestSegment = segmentsData[index] || segment;
                            if (latestSegment && latestSegment.has_translated_split) {
                                openSegmentAudioModal(latestSegment);
                            }
                        });
                        configurePlaybackButton(playbackButton, segment);
                        playbackWrapper.appendChild(playbackButton);

                        segmentContainer.appendChild(playbackWrapper);

                        autoResizeTextarea(originalTextarea);
                        autoResizeTextarea(translatedTextarea);
                        
                        resolve({ element: segmentContainer, index, originalTextarea, translatedTextarea, playbackButton });
                    });
                });
            }
            
            // Batch DOM műveletek
            async function renderVisibleSegments(currentPxPerSec) {
                if (isRendering) return;
                isRendering = true;
                
                try {
                    const scrollWrapper = document.getElementById('waveform-scroll-wrapper');
                    const scrollLeft = scrollWrapper ? scrollWrapper.scrollLeft : 0;
                    const viewportWidth = scrollWrapper ? scrollWrapper.clientWidth : 1000;
                    
                    const visibleIndices = getVisibleSegmentIndices(scrollLeft, viewportWidth, currentPxPerSec);
                    const positions = getSegmentPositions(currentPxPerSec);
                    
                    // Eltávolítjuk a már nem látható szegmenseket
                    const elementsToRemove = [];
                    visibleSegments.forEach(index => {
                        if (!visibleIndices.includes(index)) {
                            const element = segmentElementsCache.get(index);
                            if (element && element.parentNode) {
                                elementsToRemove.push(element);
                            }
                            visibleSegments.delete(index);
                        }
                    });
                    
                    // Batch removal
                    elementsToRemove.forEach(element => {
                        segmentsTimelineContainer.removeChild(element);
                    });
                    
                    // Új látható szegmensek hozzáadása
                    const newSegments = visibleIndices.filter(index => !visibleSegments.has(index));
                    const renderPromises = [];
                    
                    for (const index of newSegments) {
                        if (!segmentElementsCache.has(index)) {
                            const segment = segmentsData[index];
                            const position = positions[index];
                            if (segment && position) {
                                renderPromises.push(createSegmentElement(segment, index, position, currentPxPerSec));
                            }
                        } else {
                            // Ha már van cache-elt elem, de nem látható, hozzáadjuk a láthatókhoz
                            const cachedElement = segmentElementsCache.get(index);
                            if (cachedElement && !cachedElement.parentNode) {
                                visibleSegments.add(index);
                                const position = positions[index];
                                if (position) {
                                    cachedElement.style.left = `${position.left}px`;
                                    cachedElement.style.top = `${position.top}px`;
                                    cachedElement.style.width = `${position.width}px`;
                                    const cachedButton = cachedElement.querySelector('.segment-audio-trigger');
                                    configurePlaybackButton(cachedButton, segmentsData[index]);
                                    segmentsTimelineContainer.appendChild(cachedElement);
                                }
                            }
                        }
                    }
                    
                    // Várjuk meg az összes új elem létrehozását
                    const newElements = await Promise.all(renderPromises);
                    
                    // Batch DOM insertion
                    const fragment = document.createDocumentFragment();
                    newElements.forEach(({ element, index, originalTextarea, translatedTextarea, playbackButton }) => {
                        segmentElementsCache.set(index, element);
                        visibleSegments.add(index);
                        configurePlaybackButton(playbackButton, segmentsData[index]);
                        fragment.appendChild(element);
                        
                        // Event listeners hozzáadása az új elemekhez
                        attachSegmentEventListeners(originalTextarea, translatedTextarea, index);
                    });
                    
                    segmentsTimelineContainer.appendChild(fragment);
                    
                    // Meglévő elemek pozíciójának frissítése
                    visibleIndices.forEach(index => {
                        if (segmentElementsCache.has(index) && !newSegments.includes(index)) {
                            const element = segmentElementsCache.get(index);
                            const position = positions[index];
                            element.style.left = `${position.left}px`;
                            element.style.top = `${position.top}px`;
                            element.style.width = `${position.width}px`;
                            const playbackButton = element.querySelector('.segment-audio-trigger');
                            configurePlaybackButton(playbackButton, segmentsData[index]);
                        }
                    });
                    
                    updateTimelineContainerHeight();
                    
                } finally {
                    isRendering = false;
                }
            }
            
            // Event listener csatolás
            function attachSegmentEventListeners(originalTextarea, translatedTextarea, index) {
                [originalTextarea, translatedTextarea].forEach(textarea => {
                    textarea.addEventListener('input', debounce(function() {
                        autoResizeTextarea(this);
                        updateTimelineContainerHeight();
                    }, 100));
                    
                    textarea.addEventListener('keydown', function(event) {
                        if (event.key === 'Enter') {
                            event.preventDefault();
                            this.blur();
                        }
                    });
                    
                    textarea.addEventListener('focus', function() {
                        autoResizeTextarea(this);
                        updateTimelineContainerHeight();
                    });

                    textarea.addEventListener('click', function() {
                        wavesurfer.pause();
                        autoResizeTextarea(this);
                        updateTimelineContainerHeight();
                    });
                    // Double-click esemény eltávolítva - event delegation használjuk helyette
                });
                
                originalTextarea.addEventListener('blur', function() {
                    const newText = this.value;
                    const segment = segmentsData[index];
                    if (newText !== segment.text) {
                        updateSegmentOnServer(index, segment.start, segment.end, newText, segment.translated_text || '');
                    }
                });

                translatedTextarea.addEventListener('blur', function() {
                    const newTranslated = this.value;
                    const segment = segmentsData[index];
                    if (newTranslated !== (segment.translated_text || '')) {
                        updateSegmentOnServer(index, segment.start, segment.end, segment.text, newTranslated);
                    }
                });
            }
            
            // Optimalizált fő függvény
            const debouncedRenderSegments = debounce(renderVisibleSegments, 50);
            
            function createTimelineSegments(currentPxPerSec) {
                console.log(`[TIMELINE] Creating timeline segments, count: ${segmentsData.length}, pxPerSec: ${currentPxPerSec}`);
                
                if (!segmentsTimelineContainer || !wavesurfer || segmentsData.length === 0) {
                    if (segmentsTimelineContainer) {
                        segmentsTimelineContainer.innerHTML = '';
                        console.log('[TIMELINE] Cleared timeline container - no segments or missing dependencies');
                    }
                    return;
                }
                
                // Ha a zoom szint jelentősen változott, tisztítsuk a cache-t
                if (Math.abs(currentPxPerSec - lastZoomLevel) > 1) {
                    console.log(`[TIMELINE] Zoom level changed significantly: ${lastZoomLevel} -> ${currentPxPerSec}, clearing cache`);
                    segmentElementsCache.clear();
                    visibleSegments.clear();
                    segmentsTimelineContainer.innerHTML = '';
                    invalidateSegmentPositionCache();
                    lastZoomLevel = currentPxPerSec;
                }
                
                debouncedRenderSegments(currentPxPerSec);
            }
            // ---- OPTIMALIZÁLT FÜGGVÉNYEK VÉGE ----

            function updateSegmentOnServer(segmentIndex, newStart, newEnd, newText, newTranslatedText) {
                // Validáció
                if (segmentIndex < 0 || segmentIndex >= segmentsData.length) {
                    console.error('Invalid segment index:', segmentIndex);
                    return;
                }
                
                const originalSegment = JSON.parse(JSON.stringify(segmentsData[segmentIndex]));
                const previousHasSplit = Boolean(originalSegment.has_translated_split);
                const payload = {
                    json_file_name: currentJsonFileName,
                    segment_index: segmentIndex,
                    new_start: parseFloat(newStart.toFixed(3)),
                    new_end: parseFloat(newEnd.toFixed(3)),
                    new_text: newText,
                    new_translated_text: newTranslatedText
                };
                const startChanged = originalSegment.start !== payload.new_start || originalSegment.end !== payload.new_end;
                
                // Optimista frissítés
                segmentsData[segmentIndex].start = payload.new_start;
                segmentsData[segmentIndex].end = payload.new_end;
                segmentsData[segmentIndex].text = newText;
                segmentsData[segmentIndex].translated_text = newTranslatedText;
                if (startChanged) {
                    invalidateSegmentPositionCache();
                    if (wavesurfer && wavesurfer.options) {
                        debouncedRenderSegments(wavesurfer.options.minPxPerSec);
                    }
                }

                fetch(`/api/update-segment/${currentProjectName}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                })
                .then(response => response.ok ? response.json() : response.json().then(err => Promise.reject(err)))
                .then(data => {
                    if (!data.success) {
                        console.error('Szerver oldali hiba a mentéskor:', data.error);
                        alert(`Hiba a szegmens mentésekor: ${data.error}`);
                        // Rollback
                        segmentsData[segmentIndex] = originalSegment;
                        // Frissítjük a cache-t és a UI-t
                        segmentElementsCache.clear();
                        visibleSegments.clear();
                        invalidateSegmentPositionCache();
                        createTimelineSegments(wavesurfer.options.minPxPerSec);
                    } else {
                        if (typeof data.segment_index === 'number' && data.segment_index === segmentIndex && data.segment) {
                            sanitizeSegmentTexts([data.segment]);
                            segmentsData[segmentIndex].has_translated_split = data.segment.has_translated_split;
                        } else {
                            segmentsData[segmentIndex].has_translated_split = Boolean(segmentsData[segmentIndex].has_translated_split);
                        }
                        sanitizeSegmentTexts([segmentsData[segmentIndex]]);
                        const hasSplitChanged = previousHasSplit !== Boolean(segmentsData[segmentIndex].has_translated_split);
                        // Sikeres mentés esetén frissítjük a látható elemeket
                        if (visibleSegments.has(segmentIndex)) {
                            const element = segmentElementsCache.get(segmentIndex);
                            if (element) {
                                const originalTextarea = element.querySelector('.original-text');
                                const translatedTextarea = element.querySelector('.translated-text');
                                if (originalTextarea && originalTextarea.value !== newText) {
                                    originalTextarea.value = newText;
                                }
                                if (translatedTextarea && translatedTextarea.value !== newTranslatedText) {
                                    translatedTextarea.value = newTranslatedText;
                                }
                                const playbackButton = element.querySelector('.segment-audio-trigger');
                                configurePlaybackButton(playbackButton, segmentsData[segmentIndex]);
                            }
                        }
                        if (hasSplitChanged) {
                            fullRefreshUI();
                        }
                    }
                })
                .catch(error => {
                    console.error('Hálózati vagy egyéb hiba a mentéskor:', error);
                    alert(`Hiba a szegmens mentésekor: ${error.error || error.message || 'Ismeretlen hiba'}`);
                    // Rollback
                    segmentsData[segmentIndex] = originalSegment;
                    segmentElementsCache.clear();
                    visibleSegments.clear();
                    invalidateSegmentPositionCache();
                    createTimelineSegments(wavesurfer.options.minPxPerSec);
                });
            }


            try {
                wavesurfer = WaveSurfer.create({
                    container: '#waveform',
                    url: audioUrl,
                    waveColor: 'rgb(200, 200, 200)',
                    progressColor: 'rgb(100, 100, 100)',
                    height: 128,
                    minPxPerSec: 10 
                });

                wavesurfer.on('ready', function () {
                    regionsPlugin = wavesurfer.registerPlugin(WaveSurfer.Regions.create());

                    regionsPlugin.on('region-updated', (region) => {
                        const originalIndex = regionIdToOriginalIndexMap[region.id];
                        if (typeof originalIndex === 'undefined') {
                            console.warn('Region updated but no mapping found for region ID:', region.id);
                            return;
                        }
                        if (originalIndex >= segmentsData.length) {
                            console.warn('Region index out of bounds:', originalIndex, 'segments length:', segmentsData.length);
                            return;
                        }
                        const segment = segmentsData[originalIndex];
                        const newStart = parseFloat(region.start.toFixed(3));
                        const newEnd = parseFloat(region.end.toFixed(3));
                        updateSegmentOnServer(originalIndex, newStart, newEnd, segment.text, segment.translated_text || '');
                    });

                    regionsPlugin.on('region-clicked', (region, e) => {
                        e.stopPropagation();
                        region.play();
                    });

                    setWaveformZoom(); 
                    updateWidths();    
                    
                    if (segmentsData.length > 0) {
                        segmentsData.forEach((segment, index) => {
                            try {
                                const region = regionsPlugin.addRegion({
                                    start: segment.start,
                                    end: segment.end,
                                    color: 'rgba(0, 123, 255, 0.1)',
                                    resize: true
                                });
                                regionIdToOriginalIndexMap[region.id] = index;
                            } catch (e) {
                                console.error(`Error adding region ${index}:`, e);
                            }
                        });
                    }
                    createTimelineSegments(wavesurfer.options.minPxPerSec); 
                });

                wavesurfer.on('zoom', (newMinPxPerSec) => {
                    updateWidths();
                    createTimelineSegments(newMinPxPerSec);
                });

                wavesurfer.on('error', (err) => console.error("Wavesurfer error:", err));

            } catch (e) {
                console.error('WaveSurfer core init error:', e);
            }
            
            document.getElementById('playPauseBtn')?.addEventListener('click', () => wavesurfer.playPause());
            wavesurfer.on('play', () => document.getElementById('playPauseBtn').textContent = 'Szünet');
            wavesurfer.on('pause', () => document.getElementById('playPauseBtn').textContent = 'Lejátszás');
            wavesurfer.on('finish', () => document.getElementById('playPauseBtn').textContent = 'Lejátszás');

            // Optimalizált scroll kezelés
            const scrollWrapper = document.getElementById('waveform-scroll-wrapper');
            if (scrollWrapper) {
                // Wheel scroll optimalizálás
                scrollWrapper.addEventListener('wheel', (event) => {
                    if (event.deltaY !== 0) {
                        event.preventDefault();
                        event.currentTarget.scrollLeft += event.deltaY;
                    }
                }, { passive: false });
                
                // Scroll-alapú virtualizáció
                const debouncedScrollHandler = debounce(() => {
                    if (wavesurfer && wavesurfer.options) {
                        debouncedRenderSegments(wavesurfer.options.minPxPerSec);
                    }
                }, 16); // ~60fps
                
                scrollWrapper.addEventListener('scroll', debouncedScrollHandler);
            }
            
            // Event delegation a context menühöz
            segmentsTimelineContainer.addEventListener('contextmenu', function(event) {
                const segmentContainer = event.target.closest('.timeline-segment-container');
                if (segmentContainer && segmentContainer.dataset.segmentIndex) {
                    event.preventDefault();
                    event.stopPropagation();
                    currentContextMenuSegmentIndex = parseInt(segmentContainer.dataset.segmentIndex);
                    contextMenu.style.left = `${event.pageX}px`;
                    contextMenu.style.top = `${event.pageY}px`;
                    contextMenu.style.display = 'block';
                }
            });

            function fullRefreshUI() {
                regionsPlugin.clearRegions();
                regionIdToOriginalIndexMap = {};
                
                // Cache és látható szegmensek törlése
                segmentElementsCache.clear();
                visibleSegments.clear();
                segmentsTimelineContainer.innerHTML = '';
                lastZoomLevel = 0; // Reset zoom level to force cache clear
                invalidateSegmentPositionCache();
                
                // Regions újra létrehozása
                segmentsData.forEach((segment, index) => {
                    try {
                        const region = regionsPlugin.addRegion({
                            start: segment.start,
                            end: segment.end,
                            color: 'rgba(0, 123, 255, 0.1)',
                            resize: true
                        });
                        regionIdToOriginalIndexMap[region.id] = index;
                    } catch (e) {
                        console.error(`Error adding region ${index}:`, e);
                    }
                });
                
                createTimelineSegments(wavesurfer.options.minPxPerSec);
                updateWidths();
            }

            function insertNewSegmentAfter(clickedSegmentIndex) {
                const clickedSegment = segmentsData[clickedSegmentIndex];
                const newSegmentStartTime = clickedSegment.end;
                let nextExistingSegmentStartTime = wavesurfer.getDuration();
                for (let i = 0; i < segmentsData.length; i++) {
                    if (segmentsData[i].start > newSegmentStartTime && segmentsData[i].start < nextExistingSegmentStartTime) {
                        nextExistingSegmentStartTime = segmentsData[i].start;
                    }
                }
                let newSegmentEndTime = Math.min(newSegmentStartTime + 0.5, nextExistingSegmentStartTime, wavesurfer.getDuration());
                if (newSegmentEndTime - newSegmentStartTime < 0.05) {
                    alert('Nincs elég hely új szegmens létrehozásához (minimum 50ms).');
                    return;
                }
                const newSegmentPayload = {
                    json_file_name: currentJsonFileName,
                    start: parseFloat(newSegmentStartTime.toFixed(3)),
                    end: parseFloat(newSegmentEndTime.toFixed(3)),
                    text: ""
                };
                fetch(`/api/add-segment/${currentProjectName}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(newSegmentPayload)
                })
                .then(res => res.json())
                .then(data => {
                    if (data.success && data.segments) {
                        segmentsData = data.segments;
                        sanitizeSegmentTexts(segmentsData);
                        fullRefreshUI();
                    } else {
                        alert(`Hiba az új szegmens hozzáadásakor: ${data.error}`);
                    }
                })
                .catch(err => alert(`Hiba: ${err.message}`));
            }

            function deleteSegmentOnServer(segmentIndex) {
                fetch(`/api/delete-segment/${currentProjectName}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ json_file_name: currentJsonFileName, segment_index: segmentIndex })
                })
                .then(res => res.json())
                .then(data => {
                    if (data.success && data.segments) {
                        segmentsData = data.segments;
                        sanitizeSegmentTexts(segmentsData);
                        fullRefreshUI();
                    } else {
                        alert(`Hiba a szegmens törlésekor: ${data.error}`);
                    }
                })
                .catch(err => alert(`Hiba: ${err.message}`));
            }

            function regenerateSegmentOnServer(segmentIndex) {
                if (currentJsonFileName === null || currentJsonFileName === undefined) {
                    alert('Hiányzik a JSON fájlnév, a regenerálás nem indítható.');
                    return;
                }
                const payload = {
                    json_file_name: currentJsonFileName,
                    segment_index: segmentIndex
                };
                fetch(`/api/regenerate-segment/${currentProjectName}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                })
                .then(res => res.json())
                .then(data => {
                    if (!data.success) {
                        alert(`Regenerálás sikertelen: ${data.error}`);
                        return;
                    }
                    const message = data.message || 'Regeneráció elindítva.';
                    if (regenerateLogModal) {
                        if (regenerateLogContent) {
                            regenerateLogContent.textContent = 'Log inicializálása...';
                        }
                        updateRegenerateStatus('queued', message);
                        regenerateLogModal.show();
                    } else {
                        alert(message);
                    }
                    if (data.job_id) {
                        startRegeneratePolling(data.job_id);
                    } else if (regenerateLogModal) {
                        if (regenerateAutoCloseTimeout) {
                            clearTimeout(regenerateAutoCloseTimeout);
                            regenerateAutoCloseTimeout = null;
                        }
                        regenerateLogContent.textContent = `${message}\nNincs naplózható feladat azonosító.`;
                        regenerateAutoCloseTimeout = setTimeout(() => {
                            regenerateLogModal.hide();
                        }, 2000);
                    }
                })
                .catch(err => alert(`Regenerálás hiba: ${err.message}`));
            }

            document.getElementById('menu-insert-segment').addEventListener('click', () => {
                if (currentContextMenuSegmentIndex !== -1) insertNewSegmentAfter(currentContextMenuSegmentIndex);
                contextMenu.style.display = 'none';
            });

            document.getElementById('menu-delete-segment').addEventListener('click', () => {
                if (currentContextMenuSegmentIndex !== -1 && confirm(`Biztosan törli a(z) ${currentContextMenuSegmentIndex + 1}. szegmenst?`)) {
                    deleteSegmentOnServer(currentContextMenuSegmentIndex);
                }
                contextMenu.style.display = 'none';
            });

            document.getElementById('menu-regenerate-segment').addEventListener('click', () => {
                if (currentContextMenuSegmentIndex !== -1) {
                    regenerateSegmentOnServer(currentContextMenuSegmentIndex);
                }
                contextMenu.style.display = 'none';
            });

            document.addEventListener('click', (event) => {
                if (contextMenu.style.display === 'block' && !contextMenu.contains(event.target)) {
                    contextMenu.style.display = 'none';
                }
            });

        });
        console.log('[DEBUG 99] Script tag processing finished.');
    </script>

</body>
</html>
