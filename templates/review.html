<!DOCTYPE html>
<html lang="hu" data-bs-theme="auto">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aktív projekt: {{project_name}}</title>
    <link href="{{ url_for('static', filename='vendor/bootstrap/bootstrap.min.css') }}" rel="stylesheet">
    <script src="{{ url_for('static', filename='vendor/bootstrap/bootstrap.bundle.min.js') }}"></script>
    <link rel="stylesheet" href="{{url_for('static', filename='css/style.css')}}">
    {% if theme_colors %}
    <style>
        :root {
            {% for name, value in theme_colors.light.items() %}
            --{{ name }}: {{ value }};
            {% endfor %}
        }
        [data-bs-theme="dark"] {
            {% for name, value in theme_colors.dark.items() %}
            --{{ name }}: {{ value }};
            {% endfor %}
        }
    </style>
    {% endif %}
    <script>
        (function() {
            const root = document.documentElement;
            const storageKey = 'theme';
            const systemMedia = window.matchMedia('(prefers-color-scheme: dark)');

            const getStoredPreference = () => localStorage.getItem(storageKey) || 'auto';

            const resolveTheme = preference => {
                if (preference === 'light' || preference === 'dark') {
                    return preference;
                }
                return systemMedia.matches ? 'dark' : 'light';
            };

            const applyTheme = preference => {
                const effectiveTheme = resolveTheme(preference);
                root.setAttribute('data-bs-theme', effectiveTheme);
                root.dataset.themePreference = preference;
            };

            const handleSystemChange = () => {
                const preference = root.dataset.themePreference || getStoredPreference();
                if (preference === 'auto') {
                    applyTheme('auto');
                }
            };

            if (typeof systemMedia.addEventListener === 'function') {
                systemMedia.addEventListener('change', handleSystemChange);
            } else if (typeof systemMedia.addListener === 'function') {
                systemMedia.addListener(handleSystemChange);
            }

            window.toggleTheme = function() {
                const currentPreference = root.dataset.themePreference || getStoredPreference();
                let nextPreference = 'auto';
                if (currentPreference === 'auto') {
                    nextPreference = 'light';
                } else if (currentPreference === 'light') {
                    nextPreference = 'dark';
                }
                localStorage.setItem(storageKey, nextPreference);
                applyTheme(nextPreference);
            };

            applyTheme(getStoredPreference());
        })();
    </script>
</head>
<body>
    <div class="theme-controls">
        <button class="theme-toggle" onclick="toggleTheme()" aria-label="Téma váltása">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16">
            <path d="M8 11a3 3 0 1 1 0-6 3 3 0 0 1 0 6zm0 1a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z"/>
        </svg>
        </button>
    </div>

    <div class="container-fluid mt-4">
    <div class="d-flex justify-content-between align-items-center mb-3">
        <h1>Aktív projekt: {{project_name}}</h1>
        <div>
            <a href="{{url_for('show_project', project_name=project_name)}}" class="btn btn-secondary me-2">Vissza a projekthez</a>
        </div>
    </div>

        {%if audio_url and segments_data%}
            <div class="mb-3">
                <p class="mb-1">Audio fájl: <strong>{{audio_file_name}}</strong></p>
                <p class="mb-1">JSON fájl: <strong>{{json_file_name}}</strong> ({{segments_data|length}} szegmens)</p>
            </div>
            <button id="playPauseBtn" class="btn btn-primary mb-3">Lejátszás</button>
            <div id="waveform-scroll-wrapper">
                <div id="waveform-content-area">
                    <div id="waveform"></div>
                    <div id="segments-timeline"></div>
                </div>
            </div>
        {%elif audio_url and not segments_data%}
            <div class="alert alert-warning" role="alert">
                Audio fájl betöltve ({{audio_file_name}}), de nincsenek megjeleníthető szegmensek a {{json_file_name if json_file_name else 'társított JSON fájlban'}}.
            </div>
        {%elif not audio_url%}
            <div class="alert alert-danger" role="alert">
                Nem található audio fájl a felülvizsgálathoz.
            </div>
        {%endif%}
    </div>

    <div class="container-fluid mb-5 px-4">
        <div class="card text-start">
            <div class="card-body">
                <h2 class="h4">Segítség a felület használatához</h2>
                <p class="text-muted mb-3">Az alábbi összefoglaló segít eligazodni a felülvizsgálati nézet funkciói között.</p>
                <ul class="mb-0">
                    <li><strong>Lejátszás:</strong> A felső <em>Lejátszás</em> gombbal indítható vagy állítható meg az audió. A Wavesurfer idővonal görgethető és nagyítható.</li>
                    <li><strong>Szegmens kiválasztása:</strong> A színes sávokra kattintva a hozzátartozó hangrészletet jelölheted ki. Jobb gombbal felugró menü érhető el szegmens beszúrására vagy törlésére.</li>
                    <li><strong>Szöveg szerkesztése:</strong> Az eredeti és fordított szöveg mezőire kattintva azonnal megáll a lejátszás, és a mező mérete a teljes tartalomhoz igazodik. A módosítások a mező elhagyásakor mentésre kerülnek.</li>
                    <li><strong>Billentyűparancs:</strong> Enter lenyomása szerkesztés közben lezárja a mezőt és megakadályozza az új sor felvitelét.</li>
                    <li><strong>Hullámforma:</strong> A hullámforma feletti idővonalon a szegmensek automatikusan újrarendeződnek az átméretezés és görgetés után, biztosítva az áttekinthető elrendezést.</li>
                </ul>
            </div>
        </div>
    </div>

    <script src="{{ url_for('static', filename='vendor/wavesurfer/wavesurfer.min.js') }}"></script>
    <script src="{{ url_for('static', filename='vendor/wavesurfer/regions.min.js') }}"></script>
    <!-- Felugró menü HTML struktúrája -->
    <div id="segment-context-menu" class="custom-context-menu">
        <ul>
            <li id="menu-insert-segment">Szegmens beszúrása mögé</li>
            <li id="menu-delete-segment">Szegmens törlése</li>
        </ul>
    </div>

    <script>
        console.log('[DEBUG 01] Script tag processing started.');
        document.addEventListener('DOMContentLoaded', function () {
            console.log('[DEBUG 02] DOMContentLoaded event handler started.');
            
            const audioUrl = "{{audio_url|safe if audio_url else ''}}";
            let segmentsDataString = '{{segments_data|tojson if segments_data else "[]"}}';
            let segmentsData = JSON.parse(segmentsDataString);
            const positionsCache = new Map();

            function invalidateSegmentPositionCache() {
                positionsCache.clear();
            }

            function getSegmentPositions(currentPxPerSec) {
                const cacheKey = currentPxPerSec.toFixed(2);
                if (!positionsCache.has(cacheKey)) {
                    positionsCache.set(cacheKey, calculateSegmentPositions(segmentsData, currentPxPerSec));
                }
                return positionsCache.get(cacheKey);
            }
            
            const currentProjectName = "{{project_name|safe}}";
            let currentJsonFileNameString = '{{json_file_name|tojson if json_file_name else "null"}}';
            let currentJsonFileName = (currentJsonFileNameString && currentJsonFileNameString !== 'null') ? JSON.parse(currentJsonFileNameString) : null;

            if (!audioUrl) {
                console.error('[DEBUG 03] Audio URL hiányzik.');
                const playButton = document.getElementById('playPauseBtn');
                if(playButton) playButton.disabled = true;
                return;
            }
            console.log('[DEBUG 03] Audio URL:', audioUrl);

            if (segmentsData.length === 0 && audioUrl) {
                console.info('[DEBUG 04] Nincsenek szegmensek.');
            } else if (segmentsData.length > 0) {
                console.log('[DEBUG 04] Segments count:', segmentsData.length);
            }

            let wavesurfer;
            let regionsPlugin;
            let regionIdToOriginalIndexMap = {}; 
            let activelyLoopingRegionId = null;

            const contextMenu = document.getElementById('segment-context-menu');
            let currentContextMenuSegmentIndex = -1;

            // ---- ÚJ FÜGGVÉNYEK ----
            /**
             * Egy textarea elem magasságát a tartalmához igazítja.
             * @param {HTMLTextAreaElement} textarea - Az átméretezendő szövegdoboz.
             */
            function autoResizeTextarea(textarea) {
                textarea.style.height = 'auto';
                textarea.style.height = (textarea.scrollHeight) + 'px';
            }

            /**
             * Frissíti az idővonal konténerének magasságát a benne lévő elemek alapján.
             */
            function updateTimelineContainerHeight() {
                const segmentsTimelineContainer = document.getElementById('segments-timeline');
                if (!segmentsTimelineContainer) return;
                const timelineChildren = segmentsTimelineContainer.children;
                let maxBottom = 0;
                if (timelineChildren.length > 0) {
                    for (let i = 0; i < timelineChildren.length; i++) {
                        const child = timelineChildren[i];
                        if (child.style.display === 'none') continue;
                        const childBottom = parseFloat(child.style.top) + child.offsetHeight;
                        if (childBottom > maxBottom) {
                            maxBottom = childBottom;
                        }
                    }
                    segmentsTimelineContainer.style.height = `${maxBottom + 20}px`;
                } else {
                    segmentsTimelineContainer.style.height = '50px';
                }
            }

            /**
             * Formats time in seconds to HH-MM-SS-mmm string for filenames.
             * @param {number} timeInSeconds - The time value in seconds.
             * @returns {string} The formatted time string.
             */
            function formatTimeForFilename(timeInSeconds) {
                if (typeof timeInSeconds !== 'number' || isNaN(timeInSeconds)) {
                    console.error("Invalid time provided to formatTimeForFilename:", timeInSeconds);
                    return '00-00-00-000';
                }
                // Handle potential floating point inaccuracies by rounding to nearest millisecond
                const totalMilliseconds = Math.round(timeInSeconds * 1000);
                const hours = Math.floor(totalMilliseconds / 3600000);
                const minutes = Math.floor((totalMilliseconds % 3600000) / 60000);
                const seconds = Math.floor((totalMilliseconds % 60000) / 1000);
                const milliseconds = totalMilliseconds % 1000;

                return [
                    String(hours).padStart(2, '0'),
                    String(minutes).padStart(2, '0'),
                    String(seconds).padStart(2, '0'),
                    String(milliseconds).padStart(3, '0')
                ].join('-');
            }
            // ---- FÜGGVÉNYEK VÉGE ----

            // Függvények definíciói
            function setWaveformZoom() {
                const scrollWrapper = document.getElementById('waveform-scroll-wrapper');
                if (wavesurfer && scrollWrapper) {
                    const audioDuration = wavesurfer.getDuration();
                    const containerWidth = scrollWrapper.clientWidth;
                    const secondsToShow = 20;

                    if (audioDuration > 0 && containerWidth > 0) {
                        let newMinPxPerSec = containerWidth / Math.min(secondsToShow, audioDuration);
                        newMinPxPerSec = Math.max(10, newMinPxPerSec);
                        wavesurfer.zoom(newMinPxPerSec);
                    } else if (containerWidth > 0) {
                        wavesurfer.zoom(10);
                    }
                }
            }
            
            const segmentsTimelineContainer = document.getElementById('segments-timeline');
            const waveformContentArea = document.getElementById('waveform-content-area');

            function updateWidths() {
                if (!wavesurfer || !wavesurfer.getWrapper() || !waveformContentArea || !segmentsTimelineContainer) return;
                try {
                    const fullAudioPixelWidth = wavesurfer.getWrapper().scrollWidth;
                    waveformContentArea.style.width = `${fullAudioPixelWidth}px`;
                    segmentsTimelineContainer.style.width = `${fullAudioPixelWidth}px`;
                } catch (e) {
                    console.error("Error in updateWidths:", e);
                }
            }
            
            // ---- OPTIMALIZÁLT FÜGGVÉNYEK ----
            
            // Virtualizáció és teljesítmény optimalizálás
            let segmentElementsCache = new Map();
            let visibleSegments = new Set();
            let renderQueue = [];
            let isRendering = false;
            let lastScrollLeft = 0;
            let lastZoomLevel = 0;
            
            // Debounce függvény
            function debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }
            
            // Optimalizált collision detection - O(n log n) helyett O(n²)
            function calculateSegmentPositions(segments, currentPxPerSec) {
                const verticalGap = 5;
                const positions = [];
                const rows = [];
                
                // Szegmensek rendezése start idő szerint
                const sortedSegments = segments.map((segment, index) => ({
                    ...segment,
                    originalIndex: index,
                    leftPx: segment.start * currentPxPerSec,
                    widthPx: Math.max((segment.end - segment.start) * currentPxPerSec - 10, 150)
                })).sort((a, b) => a.start - b.start);
                
                sortedSegments.forEach(segment => {
                    let rowIndex = 0;
                    let placed = false;
                    
                    while (!placed) {
                        if (!rows[rowIndex]) {
                            rows[rowIndex] = [];
                        }
                        
                        // Ellenőrizzük az ütközést az aktuális sorban
                        let hasCollision = false;
                        for (const existingSegment of rows[rowIndex]) {
                            if (segment.leftPx < existingSegment.rightPx &&
                                segment.leftPx + segment.widthPx > existingSegment.leftPx) {
                                hasCollision = true;
                                break;
                            }
                        }
                        
                        if (!hasCollision) {
                            const segmentData = {
                                leftPx: segment.leftPx,
                                rightPx: segment.leftPx + segment.widthPx,
                                rowIndex: rowIndex
                            };
                            rows[rowIndex].push(segmentData);
                            positions[segment.originalIndex] = {
                                top: rowIndex * (80 + verticalGap), // Becsült sor magasság
                                left: segment.leftPx,
                                width: segment.widthPx
                            };
                            placed = true;
                        } else {
                            rowIndex++;
                        }
                    }
                });
                
                return positions;
            }
            
            // Viewport alapú virtualizáció
            function getVisibleSegmentIndices(scrollLeft, viewportWidth, currentPxPerSec) {
                const buffer = viewportWidth * 0.5; // 50% buffer mindkét oldalon
                const startTime = Math.max(0, (scrollLeft - buffer) / currentPxPerSec);
                const endTime = (scrollLeft + viewportWidth + buffer) / currentPxPerSec;
                
                const visibleIndices = [];
                segmentsData.forEach((segment, index) => {
                    if (segment.end >= startTime && segment.start <= endTime) {
                        visibleIndices.push(index);
                    }
                });
                
                return visibleIndices;
            }
            
            // Aszinkron DOM elem létrehozás
            function createSegmentElement(segment, index, position, currentPxPerSec) {
                return new Promise((resolve) => {
                    requestAnimationFrame(() => {
                        const segmentContainer = document.createElement('div');
                        segmentContainer.className = 'timeline-segment-container';
                        segmentContainer.style.position = 'absolute';
                        segmentContainer.style.left = `${position.left}px`;
                        segmentContainer.style.top = `${position.top}px`;
                        segmentContainer.style.width = `${position.width}px`;
                        segmentContainer.dataset.segmentIndex = index;

                        const originalTextarea = document.createElement('textarea');
                        originalTextarea.className = 'timeline-segment form-control form-control-sm original-text';
                        originalTextarea.value = segment.text;
                        originalTextarea.placeholder = "Original text";
                        originalTextarea.style.resize = 'none';
                        originalTextarea.style.overflowY = 'hidden';
                        originalTextarea.title = `[${segment.start.toFixed(2)}s - ${segment.end.toFixed(2)}s]`;

                        const translatedTextarea = document.createElement('textarea');
                        translatedTextarea.className = 'timeline-segment form-control form-control-sm translated-text';
                        translatedTextarea.value = segment.translated_text || '';
                        translatedTextarea.placeholder = segment.translated_text ? "Fordított szöveg" : "Nincs fordítás";
                        translatedTextarea.style.resize = 'none';
                        translatedTextarea.style.overflowY = 'hidden';
                        translatedTextarea.title = `[${segment.start.toFixed(2)}s - ${segment.end.toFixed(2)}s]`;
                        
                        segmentContainer.appendChild(originalTextarea);
                        segmentContainer.appendChild(translatedTextarea);

                        // Audio player hozzáadása
                        const translatedSplitsDir = "{{ app_config.PROJECT_SUBDIRS.translated_splits | e }}";
                        if (translatedSplitsDir) {
                            const startTimeFormatted = formatTimeForFilename(segment.start);
                            const endTimeFormatted = formatTimeForFilename(segment.end);
                            const wavFilename = `${startTimeFormatted}_${endTimeFormatted}.wav`;
                            
                            const audioPlayer = document.createElement('audio');
                            audioPlayer.controls = true;
                            audioPlayer.src = `/workdir/${currentProjectName}/${translatedSplitsDir}/${wavFilename}`;
                            audioPlayer.className = 'segment-audio-player';
                            audioPlayer.preload = 'none'; // Lazy loading
                            audioPlayer.addEventListener('error', function(e) {
                                console.warn(`Nem tölthető be az audio a(z) ${index}. szegmenshez: ${this.src}`);
                                this.style.display = 'none';
                            });
                            
                            segmentContainer.appendChild(audioPlayer);
                        }

                        autoResizeTextarea(originalTextarea);
                        autoResizeTextarea(translatedTextarea);
                        
                        resolve({ element: segmentContainer, index, originalTextarea, translatedTextarea });
                    });
                });
            }
            
            // Batch DOM műveletek
            async function renderVisibleSegments(currentPxPerSec) {
                if (isRendering) return;
                isRendering = true;
                
                try {
                    const scrollWrapper = document.getElementById('waveform-scroll-wrapper');
                    const scrollLeft = scrollWrapper ? scrollWrapper.scrollLeft : 0;
                    const viewportWidth = scrollWrapper ? scrollWrapper.clientWidth : 1000;
                    
                    const visibleIndices = getVisibleSegmentIndices(scrollLeft, viewportWidth, currentPxPerSec);
                    const positions = getSegmentPositions(currentPxPerSec);
                    
                    // Eltávolítjuk a már nem látható szegmenseket
                    const elementsToRemove = [];
                    visibleSegments.forEach(index => {
                        if (!visibleIndices.includes(index)) {
                            const element = segmentElementsCache.get(index);
                            if (element && element.parentNode) {
                                elementsToRemove.push(element);
                            }
                            visibleSegments.delete(index);
                        }
                    });
                    
                    // Batch removal
                    elementsToRemove.forEach(element => {
                        segmentsTimelineContainer.removeChild(element);
                    });
                    
                    // Új látható szegmensek hozzáadása
                    const newSegments = visibleIndices.filter(index => !visibleSegments.has(index));
                    const renderPromises = [];
                    
                    for (const index of newSegments) {
                        if (!segmentElementsCache.has(index)) {
                            const segment = segmentsData[index];
                            const position = positions[index];
                            if (segment && position) {
                                renderPromises.push(createSegmentElement(segment, index, position, currentPxPerSec));
                            }
                        } else {
                            // Ha már van cache-elt elem, de nem látható, hozzáadjuk a láthatókhoz
                            const cachedElement = segmentElementsCache.get(index);
                            if (cachedElement && !cachedElement.parentNode) {
                                visibleSegments.add(index);
                                const position = positions[index];
                                if (position) {
                                    cachedElement.style.left = `${position.left}px`;
                                    cachedElement.style.top = `${position.top}px`;
                                    cachedElement.style.width = `${position.width}px`;
                                    segmentsTimelineContainer.appendChild(cachedElement);
                                }
                            }
                        }
                    }
                    
                    // Várjuk meg az összes új elem létrehozását
                    const newElements = await Promise.all(renderPromises);
                    
                    // Batch DOM insertion
                    const fragment = document.createDocumentFragment();
                    newElements.forEach(({ element, index, originalTextarea, translatedTextarea }) => {
                        segmentElementsCache.set(index, element);
                        visibleSegments.add(index);
                        fragment.appendChild(element);
                        
                        // Event listeners hozzáadása az új elemekhez
                        attachSegmentEventListeners(originalTextarea, translatedTextarea, index);
                    });
                    
                    segmentsTimelineContainer.appendChild(fragment);
                    
                    // Meglévő elemek pozíciójának frissítése
                    visibleIndices.forEach(index => {
                        if (segmentElementsCache.has(index) && !newSegments.includes(index)) {
                            const element = segmentElementsCache.get(index);
                            const position = positions[index];
                            element.style.left = `${position.left}px`;
                            element.style.top = `${position.top}px`;
                            element.style.width = `${position.width}px`;
                        }
                    });
                    
                    updateTimelineContainerHeight();
                    
                } finally {
                    isRendering = false;
                }
            }
            
            // Event listener csatolás
            function attachSegmentEventListeners(originalTextarea, translatedTextarea, index) {
                [originalTextarea, translatedTextarea].forEach(textarea => {
                    textarea.addEventListener('input', debounce(function() {
                        autoResizeTextarea(this);
                        updateTimelineContainerHeight();
                    }, 100));
                    
                    textarea.addEventListener('keydown', function(event) {
                        if (event.key === 'Enter') {
                            event.preventDefault();
                            this.blur();
                        }
                    });
                    
                    textarea.addEventListener('focus', function() {
                        autoResizeTextarea(this);
                        updateTimelineContainerHeight();
                    });

                    textarea.addEventListener('click', function() {
                        wavesurfer.pause();
                        autoResizeTextarea(this);
                        updateTimelineContainerHeight();
                    });
                    // Double-click esemény eltávolítva - event delegation használjuk helyette
                });
                
                originalTextarea.addEventListener('blur', function() {
                    const newText = this.value;
                    const segment = segmentsData[index];
                    if (newText !== segment.text) {
                        updateSegmentOnServer(index, segment.start, segment.end, newText, segment.translated_text || '');
                    }
                });

                translatedTextarea.addEventListener('blur', function() {
                    const newTranslated = this.value;
                    const segment = segmentsData[index];
                    if (newTranslated !== (segment.translated_text || '')) {
                        updateSegmentOnServer(index, segment.start, segment.end, segment.text, newTranslated);
                    }
                });
            }
            
            // Optimalizált fő függvény
            const debouncedRenderSegments = debounce(renderVisibleSegments, 50);
            
            function createTimelineSegments(currentPxPerSec) {
                console.log(`[TIMELINE] Creating timeline segments, count: ${segmentsData.length}, pxPerSec: ${currentPxPerSec}`);
                
                if (!segmentsTimelineContainer || !wavesurfer || segmentsData.length === 0) {
                    if (segmentsTimelineContainer) {
                        segmentsTimelineContainer.innerHTML = '';
                        console.log('[TIMELINE] Cleared timeline container - no segments or missing dependencies');
                    }
                    return;
                }
                
                // Ha a zoom szint jelentősen változott, tisztítsuk a cache-t
                if (Math.abs(currentPxPerSec - lastZoomLevel) > 1) {
                    console.log(`[TIMELINE] Zoom level changed significantly: ${lastZoomLevel} -> ${currentPxPerSec}, clearing cache`);
                    segmentElementsCache.clear();
                    visibleSegments.clear();
                    segmentsTimelineContainer.innerHTML = '';
                    invalidateSegmentPositionCache();
                    lastZoomLevel = currentPxPerSec;
                }
                
                debouncedRenderSegments(currentPxPerSec);
            }
            // ---- OPTIMALIZÁLT FÜGGVÉNYEK VÉGE ----

            function updateSegmentOnServer(segmentIndex, newStart, newEnd, newText, newTranslatedText) {
                // Validáció
                if (segmentIndex < 0 || segmentIndex >= segmentsData.length) {
                    console.error('Invalid segment index:', segmentIndex);
                    return;
                }
                
                const originalSegment = JSON.parse(JSON.stringify(segmentsData[segmentIndex]));
                const payload = {
                    json_file_name: currentJsonFileName,
                    segment_index: segmentIndex,
                    new_start: parseFloat(newStart.toFixed(3)),
                    new_end: parseFloat(newEnd.toFixed(3)),
                    new_text: newText,
                    new_translated_text: newTranslatedText
                };
                const startChanged = originalSegment.start !== payload.new_start || originalSegment.end !== payload.new_end;
                
                // Optimista frissítés
                segmentsData[segmentIndex].start = payload.new_start;
                segmentsData[segmentIndex].end = payload.new_end;
                segmentsData[segmentIndex].text = newText;
                segmentsData[segmentIndex].translated_text = newTranslatedText;
                if (startChanged) {
                    invalidateSegmentPositionCache();
                    if (wavesurfer && wavesurfer.options) {
                        debouncedRenderSegments(wavesurfer.options.minPxPerSec);
                    }
                }

                fetch(`/api/update-segment/${currentProjectName}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                })
                .then(response => response.ok ? response.json() : response.json().then(err => Promise.reject(err)))
                .then(data => {
                    if (!data.success) {
                        console.error('Szerver oldali hiba a mentéskor:', data.error);
                        alert(`Hiba a szegmens mentésekor: ${data.error}`);
                        // Rollback
                        segmentsData[segmentIndex] = originalSegment;
                        // Frissítjük a cache-t és a UI-t
                        segmentElementsCache.clear();
                        visibleSegments.clear();
                        invalidateSegmentPositionCache();
                        createTimelineSegments(wavesurfer.options.minPxPerSec);
                    } else {
                        // Sikeres mentés esetén frissítjük a látható elemeket
                        if (visibleSegments.has(segmentIndex)) {
                            const element = segmentElementsCache.get(segmentIndex);
                            if (element) {
                                const originalTextarea = element.querySelector('.original-text');
                                const translatedTextarea = element.querySelector('.translated-text');
                                if (originalTextarea && originalTextarea.value !== newText) {
                                    originalTextarea.value = newText;
                                }
                                if (translatedTextarea && translatedTextarea.value !== newTranslatedText) {
                                    translatedTextarea.value = newTranslatedText;
                                }
                            }
                        }
                    }
                })
                .catch(error => {
                    console.error('Hálózati vagy egyéb hiba a mentéskor:', error);
                    alert(`Hiba a szegmens mentésekor: ${error.error || error.message || 'Ismeretlen hiba'}`);
                    // Rollback
                    segmentsData[segmentIndex] = originalSegment;
                    segmentElementsCache.clear();
                    visibleSegments.clear();
                    invalidateSegmentPositionCache();
                    createTimelineSegments(wavesurfer.options.minPxPerSec);
                });
            }


            try {
                wavesurfer = WaveSurfer.create({
                    container: '#waveform',
                    url: audioUrl,
                    waveColor: 'rgb(200, 200, 200)',
                    progressColor: 'rgb(100, 100, 100)',
                    height: 128,
                    minPxPerSec: 10 
                });

                wavesurfer.on('ready', function () {
                    regionsPlugin = wavesurfer.registerPlugin(WaveSurfer.Regions.create());

                    regionsPlugin.on('region-updated', (region) => {
                        const originalIndex = regionIdToOriginalIndexMap[region.id];
                        if (typeof originalIndex === 'undefined') {
                            console.warn('Region updated but no mapping found for region ID:', region.id);
                            return;
                        }
                        if (originalIndex >= segmentsData.length) {
                            console.warn('Region index out of bounds:', originalIndex, 'segments length:', segmentsData.length);
                            return;
                        }
                        const segment = segmentsData[originalIndex];
                        const newStart = parseFloat(region.start.toFixed(3));
                        const newEnd = parseFloat(region.end.toFixed(3));
                        updateSegmentOnServer(originalIndex, newStart, newEnd, segment.text, segment.translated_text || '');
                    });

                    regionsPlugin.on('region-clicked', (region, e) => {
                        e.stopPropagation();
                        region.play();
                    });

                    setWaveformZoom(); 
                    updateWidths();    
                    
                    if (segmentsData.length > 0) {
                        segmentsData.forEach((segment, index) => {
                            try {
                                const region = regionsPlugin.addRegion({
                                    start: segment.start,
                                    end: segment.end,
                                    color: 'rgba(0, 123, 255, 0.1)',
                                    resize: true
                                });
                                regionIdToOriginalIndexMap[region.id] = index;
                            } catch (e) {
                                console.error(`Error adding region ${index}:`, e);
                            }
                        });
                    }
                    createTimelineSegments(wavesurfer.options.minPxPerSec); 
                });

                wavesurfer.on('zoom', (newMinPxPerSec) => {
                    updateWidths();
                    createTimelineSegments(newMinPxPerSec);
                });

                wavesurfer.on('error', (err) => console.error("Wavesurfer error:", err));

            } catch (e) {
                console.error('WaveSurfer core init error:', e);
            }
            
            document.getElementById('playPauseBtn')?.addEventListener('click', () => wavesurfer.playPause());
            wavesurfer.on('play', () => document.getElementById('playPauseBtn').textContent = 'Szünet');
            wavesurfer.on('pause', () => document.getElementById('playPauseBtn').textContent = 'Lejátszás');
            wavesurfer.on('finish', () => document.getElementById('playPauseBtn').textContent = 'Lejátszás');

            // Optimalizált scroll kezelés
            const scrollWrapper = document.getElementById('waveform-scroll-wrapper');
            if (scrollWrapper) {
                // Wheel scroll optimalizálás
                scrollWrapper.addEventListener('wheel', (event) => {
                    if (event.deltaY !== 0) {
                        event.preventDefault();
                        event.currentTarget.scrollLeft += event.deltaY;
                    }
                }, { passive: false });
                
                // Scroll-alapú virtualizáció
                const debouncedScrollHandler = debounce(() => {
                    if (wavesurfer && wavesurfer.options) {
                        debouncedRenderSegments(wavesurfer.options.minPxPerSec);
                    }
                }, 16); // ~60fps
                
                scrollWrapper.addEventListener('scroll', debouncedScrollHandler);
            }
            
            // Event delegation a context menühöz
            segmentsTimelineContainer.addEventListener('contextmenu', function(event) {
                const segmentContainer = event.target.closest('.timeline-segment-container');
                if (segmentContainer && segmentContainer.dataset.segmentIndex) {
                    event.preventDefault();
                    event.stopPropagation();
                    currentContextMenuSegmentIndex = parseInt(segmentContainer.dataset.segmentIndex);
                    contextMenu.style.left = `${event.pageX}px`;
                    contextMenu.style.top = `${event.pageY}px`;
                    contextMenu.style.display = 'block';
                }
            });

            function fullRefreshUI() {
                regionsPlugin.clearRegions();
                regionIdToOriginalIndexMap = {};
                
                // Cache és látható szegmensek törlése
                segmentElementsCache.clear();
                visibleSegments.clear();
                segmentsTimelineContainer.innerHTML = '';
                lastZoomLevel = 0; // Reset zoom level to force cache clear
                invalidateSegmentPositionCache();
                
                // Regions újra létrehozása
                segmentsData.forEach((segment, index) => {
                    try {
                        const region = regionsPlugin.addRegion({
                            start: segment.start,
                            end: segment.end,
                            color: 'rgba(0, 123, 255, 0.1)',
                            resize: true
                        });
                        regionIdToOriginalIndexMap[region.id] = index;
                    } catch (e) {
                        console.error(`Error adding region ${index}:`, e);
                    }
                });
                
                createTimelineSegments(wavesurfer.options.minPxPerSec);
                updateWidths();
            }

            function insertNewSegmentAfter(clickedSegmentIndex) {
                const clickedSegment = segmentsData[clickedSegmentIndex];
                const newSegmentStartTime = clickedSegment.end;
                let nextExistingSegmentStartTime = wavesurfer.getDuration();
                for (let i = 0; i < segmentsData.length; i++) {
                    if (segmentsData[i].start > newSegmentStartTime && segmentsData[i].start < nextExistingSegmentStartTime) {
                        nextExistingSegmentStartTime = segmentsData[i].start;
                    }
                }
                let newSegmentEndTime = Math.min(newSegmentStartTime + 0.5, nextExistingSegmentStartTime, wavesurfer.getDuration());
                if (newSegmentEndTime - newSegmentStartTime < 0.05) {
                    alert('Nincs elég hely új szegmens létrehozásához (minimum 50ms).');
                    return;
                }
                const newSegmentPayload = {
                    json_file_name: currentJsonFileName,
                    start: parseFloat(newSegmentStartTime.toFixed(3)),
                    end: parseFloat(newSegmentEndTime.toFixed(3)),
                    text: ""
                };
                fetch(`/api/add-segment/${currentProjectName}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(newSegmentPayload)
                })
                .then(res => res.json())
                .then(data => {
                    if (data.success && data.segments) {
                        segmentsData = data.segments;
                        fullRefreshUI();
                    } else {
                        alert(`Hiba az új szegmens hozzáadásakor: ${data.error}`);
                    }
                })
                .catch(err => alert(`Hiba: ${err.message}`));
            }

            function deleteSegmentOnServer(segmentIndex) {
                fetch(`/api/delete-segment/${currentProjectName}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ json_file_name: currentJsonFileName, segment_index: segmentIndex })
                })
                .then(res => res.json())
                .then(data => {
                    if (data.success && data.segments) {
                        segmentsData = data.segments;
                        fullRefreshUI();
                    } else {
                        alert(`Hiba a szegmens törlésekor: ${data.error}`);
                    }
                })
                .catch(err => alert(`Hiba: ${err.message}`));
            }

            document.getElementById('menu-insert-segment').addEventListener('click', () => {
                if (currentContextMenuSegmentIndex !== -1) insertNewSegmentAfter(currentContextMenuSegmentIndex);
                contextMenu.style.display = 'none';
            });

            document.getElementById('menu-delete-segment').addEventListener('click', () => {
                if (currentContextMenuSegmentIndex !== -1 && confirm(`Biztosan törli a(z) ${currentContextMenuSegmentIndex + 1}. szegmenst?`)) {
                    deleteSegmentOnServer(currentContextMenuSegmentIndex);
                }
                contextMenu.style.display = 'none';
            });

            document.addEventListener('click', (event) => {
                if (contextMenu.style.display === 'block' && !contextMenu.contains(event.target)) {
                    contextMenu.style.display = 'none';
                }
            });

        });
        console.log('[DEBUG 99] Script tag processing finished.');
    </script>

    <!-- Fordítás modal ablak -->
    <div class="modal fade" id="translationModal" tabindex="-1" aria-labelledby="translationModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="translationModalLabel">Fordítás beállításai</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <form id="translationForm">
                        <div class="mb-3">
                            <label for="inputDir" class="form-label">Bemeneti könyvtár (input_dir)</label>
                            <input type="text" class="form-control" id="inputDir" value="workdir/{{ project_name }}/{{ app_config.PROJECT_SUBDIRS.separated_audio_speech }}" readonly>
                        </div>
                        <div class="mb-3">
                            <label for="outputDir" class="form-label">Kimeneti könyvtár (output_dir)</label>
                            <input type="text" class="form-control" id="outputDir" value="workdir/{{ project_name }}/{{ app_config.PROJECT_SUBDIRS.translated if app_config.PROJECT_SUBDIRS.translated else 'translated' }}" readonly>
                        </div>
                        <div class="mb-3">
                            <label for="inputLanguage" class="form-label">Bemeneti nyelv (input_language)</label>
                            <input type="text" class="form-control" id="inputLanguage" value="{{ app_config.CONFIG.default_source_lang if app_config.CONFIG.default_source_lang else 'en' }}">
                        </div>
                        <div class="mb-3">
                            <label for="outputLanguage" class="form-label">Kimeneti nyelv (output_language)</label>
                            <input type="text" class="form-control" id="outputLanguage" value="{{ app_config.CONFIG.default_target_lang if app_config.CONFIG.default_target_lang else 'hu' }}">
                        </div>
                        <div class="mb-3">
                            <label for="apiKey" class="form-label">API Kulcs</label>
                            <input type="password" class="form-control" id="apiKey">
                        </div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Mégse</button>
                    <button type="button" class="btn btn-primary" id="saveApiKeyBtn">Mentés</button>
                    <button type="button" class="btn btn-success" id="runTranslationBtn">Fordítás indítása</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const translationBtn = document.getElementById('translationBtn');
            const translationModalElement = document.getElementById('translationModal');
            if (!translationBtn || !translationModalElement) return;

            const translationModal = new bootstrap.Modal(translationModalElement);
            
            fetch('/get-api-key')
                .then(response => response.json())
                .then(data => {
                    if (data.api_key) {
                        try {
                            document.getElementById('apiKey').value = atob(data.api_key);
                        } catch(e) { console.error("API key decoding failed:", e); }
                    }
                });

            translationBtn.addEventListener('click', () => translationModal.show());

            document.getElementById('saveApiKeyBtn').addEventListener('click', function() {
                const apiKey = document.getElementById('apiKey').value;
                if (!apiKey) { alert('Kérjük adja meg az API kulcsot!'); return; }
                
                fetch('/save-api-key', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ api_key: apiKey })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        alert('API kulcs sikeresen mentve!');
                        translationModal.hide();
                    } else {
                        alert('Hiba történt a mentés során: ' + data.error);
                    }
                });
            });

            document.getElementById('runTranslationBtn').addEventListener('click', function() {
                const payload = {
                    auth_key: document.getElementById('apiKey').value,
                    input_dir: document.getElementById('inputDir').value,
                    output_dir: document.getElementById('outputDir').value,
                    input_language: document.getElementById('inputLanguage').value,
                    output_language: document.getElementById('outputLanguage').value,
                };
                
                if (Object.values(payload).some(v => !v)) {
                    alert('Minden mező kitöltése kötelező!');
                    return;
                }

                fetch('/run-translation', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        const modeMessages = {
                            srt_align: 'Meglévő célnyelvi SRT igazítása indul.',
                            deepl: 'DeepL alapú fordítás indul (SRT nem található).'
                        };
                        const modeText = modeMessages[data.mode] || 'Fordítási folyamat elindult.';
                        alert(`${modeText} Az oldal frissítése szükséges az eredmények megtekintéséhez, amint a folyamat befejeződött.`);
                        translationModal.hide();
                    } else {
                        alert('Hiba a fordítás indításakor: ' + data.error);
                    }
                });
            });
        });
    </script>
</body>
</html>
