<!DOCTYPE html>
<html lang="hu" data-bs-theme="auto">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Projekt: {{ project.name }} | AI Dubbing</title>
    <link href="{{ url_for('static', filename='vendor/bootstrap/bootstrap.min.css') }}" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    {% if theme_colors %}
    <style>
        :root {
            {% for name, value in theme_colors.light.items() %}
            --{{ name }}: {{ value }};
            {% endfor %}
        }
        [data-bs-theme="dark"] {
            {% for name, value in theme_colors.dark.items() %}
            --{{ name }}: {{ value }};
            {% endfor %}
        }
    </style>
    {% endif %}
    <script src="{{ url_for('static', filename='vendor/marked/marked.min.js') }}"></script>
    <script src="https://unpkg.com/wavesurfer.js@7"></script>
    <script src="https://unpkg.com/wavesurfer.js@7/dist/plugins/regions.min.js"></script>
    <script src="{{ url_for('static', filename='js/audio-trimmer.js') }}"></script>
    <script>
        (function() {
            const root = document.documentElement;
            const storageKey = 'theme';
            const systemMedia = window.matchMedia('(prefers-color-scheme: dark)');

            const getStoredPreference = () => localStorage.getItem(storageKey) || 'auto';

            const resolveTheme = preference => {
                if (preference === 'light' || preference === 'dark') {
                    return preference;
                }
                return systemMedia.matches ? 'dark' : 'light';
            };

            const applyTheme = preference => {
                const effectiveTheme = resolveTheme(preference);
                root.setAttribute('data-bs-theme', effectiveTheme);
                root.dataset.themePreference = preference;
            };

            const handleSystemChange = () => {
                const preference = root.dataset.themePreference || getStoredPreference();
                if (preference === 'auto') {
                    applyTheme('auto');
                }
            };

            if (typeof systemMedia.addEventListener === 'function') {
                systemMedia.addEventListener('change', handleSystemChange);
            } else if (typeof systemMedia.addListener === 'function') {
                systemMedia.addListener(handleSystemChange);
            }

            window.toggleTheme = function() {
                const currentPreference = root.dataset.themePreference || getStoredPreference();
                let nextPreference = 'auto';
                if (currentPreference === 'auto') {
                    nextPreference = 'light';
                } else if (currentPreference === 'light') {
                    nextPreference = 'dark';
                }
                localStorage.setItem(storageKey, nextPreference);
                applyTheme(nextPreference);
            };

            applyTheme(getStoredPreference());
        })();
    </script>
    <style>
        .audio-waveform {
            position: relative;
            min-height: 140px;
            border-radius: 0.5rem;
            border: 1px solid var(--bs-border-color);
            background-color: var(--waveform-bg, var(--bs-tertiary-bg));
            overflow: hidden;
        }
        .audio-waveform #audioWaveform {
            width: 100%;
            height: 100%;
        }
        .audio-waveform canvas {
            display: block;
        }
        .audio-waveform .waveform-loading-overlay {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(0, 0, 0, 0.05);
            color: var(--bs-secondary-color, #6c757d);
            font-size: 0.9rem;
            pointer-events: none;
        }
        [data-bs-theme="dark"] .audio-waveform .waveform-loading-overlay {
            background-color: rgba(0, 0, 0, 0.35);
            color: rgba(255, 255, 255, 0.75);
        }
        .audio-trim-info span {
            font-variant-numeric: tabular-nums;
        }
        .file-browser-tree {
            list-style: none;
            padding-left: 0;
        }
        .file-browser-tree ul {
            list-style: none;
            padding-left: 1rem;
            margin: 0.25rem 0;
        }
        .file-browser-summary {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.5rem;
            font-weight: 600;
        }
        .file-browser-label {
            flex: 1 1 auto;
            min-width: 0;
            word-break: break-word;
        }
        .file-browser-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.15rem 0.35rem;
            margin: 0 -0.35rem;
            flex-wrap: wrap;
            border-radius: 0.4rem;
            transition: background-color 0.12s ease-in-out;
        }
        .file-browser-item:hover {
            background-color: var(--bs-tertiary-bg, rgba(0, 0, 0, 0.05));
        }
        .file-browser-link {
            flex: 1 1 auto;
            min-width: 0;
            word-break: break-word;
        }
        .file-browser-meta {
            font-size: 0.8rem;
            color: var(--bs-secondary-color, #6c757d);
            font-variant-numeric: tabular-nums;
        }
        .file-browser-note {
            font-size: 0.8rem;
            color: var(--bs-secondary-color, #6c757d);
            flex-basis: 100%;
            margin-left: 0.2rem;
            word-break: break-word;
        }
        details.file-browser-directory > summary {
            cursor: pointer;
        }
        .file-browser-directory.fg-has-translated > summary {
            background-color: var(--bs-success-bg-subtle, rgba(25, 135, 84, 0.18));
            border-left: 0.3rem solid var(--bs-success-border-subtle, rgba(25, 135, 84, 0.4));
            border-radius: 0.375rem;
            padding-left: 0.75rem;
        }
        .file-browser-directory.fg-has-translated > summary .file-browser-label {
            font-weight: 600;
        }
        [data-bs-theme="dark"] .file-browser-directory.fg-has-translated > summary {
            background-color: rgba(25, 135, 84, 0.28);
        }
        .file-browser-legend {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        .file-browser-legend .file-browser-legend-swatch {
            width: 1.1rem;
            height: 1.1rem;
            border-radius: 0.25rem;
            background-color: var(--bs-success-bg-subtle, rgba(25, 135, 84, 0.45));
            border: 1px solid var(--bs-success-border-subtle, rgba(25, 135, 84, 0.7));
            flex-shrink: 0;
        }
        [data-bs-theme="dark"] .file-browser-legend .file-browser-legend-swatch {
            background-color: rgba(25, 135, 84, 0.45);
        }
        .file-browser-children {
            margin-left: 1rem;
            padding-left: 0.5rem;
        }
        .file-browser-actions {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }
        .file-browser-actions .btn {
            padding: 0.2rem 0.5rem;
            font-size: 0.75rem;
            line-height: 1.2;
        }
        .script-api-badge {
            font-size: 0.75rem;
            font-weight: 600;
            letter-spacing: 0.05em;
        }
        .script-api-highlight {
            color: #b8860b;
            font-weight: 600;
        }
        .cycle-counter-display {
            font-size: 1.5rem;
            font-weight: 700;
            margin-top: 0.75rem;
            color: var(--bs-primary, #0d6efd);
        }
        .markdown-content {
            font-size: 0.95rem;
            line-height: 1.5;
        }
        .markdown-content p {
            margin-bottom: 0.75rem;
        }
        .markdown-content ul,
        .markdown-content ol {
            padding-left: 1.25rem;
            margin-bottom: 0.75rem;
        }
        .markdown-content pre {
            background-color: #f8f9fa;
            padding: 0.75rem;
            border-radius: 0.375rem;
            overflow-x: auto;
        }
        [data-bs-theme="dark"] .markdown-content pre {
            background-color: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.12);
            color: var(--bs-body-color, #f8f9fa);
        }
        [data-bs-theme="dark"] .markdown-content code {
            color: var(--bs-body-color, #f8f9fa);
        }
        .markdown-content code {
            font-size: 0.9em;
        }
        .workflow-context-menu {
            position: absolute;
            display: none;
            min-width: 240px;
            background-color: var(--bs-body-bg, #ffffff);
            border: 1px solid rgba(0, 0, 0, 0.15);
            border-radius: 0.5rem;
            box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.15);
            padding: 0.25rem 0;
            z-index: 1080;
        }
        .workflow-context-menu.show {
            display: block;
        }
        .workflow-context-item {
            position: relative;
            padding: 0.35rem 1.5rem 0.35rem 0.75rem;
            white-space: nowrap;
            cursor: pointer;
            font-size: 0.95rem;
        }
        .workflow-context-item:hover {
            background-color: rgba(13, 110, 253, 0.08);
        }
        .workflow-context-item.disabled {
            color: #adb5bd;
            pointer-events: none;
        }
        .workflow-context-item.has-submenu::after {
            content: '>';
            position: absolute;
            right: 0.6rem;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.75rem;
            color: var(--bs-secondary-color, #6c757d);
        }
        .workflow-context-submenu {
            position: absolute;
            top: 0;
            left: 100%;
            margin-left: 2px;
            min-width: 220px;
            background-color: var(--bs-body-bg, #ffffff);
            border: 1px solid rgba(0, 0, 0, 0.15);
            border-radius: 0.5rem;
            box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.15);
            padding: 0.25rem 0;
            display: none;
            z-index: 1081;
        }
        .workflow-context-item.has-submenu:hover > .workflow-context-submenu {
            display: block;
        }
        .workflow-context-divider {
            height: 1px;
            margin: 0.25rem 0;
            background-color: rgba(0, 0, 0, 0.1);
        }
        tr.workflow-context-target > * {
            background-color: rgba(13, 110, 253, 0.08) !important;
        }
        .json-preview {
            max-height: 60vh;
            overflow: auto;
            background-color: var(--bs-tertiary-bg);
            border-radius: 0.5rem;
            padding: 1rem;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 0.9rem;
            white-space: pre-wrap;
            color: var(--bs-body-color);
            border: 1px solid var(--bs-border-color);
        }
    </style>
    <script>
        const PROJECT_NAME = "{{ project.name }}";
        let workflowPollInterval = null;
        let workflowLogInterval = null;
        let currentWorkflowJobId = null;
        let currentLogJobId = null;
        let workflowInfoDismissed = false;
        let workflowKeysModal = null;
        let workflowStepModal = null;
        let workflowParamsModal = null;
        let workflowSaveModal = null;
        let pendingWorkflowPayload = null;
        let pendingWorkflowContext = null;
        let availableScripts = [];
        let defaultWorkflow = [];
        let workflowSteps = [];
        let workflowAutoSaveEnabled = false;
        let workflowAutoSaveTimer = null;
        let workflowAutoSavePending = false;
        let workflowSaving = false;
        let workflowSuppressAutoSave = false;
        let workflowLastSavedSnapshot = null;
        let selectedStepIndex = null;
        let selectedStepType = null;
        let selectedWidgetConfig = null;
        let currentRunContext = null;
        let cycleState = null;
        let workflowTemplates = [];
        let currentTemplateId = null;
        let workflowInitialized = false;
        let workflowContextMenu = null;
        let workflowContextState = {
            targetIndex: null,
            targetRow: null
        };

        const workflowKeyFieldMap = {
            chatgpt: { wrapperId: 'workflowKeyFieldChatgpt', inputId: 'workflowKeyChatgpt', payloadKey: 'chatgpt_api_key' },
            deepl: { wrapperId: 'workflowKeyFieldDeepl', inputId: 'workflowKeyDeepl', payloadKey: 'deepl_api_key' },
            huggingface: { wrapperId: 'workflowKeyFieldHuggingface', inputId: 'workflowKeyHuggingface', payloadKey: 'huggingface_token' }
        };
        const SECRET_PARAM_NAMES = {{ secret_param_names|tojson }};
        const SECRET_VALUE_PLACEHOLDER = '***';
        const AUDIO_EXTENSIONS = new Set({{ audio_extensions|list|sort|tojson }});
        const VIDEO_EXTENSIONS = new Set({{ video_extensions|list|sort|tojson }});
        const TEXT_PREVIEW_EXTENSIONS = new Set(['.json', '.txt', '.bak', '.log', '.srt']);
        let videoPreviewModal = null;
        let jsonPreviewModal = null;

        const workflowWidgets = [
            {
                id: 'reviewContinue',
                name: 'Review + Continue',
                description: 'Felülvizsgálati nézet megnyitása és kézi folytatás.',
                continueLabel: 'Continue',
                reviewLabel: 'Review'
            },
            {
                id: 'cycleWidget',
                name: 'Ciklus',
                description: 'Korábbi lépések többszöri futtatása a workflow-ban.',
                continueLabel: 'Ciklus futtatása',
                reviewLabel: 'Review',
                parameters: [
                    {
                        name: 'repeat_count',
                        label: 'Ismétlések száma',
                        type: 'number',
                        min: 1,
                        step: 1,
                        default: 1,
                        required: true,
                        helper: 'Hányszor ismétlődjön a kijelölt lépéssor.'
                    },
                    {
                        name: 'step_back',
                        label: 'Visszalépés lépéseinek száma',
                        type: 'number',
                        min: 1,
                        step: 1,
                        default: 1,
                        required: true,
                        helper: 'A widget előtti hány futtatható lépést ismételjen a ciklus.'
                    }
                ],
                help: 'A ciklus widget a megadott számú, aktív szkript lépést ismétli a widget előtt, a megadott alkalommal.'
            }
        ];

        function findWidgetById(widgetId) {
            if (!widgetId) {
                return null;
            }
            return workflowWidgets.find(widget => widget.id === widgetId) || null;
        }

        function normalizeWorkflowStep(step) {
            if (!step || typeof step !== 'object') {
                return;
            }
            if (!step.type) {
                if (step.widget) {
                    step.type = 'widget';
                } else if (step.script) {
                    step.type = 'script';
                }
            }
            if (step.type === 'widget') {
                if (!step.widget) {
                    step.widget = 'unknownWidget';
                }
                if (step.enabled === undefined) {
                    step.enabled = true;
                }
                if (!step.params || typeof step.params !== 'object') {
                    step.params = {};
                }
                const widgetMeta = findWidgetById(step.widget);
                if (widgetMeta && Array.isArray(widgetMeta.parameters)) {
                    widgetMeta.parameters.forEach(param => {
                        if (param && param.name && step.params[param.name] === undefined && param.default !== undefined) {
                            step.params[param.name] = param.default;
                        }
                    });
                }
            } else {
                step.type = 'script';
                if (step.enabled === undefined) {
                    step.enabled = true;
                }
                if (step.halt_on_fail === undefined) {
                    step.halt_on_fail = true;
                }
                if (!step.params || typeof step.params !== 'object') {
                    step.params = {};
                }
            }
        }

        function normalizeWorkflowStepList(steps) {
            (steps || []).forEach(normalizeWorkflowStep);
            return steps || [];
        }

        function buildRunStepFromWorkflowStep(step) {
            return {
                script: step.script,
                enabled: true,
                halt_on_fail: step.halt_on_fail !== false,
                params: cloneObject(step.params)
            };
        }

        function collectWorkflowSegment(startIndex = 0) {
            const segment = {
                startIndex,
                steps: [],
                widgetIndex: null
            };
            for (let i = startIndex; i < workflowSteps.length; i++) {
                const step = workflowSteps[i];
                if (step.type === 'widget') {
                    if (step.enabled !== false) {
                        segment.widgetIndex = i;
                        break;
                    }
                    continue;
                }
                if (step.enabled === false) {
                    continue;
                }
                segment.steps.push(buildRunStepFromWorkflowStep(step));
            }
            return segment;
        }

        function collectScriptStepsForRun(startIndex = 0) {
            return collectWorkflowSegment(startIndex).steps;
        }

        function collectWorkflowState() {
            return cloneSteps(workflowSteps);
        }

        function buildWorkflowSnapshot() {
            return {
                steps: collectWorkflowState(),
                template_id: currentTemplateId || null
            };
        }

        function hasEnabledScriptStep(steps) {
            return (steps || []).some(step => step && step.type !== 'widget' && step.enabled !== false);
        }

        function resetWorkflowAutoSave() {
            if (workflowAutoSaveTimer) {
                clearTimeout(workflowAutoSaveTimer);
                workflowAutoSaveTimer = null;
            }
            workflowAutoSavePending = false;
        }

        function markWorkflowDirty() {
            if (!workflowAutoSaveEnabled || workflowSuppressAutoSave) {
                return;
            }
            workflowAutoSavePending = true;
            scheduleWorkflowAutoSave();
        }

        function scheduleWorkflowAutoSave(delay = 500) {
            if (workflowAutoSaveTimer) {
                clearTimeout(workflowAutoSaveTimer);
            }
            workflowAutoSaveTimer = setTimeout(runWorkflowAutoSave, delay);
        }

        async function runWorkflowAutoSave() {
            workflowAutoSaveTimer = null;
            if (!workflowAutoSaveEnabled || workflowSuppressAutoSave) {
                return;
            }
            if (!workflowAutoSavePending) {
                return;
            }
            if (workflowSaving) {
                scheduleWorkflowAutoSave(300);
                return;
            }

            const snapshot = buildWorkflowSnapshot();
            const snapshotKey = JSON.stringify(snapshot);
            if (snapshotKey === workflowLastSavedSnapshot) {
                workflowAutoSavePending = false;
                return;
            }

            if (!hasEnabledScriptStep(snapshot.steps)) {
                workflowLastSavedSnapshot = snapshotKey;
                workflowAutoSavePending = false;
                return;
            }

            workflowSaving = true;
            try {
                const payload = {
                    steps: snapshot.steps,
                    template_id: snapshot.template_id,
                    saved_at: new Date().toISOString()
                };
                await persistProjectWorkflowState(payload);
                workflowLastSavedSnapshot = snapshotKey;
                workflowAutoSavePending = false;
            } catch (error) {
                console.error('Workflow állapot mentése sikertelen:', error);
                workflowAutoSavePending = true;
                scheduleWorkflowAutoSave(2000);
            } finally {
                workflowSaving = false;
            }
        }

        async function persistProjectWorkflowState(payload) {
            const response = await fetch(`/api/project-workflow-state/${encodeURIComponent(PROJECT_NAME)}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload || {})
            });
            let result = null;
            try {
                result = await response.json();
            } catch (error) {
                // ignore JSON parsing issues; handled below
            }
            if (!response.ok || !result || !result.success) {
                const message = result && result.error ? result.error : `HTTP ${response.status}`;
                throw new Error(message);
            }
            return result.state || null;
        }

        async function loadProjectWorkflowState() {
            try {
                const response = await fetch(`/api/project-workflow-state/${encodeURIComponent(PROJECT_NAME)}`, { cache: 'no-store' });
                if (response.status === 404) {
                    return null;
                }
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                const result = await response.json();
                if (!result || result.success !== true) {
                    const message = result && result.error ? result.error : 'Ismeretlen hiba';
                    throw new Error(message);
                }
                const data = result.state || {};
                const steps = Array.isArray(data.steps) ? data.steps : [];
                const templateId = data.template_id || null;
                return { steps, template_id: templateId };
            } catch (error) {
                console.warn('Nem sikerült betölteni a projekt workflow állapotát:', error);
            }
            return null;
        }

        async function loadDefaultWorkflowTemplate(templates) {
            const list = Array.isArray(templates) ? templates : [];
            const defaultEntry = list.find(item => item && item.id === 'default');
            if (!defaultEntry) {
                return null;
            }
            try {
                const response = await fetch(`/api/workflow-template/${encodeURIComponent(defaultEntry.id)}`);
                const result = await response.json();
                if (!response.ok || !result.success) {
                    throw new Error(result.error || 'Ismeretlen hiba');
                }
                const template = result.template || {};
                return Array.isArray(template.steps) ? template.steps : [];
            } catch (error) {
                console.error('Alapértelmezett workflow betöltési hiba:', error);
                return null;
            }
        }

        function collectScriptStepsBefore(index, requiredCount) {
            const collected = [];
            let count = 0;
            for (let i = index - 1; i >= 0 && count < requiredCount; i--) {
                const step = workflowSteps[i];
                if (!step || step.type === 'widget') {
                    continue;
                }
                if (step.enabled === false) {
                    continue;
                }
                collected.push(step);
                count++;
            }
            collected.reverse();
            return {
                steps: collected,
                collectedCount: count,
                requiredCount
            };
        }

        function validateStepCollection(stepCollection) {
            const errors = [];
            const missingSummary = [];
            let hasRunnableStep = false;
            (stepCollection || []).forEach(step => {
                if (!step || step.type === 'widget') {
                    return;
                }
                if (step.enabled === false) {
                    return;
                }
                hasRunnableStep = true;
                const script = findScriptById(step.script);
                if (!script) {
                    errors.push(`Ismeretlen szkript: ${step.script}`);
                    return;
                }
                const missing = getMissingParams(step, script);
                if (missing.length) {
                    missingSummary.push({ script, missing });
                }
            });
            return {
                valid: hasRunnableStep && errors.length === 0 && missingSummary.length === 0,
                hasRunnableStep,
                errors,
                missingSummary
            };
        }

        function buildRunPayload(startIndex = 0, segmentInfo = null) {
            const segment = segmentInfo || collectWorkflowSegment(startIndex);
            return {
                steps: segment.steps.map(step => ({
                    script: step.script,
                    enabled: true,
                    halt_on_fail: step.halt_on_fail !== false,
                    params: cloneObject(step.params)
                })),
                template_id: currentTemplateId,
                workflow_state: collectWorkflowState()
            };
        }

        function cloneSteps(steps) {
            const cloned = JSON.parse(JSON.stringify(steps || []));
            return normalizeWorkflowStepList(cloned);
        }

        function cloneObject(obj) {
            return JSON.parse(JSON.stringify(obj || {}));
        }

        function getScriptParamDefaults(script) {
            const defaults = new Map();
            if (!script) {
                return defaults;
            }
            (script.parameters || []).forEach(param => {
                if (!param || !param.name || defaults.has(param.name)) {
                    return;
                }
                if (Object.prototype.hasOwnProperty.call(param, 'default')) {
                    const value = param.default;
                    if (value !== undefined && value !== null) {
                        defaults.set(param.name, value);
                    }
                }
            });
            const raw = script.raw || {};
            ['required', 'optional'].forEach(key => {
                const list = raw[key];
                (list || []).forEach(param => {
                    if (!param || !param.name || defaults.has(param.name)) {
                        return;
                    }
                    const value = param.default;
                    if (value !== undefined && value !== null) {
                        defaults.set(param.name, value);
                    }
                });
            });
            return defaults;
        }

        function buildWorkdirUrl(relativePath) {
            const segments = [PROJECT_NAME];
            if (relativePath) {
                relativePath.split('/').forEach(segment => {
                    if (segment) {
                        segments.push(segment);
                    }
                });
            }
            const encoded = segments.map(part => encodeURIComponent(part));
            return `/workdir/${encoded.join('/')}`;
        }

        function getFileExtension(name) {
            if (!name || typeof name !== 'string') {
                return '';
            }
            const dotIndex = name.lastIndexOf('.');
            if (dotIndex === -1) {
                return '';
            }
            return name.substring(dotIndex).toLowerCase();
        }

        function createMetadataElement(entry) {
            const value = entry && entry.duration_display;
            if (!value) {
                return null;
            }
            const span = document.createElement('span');
            span.className = 'file-browser-meta small text-muted';
            span.textContent = value;
            return span;
        }

        function createFailedOriginalTextElement(entry) {
            const value = entry && entry.failed_original_text_display;
            if (!value) {
                return null;
            }
            const span = document.createElement('span');
            span.className = 'file-browser-note small text-muted';
            span.textContent = value;
            return span;
        }

        function createFileTreeList(entries) {
            const list = document.createElement('ul');
            list.className = 'file-browser-tree list-unstyled mb-0';
            (entries || []).forEach(entry => {
                const item = document.createElement('li');
                if (entry.type === 'directory') {
                    const details = document.createElement('details');
                    details.className = 'file-browser-directory';
                    details.dataset.path = entry.path || '';
                    if (entry.highlight_class) {
                        entry.highlight_class.split(/\s+/).forEach(cls => {
                            if (cls) {
                                details.classList.add(cls);
                            }
                        });
                        details.dataset.highlight = entry.highlight_class;
                    }

                    const summary = document.createElement('summary');
                    summary.className = 'file-browser-summary';
                    const label = document.createElement('span');
                    label.className = 'file-browser-label';
                    label.textContent = entry.name || '(névtelen mappa)';
                    const actions = document.createElement('div');
                    actions.className = 'file-browser-actions';
                    const uploadBtn = document.createElement('button');
                    uploadBtn.type = 'button';
                    uploadBtn.className = 'btn btn-sm btn-outline-secondary file-upload-trigger';
                    uploadBtn.dataset.path = entry.path || '';
                    uploadBtn.title = 'Fájl feltöltése ebbe a mappába';
                    uploadBtn.textContent = 'Feltöltés';
                    actions.append(uploadBtn);

                    const clearBtn = document.createElement('button');
                    clearBtn.type = 'button';
                    clearBtn.className = 'btn btn-sm btn-outline-danger file-directory-clear-btn';
                    clearBtn.dataset.path = entry.path || '';
                    clearBtn.title = 'Könyvtár tartalmának törlése';
                    clearBtn.textContent = 'Tartalom törlése';
                    actions.append(clearBtn);

                    summary.append(label);
                    summary.append(actions);
                    details.append(summary);

                    const children = document.createElement('div');
                    children.className = 'file-browser-children';
                    if (entry.children && entry.children.length) {
                        children.appendChild(createFileTreeList(entry.children));
                    }
                    details.append(children);

                    item.appendChild(details);
                } else {
                    const fileRow = document.createElement('div');
                    fileRow.className = 'file-browser-item';
                    fileRow.dataset.filePath = entry.path || '';
                    fileRow.dataset.fileName = entry.name || '';
                    const extension = getFileExtension(entry.name || '');
                    fileRow.dataset.fileExtension = extension;
                    if (entry.enable_failed_move) {
                        fileRow.dataset.enableFailedMove = 'true';
                    }

                    const link = document.createElement('a');
                    link.className = 'file-browser-link';
                    link.href = buildWorkdirUrl(entry.path || '');
                    link.target = '_blank';
                    link.rel = 'noopener';
                    link.textContent = entry.name || '(névtelen fájl)';

                    fileRow.appendChild(link);

                    const actions = document.createElement('div');
                    actions.className = 'file-browser-actions';

                    const deleteBtn = document.createElement('button');
                    deleteBtn.type = 'button';
                    deleteBtn.className = 'btn btn-sm btn-outline-danger file-delete-btn';
                    deleteBtn.title = 'Fájl törlése';
                    deleteBtn.textContent = 'Törlés';
                    actions.append(deleteBtn);

                    if (entry.enable_failed_move && extension === '.wav') {
                        const moveBtn = document.createElement('button');
                        moveBtn.type = 'button';
                        moveBtn.className = 'btn btn-sm btn-outline-primary file-move-to-translated-btn';
                        moveBtn.title = 'Áthelyezés a fordított szegmensek közé';
                        moveBtn.textContent = 'Áthelyezés';
                        actions.append(moveBtn);
                    }

                    fileRow.appendChild(actions);
                    const metadataElement = createMetadataElement(entry);
                    if (metadataElement) {
                        fileRow.insertBefore(metadataElement, actions);
                    }
                    const noteElement = createFailedOriginalTextElement(entry);
                    if (noteElement) {
                        fileRow.insertBefore(noteElement, actions);
                    }
                    if (entry.duration_from_name !== undefined && entry.duration_from_name !== null) {
                        fileRow.dataset.durationFromName = String(entry.duration_from_name);
                    }
                    if (entry.duration_actual !== undefined && entry.duration_actual !== null) {
                        fileRow.dataset.durationActual = String(entry.duration_actual);
                    }
                    if (entry.duration_display) {
                        fileRow.dataset.durationDisplay = entry.duration_display;
                    }
                    if (entry.failed_original_text !== undefined && entry.failed_original_text !== null) {
                        fileRow.dataset.failedOriginalText = entry.failed_original_text;
                    }
                    if (entry.failed_original_text_display) {
                        fileRow.dataset.failedOriginalTextDisplay = entry.failed_original_text_display;
                    }
                    item.appendChild(fileRow);
                }
                list.appendChild(item);
            });
            return list;
        }

        function updateDirectoryHighlight(detailsElement, highlightClass) {
            if (!detailsElement) {
                return;
            }
            const previous = detailsElement.dataset.highlight || '';
            if (previous) {
                previous.split(/\s+/).forEach(cls => {
                    if (cls) {
                        detailsElement.classList.remove(cls);
                    }
                });
            }
            if (highlightClass && highlightClass.trim()) {
                highlightClass.split(/\s+/).forEach(cls => {
                    if (cls) {
                        detailsElement.classList.add(cls);
                    }
                });
                detailsElement.dataset.highlight = highlightClass;
            } else {
                delete detailsElement.dataset.highlight;
            }
        }

        function updateFailedLegend(visible) {
            const legend = document.getElementById('failedGenerationLegend');
            if (!legend) {
                return;
            }
            if (visible) {
                legend.classList.remove('d-none');
            } else {
                legend.classList.add('d-none');
            }
        }

        async function refreshDirectory(detailsElement) {
            const childrenContainer = detailsElement.querySelector('.file-browser-children');
            if (!childrenContainer) {
                return;
            }
            const relativePath = detailsElement.dataset.path || '';
            childrenContainer.innerHTML = '<div class="small text-muted">Betöltés...</div>';
            try {
                const url = `/api/project-tree/${encodeURIComponent(PROJECT_NAME)}?path=${encodeURIComponent(relativePath)}`;
                const response = await fetch(url);
                const result = await response.json();
                if (!response.ok || !result.success) {
                    throw new Error(result.error || 'Ismeretlen hiba');
                }
                const entries = result.entries || [];
                updateDirectoryHighlight(detailsElement, result.current_highlight || '');
                if (Object.prototype.hasOwnProperty.call(result, 'has_highlights')) {
                    updateFailedLegend(Boolean(result.has_highlights));
                }
                childrenContainer.innerHTML = '';
                if (!entries.length) {
                    const empty = document.createElement('div');
                    empty.className = 'small text-muted';
                    empty.textContent = 'A mappa üres.';
                    childrenContainer.appendChild(empty);
                } else {
                    childrenContainer.appendChild(createFileTreeList(entries));
                }
            } catch (error) {
                console.error('Directory refresh failed:', error);
                childrenContainer.innerHTML = '<div class="text-danger small">Nem sikerült betölteni a könyvtár tartalmát.</div>';
            }
        }

        function cssEscape(value) {
            if (window.CSS && typeof window.CSS.escape === 'function') {
                return window.CSS.escape(value);
            }
            return (value || '').replace(/[^a-zA-Z0-9_\-]/g, (char) => `\\${char}`);
        }

        async function reloadFileBrowser(targetPath = '') {
            const browserRoot = document.getElementById('projectFileBrowser');
            if (!browserRoot) {
                return;
            }
            const normalized = (targetPath || '').replace(/\\/g, '/').replace(/^\/+|\/+$/g, '');

            if (!normalized) {
                browserRoot.innerHTML = '<div class="small text-muted">Frissítés...</div>';
                try {
                    const url = `/api/project-tree/${encodeURIComponent(PROJECT_NAME)}?path=`;
                    const response = await fetch(url);
                    const result = await response.json();
                    if (!response.ok || !result.success) {
                        throw new Error(result.error || 'Ismeretlen hiba');
                    }
                    const entries = result.entries || [];
                    browserRoot.innerHTML = '';
                    if (!entries.length) {
                        const empty = document.createElement('div');
                        empty.className = 'small text-muted';
                        empty.textContent = 'A mappa üres.';
                        browserRoot.appendChild(empty);
                    } else {
                        browserRoot.appendChild(createFileTreeList(entries));
                    }
                    if (Object.prototype.hasOwnProperty.call(result, 'has_highlights')) {
                        updateFailedLegend(Boolean(result.has_highlights));
                    }
                } catch (error) {
                    console.error('Root refresh failed:', error);
                    browserRoot.innerHTML = '<div class="text-danger small">Nem sikerült frissíteni a fájlok listáját.</div>';
                }
                return;
            }

            const selector = `details.file-browser-directory[data-path="${cssEscape(normalized)}"]`;
            const details = browserRoot.querySelector(selector);
            if (details) {
                await refreshDirectory(details);
                details.setAttribute('open', '');
            } else {
                await reloadFileBrowser('');
            }
        }

        function openUploadDialog(targetPath = '') {
            const uploadInput = document.getElementById('projectFileUploadInput');
            if (!uploadInput) {
                return;
            }
            uploadInput.dataset.targetPath = targetPath || '';
            uploadInput.value = '';
            uploadInput.click();
        }

        async function uploadFileToPath(targetPath, file) {
            const formData = new FormData();
            formData.append('projectName', PROJECT_NAME);
            formData.append('targetPath', targetPath || '');
            formData.append('file', file);

            const response = await fetch('/api/project-file/upload', {
                method: 'POST',
                body: formData
            });

            let result = {};
            try {
                result = await response.json();
            } catch (error) {
                // ignore JSON parse error, handled below
            }

            if (!response.ok || !result.success) {
                throw new Error((result && result.error) || 'Nem sikerült feltölteni a fájlt.');
            }
            return result;
        }

        async function deleteProjectFile(filePath, { ignoreMissing = false } = {}) {
            const response = await fetch(`/api/project-file/${encodeURIComponent(PROJECT_NAME)}`, {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ path: filePath })
            });

            if (response.status === 404 && ignoreMissing) {
                return { success: true, skipped: true };
            }

            let result = {};
            try {
                result = await response.json();
            } catch (error) {
                // ignore
            }

            if (!response.ok || !result.success) {
                throw new Error((result && result.error) || 'Nem sikerült törölni a fájlt.');
            }
            return result;
        }

        async function clearProjectDirectory(directoryPath) {
            const response = await fetch(`/api/project-directory/${encodeURIComponent(PROJECT_NAME)}`, {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ path: directoryPath })
            });

            let result = {};
            try {
                result = await response.json();
            } catch (error) {
                // ignore
            }

            if (!response.ok || !result.success) {
                throw new Error((result && result.error) || 'Nem sikerült törölni a könyvtár tartalmát.');
            }
            return result;
        }

        async function moveFailedGenerationFileRequest(filePath) {
            const response = await fetch('/api/project-file/move-failed', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    projectName: PROJECT_NAME,
                    sourcePath: filePath
                })
            });

            let result = {};
            try {
                result = await response.json();
            } catch (error) {
                // ignore
            }

            if (!response.ok || !result.success) {
                throw new Error((result && result.error) || 'Nem sikerült áthelyezni a fájlt.');
            }
            return result;
        }

        function showVideoPreview(fileName, fileUrl) {
            const modalElement = document.getElementById('videoPreviewModal');
            if (!modalElement) {
                window.open(fileUrl, '_blank');
                return;
            }
            if (!videoPreviewModal) {
                videoPreviewModal = new bootstrap.Modal(modalElement);
            }

            const titleElement = document.getElementById('videoPreviewTitle');
            if (titleElement) {
                titleElement.textContent = fileName || 'Videó lejátszása';
            }

            const videoElement = document.getElementById('videoPreviewPlayer');
            if (!videoElement) {
                window.open(fileUrl, '_blank');
                return;
            }

            videoElement.pause();
            videoElement.src = fileUrl;
            videoElement.load();

            const handleShown = () => {
                videoElement.play().catch(() => {
                    // Autoplay might be blocked; user can start manually.
                });
            };

            if (modalElement.classList.contains('show')) {
                handleShown();
            } else {
                modalElement.addEventListener('shown.bs.modal', handleShown, { once: true });
            }

            videoPreviewModal.show();
        }

        async function showTextPreview(fileName, fileUrl, extension) {
            const modalElement = document.getElementById('jsonPreviewModal');
            if (!modalElement) {
                window.open(fileUrl, '_blank');
                return;
            }
            if (!jsonPreviewModal) {
                jsonPreviewModal = new bootstrap.Modal(modalElement);
            }
            const titleElement = document.getElementById('jsonPreviewTitle');
            if (titleElement) {
                titleElement.textContent = fileName || 'Fájl előnézete';
            }
            const contentElement = document.getElementById('jsonPreviewContent');
            if (contentElement) {
                contentElement.textContent = 'Betöltés...';
            }
            jsonPreviewModal.show();

            try {
                const response = await fetch(fileUrl, {
                    headers: {
                        'Accept': 'application/json, text/plain;q=0.9, */*;q=0.8'
                    }
                });
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                const text = await response.text();
                let formatted = text;
                if (extension === '.json') {
                    try {
                        const parsed = JSON.parse(text);
                        formatted = JSON.stringify(parsed, null, 2);
                    } catch (error) {
                        // fallback to raw text
                    }
                }
                if (contentElement) {
                    contentElement.textContent = formatted || 'Üres fájl.';
                }
            } catch (error) {
                console.error('Text preview failed:', error);
                if (contentElement) {
                    contentElement.textContent = `Nem sikerült betölteni a fájlt.\n${error.message || error}`;
                }
            }
        }

        function initPreviewModals() {
            const audioModalElement = document.getElementById('audioPreviewModal');
            if (audioModalElement && (!window.AudioTrimmer || typeof AudioTrimmer.init !== 'function')) {
                audioModalElement.addEventListener('hidden.bs.modal', () => {
                    const titleElement = document.getElementById('audioPreviewTitle');
                    if (titleElement) {
                        titleElement.textContent = '';
                    }
                });
            }

            const videoModalElement = document.getElementById('videoPreviewModal');
            if (videoModalElement) {
                videoPreviewModal = new bootstrap.Modal(videoModalElement);
                videoModalElement.addEventListener('hidden.bs.modal', () => {
                    const videoElement = document.getElementById('videoPreviewPlayer');
                    if (videoElement) {
                        videoElement.pause();
                        videoElement.removeAttribute('src');
                        videoElement.load();
                    }
                    const titleElement = document.getElementById('videoPreviewTitle');
                    if (titleElement) {
                        titleElement.textContent = '';
                    }
                });
            }

            const jsonModalElement = document.getElementById('jsonPreviewModal');
            if (jsonModalElement) {
                jsonPreviewModal = new bootstrap.Modal(jsonModalElement);
                jsonModalElement.addEventListener('hidden.bs.modal', () => {
                    const contentElement = document.getElementById('jsonPreviewContent');
                    if (contentElement) {
                        contentElement.textContent = '';
                    }
                    const titleElement = document.getElementById('jsonPreviewTitle');
                    if (titleElement) {
                        titleElement.textContent = '';
                    }
                });
            }
        }

        function initProjectFileActions() {
            const uploadInput = document.getElementById('projectFileUploadInput');
            if (uploadInput) {
                uploadInput.addEventListener('change', async (event) => {
                    const files = Array.from(event.target.files || []);
                    if (!files.length) {
                        return;
                    }
                    const targetPath = uploadInput.dataset.targetPath || '';
                    try {
                        await uploadFileToPath(targetPath, files[0]);
                        alert('Fájl sikeresen feltöltve.');
                        await reloadFileBrowser(targetPath);
                    } catch (error) {
                        alert(error.message || 'Nem sikerült feltölteni a fájlt.');
                    } finally {
                        uploadInput.value = '';
                        delete uploadInput.dataset.targetPath;
                    }
                });
            }

            const rootUploadBtn = document.getElementById('rootUploadBtn');
            if (rootUploadBtn) {
                rootUploadBtn.addEventListener('click', () => openUploadDialog(''));
            }

            const refreshBtn = document.getElementById('refreshFileBrowserBtn');
            if (refreshBtn) {
                refreshBtn.addEventListener('click', () => {
                    reloadFileBrowser('');
                });
            }
        }

        function initFileBrowser() {
            const browserRoot = document.getElementById('projectFileBrowser');
            if (!browserRoot) {
                return;
            }

            browserRoot.addEventListener('click', async (event) => {
                const uploadButton = event.target.closest('.file-upload-trigger');
                if (uploadButton && browserRoot.contains(uploadButton)) {
                    event.preventDefault();
                    event.stopPropagation();
                    openUploadDialog(uploadButton.dataset.path || '');
                    return;
                }

                const clearDirectoryButton = event.target.closest('.file-directory-clear-btn');
                if (clearDirectoryButton && browserRoot.contains(clearDirectoryButton)) {
                    event.preventDefault();
                    event.stopPropagation();
                    const detailsElement = clearDirectoryButton.closest('details.file-browser-directory');
                    if (!detailsElement) {
                        return;
                    }
                    const directoryPath = clearDirectoryButton.dataset.path || detailsElement.dataset.path || '';
                    if (!directoryPath) {
                        alert('A mappa útvonala nem határozható meg.');
                        return;
                    }
                    const labelElement = detailsElement.querySelector('.file-browser-label');
                    const directoryName = (labelElement && labelElement.textContent) ? labelElement.textContent.trim() : directoryPath;
                    const confirmed = confirm(`Biztosan törlöd a(z) "${directoryName}" mappa teljes tartalmát?\nA mappa megmarad, de minden fájl és alkönyvtár törlődik.`);
                    if (!confirmed) {
                        return;
                    }
                    clearDirectoryButton.disabled = true;
                    try {
                        await clearProjectDirectory(directoryPath);
                        alert('A mappa tartalma sikeresen törölve.');
                        await refreshDirectory(detailsElement);
                        detailsElement.setAttribute('open', '');
                    } catch (error) {
                        alert(error.message || 'Nem sikerült törölni a mappa tartalmát.');
                    } finally {
                        clearDirectoryButton.disabled = false;
                    }
                    return;
                }

                const deleteButton = event.target.closest('.file-delete-btn');
                if (deleteButton && browserRoot.contains(deleteButton)) {
                    event.preventDefault();
                    event.stopPropagation();
                    const fileRow = deleteButton.closest('.file-browser-item');
                    if (!fileRow) {
                        return;
                    }
                    const filePath = fileRow.dataset.filePath || '';
                    if (!filePath) {
                        return;
                    }
                    const fileName = fileRow.dataset.fileName || filePath.split('/').pop();
                    const confirmed = confirm(`Biztosan törlöd ezt a fájlt?\n${fileName}`);
                    if (!confirmed) {
                        return;
                    }
                    try {
                        await deleteProjectFile(filePath);
                        const parentPath = filePath.includes('/') ? filePath.substring(0, filePath.lastIndexOf('/')) : '';
                        alert('Fájl sikeresen törölve.');
                        await reloadFileBrowser(parentPath);
                    } catch (error) {
                        alert(error.message || 'Nem sikerült törölni a fájlt.');
                    }
                    return;
                }

                const moveButton = event.target.closest('.file-move-to-translated-btn');
                if (moveButton && browserRoot.contains(moveButton)) {
                    event.preventDefault();
                    event.stopPropagation();
                    const fileRow = moveButton.closest('.file-browser-item');
                    if (!fileRow) {
                        return;
                    }
                    const filePath = fileRow.dataset.filePath || '';
                    if (!filePath) {
                        return;
                    }
                    const fileName = fileRow.dataset.fileName || filePath.split('/').pop();
                    const confirmed = confirm(`Áthelyezed ezt a fájlt a fordított szegmensek közé?\n${fileName}`);
                    if (!confirmed) {
                        return;
                    }
                    moveButton.disabled = true;
                    try {
                        await moveFailedGenerationFileRequest(filePath);
                        const parentPath = filePath.includes('/') ? filePath.substring(0, filePath.lastIndexOf('/')) : '';
                        alert('Fájl sikeresen áthelyezve.');
                        await reloadFileBrowser(parentPath);
                    } catch (error) {
                        alert(error.message || 'Nem sikerült áthelyezni a fájlt.');
                    } finally {
                        moveButton.disabled = false;
                    }
                    return;
                }

                const fileLink = event.target.closest('.file-browser-link');
                if (fileLink && browserRoot.contains(fileLink)) {
                    if (event.metaKey || event.ctrlKey || event.shiftKey || event.button !== 0) {
                        return;
                    }
                    const fileRow = fileLink.closest('.file-browser-item');
                    if (!fileRow) {
                        return;
                    }
                    const fileName = fileRow.dataset.fileName || '';
                    const filePath = fileRow.dataset.filePath || '';
                    const extension = (fileRow.dataset.fileExtension || '').toLowerCase();

                    if (AUDIO_EXTENSIONS.has(extension)) {
                        event.preventDefault();
                        event.stopPropagation();
                        if (window.AudioTrimmer && typeof AudioTrimmer.showPreview === 'function') {
                            AudioTrimmer.showPreview(fileName, buildWorkdirUrl(filePath), filePath);
                        } else {
                            window.open(buildWorkdirUrl(filePath), '_blank');
                        }
                        return;
                    }

                    if (VIDEO_EXTENSIONS.has(extension)) {
                        event.preventDefault();
                        event.stopPropagation();
                        showVideoPreview(fileName, buildWorkdirUrl(filePath));
                        return;
                    }

                    if (TEXT_PREVIEW_EXTENSIONS.has(extension)) {
                        event.preventDefault();
                        event.stopPropagation();
                        await showTextPreview(fileName, buildWorkdirUrl(filePath), extension);
                        return;
                    }

                    return;
                }

                const summary = event.target.closest('summary.file-browser-summary');
                if (!summary || !browserRoot.contains(summary)) {
                    return;
                }

                const details = summary.closest('details.file-browser-directory');
                if (!details) {
                    return;
                }

                if (event.target.closest('.file-browser-actions')) {
                    return;
                }

                event.preventDefault();

                if (details.dataset.loading === 'true') {
                    return;
                }

                const isOpen = details.hasAttribute('open');
                if (isOpen) {
                    details.removeAttribute('open');
                    return;
                }

                details.dataset.loading = 'true';
                try {
                    await refreshDirectory(details);
                    details.setAttribute('open', '');
                } finally {
                    delete details.dataset.loading;
                }
            });
        }

        function findScriptById(scriptId) {
            if (!scriptId) return null;
            return availableScripts.find(entry => entry.id === scriptId) || null;
        }

        function getMissingParams(step, script) {
            if (!script || !script.parameters) {
                return [];
            }
            const defaults = getScriptParamDefaults(script);
            return script.parameters
                .filter(param => param.required && param.type !== 'flag' && !param.autofill)
                .filter(param => {
                    const value = step.params ? step.params[param.name] : undefined;
                    let hasValue = value !== undefined && value !== null;
                    if (hasValue && typeof value === 'string' && value.trim() === '') {
                        hasValue = false;
                    }
                    if (hasValue) {
                        return false;
                    }
                    if (defaults.has(param.name)) {
                        const defaultValue = defaults.get(param.name);
                        if (defaultValue !== undefined && defaultValue !== null) {
                            if (!(typeof defaultValue === 'string' && defaultValue.trim() === '')) {
                                return false;
                            }
                        }
                    }
                    return true;
                })
                .map(param => param.name);
        }

        function describeStepParameters(step, script, missing) {
            if (missing && missing.length) {
                return `Hiányzó kötelező paraméterek: ${missing.join(', ')}`;
            }
            const summary = [];
            if (script && script.parameters) {
                script.parameters.forEach(param => {
                    const value = step.params ? step.params[param.name] : undefined;
                    const hasValue = value !== undefined && value !== null && !(typeof value === 'string' && value.trim() === '');
                    if (param.type === 'flag') {
                        if (value === true) {
                            summary.push(`${param.name}=on`);
                        } else if (value === false) {
                            summary.push(`${param.name}=off`);
                        }
                    } else if (param.secret) {
                        if (hasValue) {
                            summary.push(`${param.name}=${SECRET_VALUE_PLACEHOLDER}`);
                        }
                    } else if (hasValue) {
                        summary.push(`${param.name}=${value}`);
                    }
                });
            }
            Object.entries(step.params || {}).forEach(([key, value]) => {
                if (!script || !(script.parameters || []).some(param => param.name === key)) {
                    if (SECRET_PARAM_NAMES.includes(key)) {
                        summary.push(`${key}=${SECRET_VALUE_PLACEHOLDER}`);
                    } else if (value !== undefined && value !== null && !(typeof value === 'string' && value.trim() === '')) {
                        summary.push(`${key}=${value}`);
                    }
                }
            });
            return summary.length ? summary.join(', ') : 'Nincs megadott paraméter';
        }

        function describeWidgetParameters(widget, step) {
            if (!widget || !Array.isArray(widget.parameters) || !widget.parameters.length) {
                return '';
            }
            const params = step && step.params ? step.params : {};
            const summary = [];
            widget.parameters.forEach(param => {
                if (!param || !param.name) {
                    return;
                }
                const label = param.label || param.name;
                const hasOwnValue = Object.prototype.hasOwnProperty.call(params, param.name);
                let value = hasOwnValue ? params[param.name] : param.default;
                if (value === undefined || value === null || (typeof value === 'string' && value.trim() === '')) {
                    return;
                }
                summary.push(`${label}: ${value}`);
            });
            return summary.join(' • ');
        }

        function formatScriptDirectoryName(script, step) {
            const rawPath = (script && script.script) || (step && step.script) || '';
            if (typeof rawPath === 'string' && rawPath) {
                const normalized = rawPath.replace(/\\/g, '/');
                const segments = normalized.split('/').filter(Boolean);
                if (segments.length >= 2) {
                    const parentDir = segments[segments.length - 2];
                    if (parentDir) {
                        return parentDir.replace(/_/g, ' ');
                    }
                } else if (segments.length === 1) {
                    return segments[0].replace(/_/g, ' ');
                }
            }
            if (script && script.display_name) {
                return script.display_name;
            }
            if (step && typeof step.script === 'string') {
                return step.script.replace(/_/g, ' ');
            }
            return 'Ismeretlen script';
        }

        function updateMissingBadge() {
            const badge = document.getElementById('workflowMissingBadge');
            if (!badge) return;
            const hasMissing = workflowSteps.some(step =>
                step.type !== 'widget' &&
                step.enabled !== false &&
                getMissingParams(step, findScriptById(step.script)).length
            );
            badge.classList.toggle('d-none', !hasMissing);
        }

        function findTemplateById(templateId) {
            if (!templateId) {
                return null;
            }
            return workflowTemplates.find(item => item.id === templateId) || null;
        }

        function populateWorkflowTemplateSelect(selectedId) {
            const select = document.getElementById('workflowTemplateSelect');
            if (!select) {
                return;
            }
            const previousValue = selectedId !== undefined ? selectedId : select.value;
            select.innerHTML = '';

            const placeholder = document.createElement('option');
            placeholder.value = '';
            placeholder.textContent = 'Válassz sablont...';
            select.append(placeholder);

            workflowTemplates.forEach(template => {
                const option = document.createElement('option');
                option.value = template.id;
                option.textContent = template.name || template.id;
                select.append(option);
            });

            const targetValue = selectedId !== undefined ? selectedId : previousValue;
            if (targetValue && Array.from(select.options).some(option => option.value === targetValue)) {
                select.value = targetValue;
                currentTemplateId = targetValue;
            } else {
                select.value = '';
                if (selectedId !== undefined) {
                    currentTemplateId = null;
                }
            }
        }

        async function refreshWorkflowTemplates(selectedId = currentTemplateId) {
            try {
                const response = await fetch('/api/workflow-templates');
                const result = await response.json();
                if (!response.ok || !result.success) {
                    throw new Error(result.error || 'Nem sikerült lekérdezni a sablonokat.');
                }
                workflowTemplates = result.templates || [];
                populateWorkflowTemplateSelect(selectedId);
            } catch (error) {
                console.error('Workflow sablon lista frissítési hiba:', error);
            }
        }

        async function loadWorkflowTemplateById(templateId, showMessage = true) {
            if (!templateId) {
                alert('Előbb válassz egy workflow sablont.');
                return;
            }
            try {
                const response = await fetch(`/api/workflow-template/${encodeURIComponent(templateId)}`);
                const result = await response.json();
                if (!response.ok || !result.success) {
                    throw new Error(result.error || 'Nem sikerült betölteni a sablont.');
                }
                const template = result.template || {};
                currentTemplateId = template.id || templateId;
                workflowSteps = cloneSteps(template.steps || []);
                defaultWorkflow = cloneSteps(template.steps || []);
                markWorkflowDirty();
                populateWorkflowTemplateSelect(currentTemplateId);
                renderWorkflowSteps();
                if (showMessage) {
                    updateInfoBox('info', `${template.name || currentTemplateId} sablon betöltve.`);
                }
            } catch (error) {
                console.error('Workflow sablon betöltési hiba:', error);
                alert('Nem sikerült betölteni a kiválasztott workflow-t: ' + error.message);
            }
        }

        function showSaveWorkflowModal() {
            const modalElement = document.getElementById('workflowSaveModal');
            if (!modalElement) {
                return;
            }
            const nameInput = document.getElementById('workflowSaveName');
            const descriptionInput = document.getElementById('workflowSaveDescription');
            const overwriteCheckbox = document.getElementById('workflowSaveOverwrite');
            const overwriteInfo = document.getElementById('workflowSaveOverwriteInfo');
            const errorBox = document.getElementById('workflowSaveError');

            const currentTemplate = findTemplateById(currentTemplateId);
            if (nameInput) {
                nameInput.value = currentTemplate ? (currentTemplate.name || '') : '';
            }
            if (descriptionInput) {
                descriptionInput.value = currentTemplate ? (currentTemplate.description || '') : '';
            }
            if (overwriteCheckbox) {
                overwriteCheckbox.checked = false;
                overwriteCheckbox.disabled = !currentTemplateId;
            }
            if (overwriteInfo) {
                if (currentTemplate) {
                    overwriteInfo.textContent = `Aktuális sablon: ${currentTemplate.name} (${currentTemplate.id})`;
                    overwriteInfo.classList.remove('d-none');
                } else {
                    overwriteInfo.classList.add('d-none');
                }
            }
            if (errorBox) {
                errorBox.classList.add('d-none');
                errorBox.textContent = '';
            }
            if (!workflowSaveModal) {
                workflowSaveModal = new bootstrap.Modal(modalElement);
            }
            workflowSaveModal.show();
        }

        async function saveWorkflowTemplateFromModal() {
            const nameInput = document.getElementById('workflowSaveName');
            const descriptionInput = document.getElementById('workflowSaveDescription');
            const overwriteCheckbox = document.getElementById('workflowSaveOverwrite');
            const errorBox = document.getElementById('workflowSaveError');

            const name = nameInput ? nameInput.value.trim() : '';
            const description = descriptionInput ? descriptionInput.value.trim() : '';
            const overwrite = overwriteCheckbox ? overwriteCheckbox.checked : false;

            if (errorBox) {
                errorBox.classList.add('d-none');
                errorBox.textContent = '';
            }

            if (overwrite && !currentTemplateId) {
                if (errorBox) {
                    errorBox.textContent = 'Nincs kiválasztott sablon, amit felül lehetne írni.';
                    errorBox.classList.remove('d-none');
                }
                return;
            }

            if (!name && !overwrite) {
                if (errorBox) {
                    errorBox.textContent = 'Adj meg egy nevet a workflow sablonnak.';
                    errorBox.classList.remove('d-none');
                }
                return;
            }

            const workflowState = collectWorkflowState();
            const body = {
                name,
                description,
                steps: workflowState,
                overwrite
            };
            if (overwrite && currentTemplateId) {
                body.template_id = currentTemplateId;
            }

            try {
                const response = await fetch('/api/save-workflow-template', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });
                const result = await response.json();
                if (!response.ok || !result.success) {
                    throw new Error(result.error || 'Nem sikerült elmenteni a workflow sablont.');
                }
                if (workflowSaveModal) {
                    workflowSaveModal.hide();
                }
                const savedTemplate = result.template || {};
                currentTemplateId = savedTemplate.id || currentTemplateId;
                defaultWorkflow = cloneSteps(workflowState);
                await refreshWorkflowTemplates(currentTemplateId);
                populateWorkflowTemplateSelect(currentTemplateId);
                updateInfoBox('success', `Workflow sablon elmentve: ${savedTemplate.name || currentTemplateId}.`);
            } catch (error) {
                console.error('Workflow sablon mentési hiba:', error);
                if (errorBox) {
                    errorBox.textContent = error.message;
                    errorBox.classList.remove('d-none');
                }
            }
        }

        function initWorkflowButtons() {
            const templateSelect = document.getElementById('workflowTemplateSelect');
            if (templateSelect) {
                templateSelect.addEventListener('change', event => {
                    const value = event.target.value || '';
                    if (!value) {
                        currentTemplateId = null;
                        return;
                    }
                    if (value === currentTemplateId) {
                        return;
                    }
                    currentTemplateId = value;
                    loadWorkflowTemplateById(currentTemplateId);
                });
            }

            const saveTemplateBtn = document.getElementById('saveWorkflowBtn');
            if (saveTemplateBtn) {
                saveTemplateBtn.addEventListener('click', showSaveWorkflowModal);
            }

            const resetBtn = document.getElementById('resetWorkflowBtn');
            if (resetBtn) {
                resetBtn.addEventListener('click', () => {
                    if (!defaultWorkflow.length) {
                        alert('Nincs elérhető alapértelmezett workflow.');
                        return;
                    }
                    if (!confirm('Biztosan visszaállítod az alapértelmezett lépéssort?')) {
                        return;
                    }
                    workflowSteps = cloneSteps(defaultWorkflow);
                    markWorkflowDirty();
                    renderWorkflowSteps();
                    updateInfoBox('info', 'Az alapértelmezett lépéssor betöltve.');
                });
            }

            const startBtn = document.getElementById('startWorkflowBtn');
            if (startBtn) {
                startBtn.addEventListener('click', handleStartWorkflow);
            }

            const stopBtn = document.getElementById('stopWorkflowBtn');
            if (stopBtn) {
                stopBtn.addEventListener('click', stopWorkflow);
            }

            const searchInput = document.getElementById('workflowStepSearch');
            if (searchInput) {
                searchInput.addEventListener('input', event => populateWorkflowStepList(event.target.value || ''));
            }
        }

        function initWorkflowContextMenu() {
            if (workflowContextMenu) {
                return;
            }
            workflowContextMenu = document.createElement('div');
            workflowContextMenu.id = 'workflowContextMenu';
            workflowContextMenu.className = 'workflow-context-menu';
            workflowContextMenu.addEventListener('contextmenu', event => event.preventDefault());
            document.body.append(workflowContextMenu);

            document.addEventListener('click', event => {
                if (!workflowContextMenu || !workflowContextMenu.classList.contains('show')) {
                    return;
                }
                if (workflowContextMenu.contains(event.target)) {
                    return;
                }
                hideWorkflowContextMenu();
            });

            document.addEventListener('keydown', event => {
                if (event.key === 'Escape') {
                    hideWorkflowContextMenu();
                }
            });

            window.addEventListener('resize', hideWorkflowContextMenu);
            document.addEventListener('scroll', hideWorkflowContextMenu, true);

            const stepsTable = document.getElementById('workflowStepsTable');
            if (stepsTable) {
                stepsTable.addEventListener('contextmenu', event => {
                    const row = event.target.closest('tr[data-step-index]');
                    const rawIndex = row ? parseInt(row.dataset.stepIndex, 10) : NaN;
                    const targetIndex = Number.isNaN(rawIndex) ? null : rawIndex;
                    showWorkflowContextMenu(event, row || null, targetIndex);
                });
            }
        }

        function hideWorkflowContextMenu() {
            if (!workflowContextMenu) {
                return;
            }
            workflowContextMenu.classList.remove('show');
            workflowContextMenu.innerHTML = '';
            if (workflowContextState.targetRow) {
                workflowContextState.targetRow.classList.remove('workflow-context-target');
            }
            workflowContextState.targetIndex = null;
            workflowContextState.targetRow = null;
        }

        function showWorkflowContextMenu(event, rowElement, targetIndex) {
            event.preventDefault();
            if (!workflowContextMenu) {
                return;
            }

            hideWorkflowContextMenu();

            workflowContextState.targetIndex = typeof targetIndex === 'number' ? targetIndex : null;
            workflowContextState.targetRow = rowElement || null;
            if (workflowContextState.targetRow) {
                workflowContextState.targetRow.classList.add('workflow-context-target');
            }

            const positions = [
                { key: 'above', label: 'Beszúrás fölé' },
                { key: 'below', label: 'Beszúrás alá' }
            ];

            positions.forEach(position => {
                const item = document.createElement('div');
                item.className = 'workflow-context-item has-submenu';
                item.textContent = position.label;
                const submenu = buildWorkflowInsertSubmenu(position.key);
                item.append(submenu);
                workflowContextMenu.append(item);
            });

            const pageX = event.pageX;
            const pageY = event.pageY;
            workflowContextMenu.style.left = `${pageX}px`;
            workflowContextMenu.style.top = `${pageY}px`;
            workflowContextMenu.classList.add('show');

            requestAnimationFrame(() => {
                const rect = workflowContextMenu.getBoundingClientRect();
                let adjustedLeft = pageX;
                let adjustedTop = pageY;
                const viewportRight = window.scrollX + window.innerWidth;
                const viewportBottom = window.scrollY + window.innerHeight;
                if (rect.right > viewportRight) {
                    adjustedLeft = viewportRight - rect.width - 8;
                }
                if (rect.bottom > viewportBottom) {
                    adjustedTop = viewportBottom - rect.height - 8;
                }
                workflowContextMenu.style.left = `${Math.max(window.scrollX + 8, adjustedLeft)}px`;
                workflowContextMenu.style.top = `${Math.max(window.scrollY + 8, adjustedTop)}px`;
            });
        }

        function buildWorkflowInsertSubmenu(position) {
            const submenu = document.createElement('div');
            submenu.className = 'workflow-context-submenu';
            const scriptTree = buildScriptDirectoryTree();
            const hasDirectoryContent = scriptTree.children.size > 0;
            const hasRootScripts = scriptTree.scripts.length > 0;
            const hasAnyScripts = hasDirectoryContent || hasRootScripts;

            if (workflowWidgets.length) {
                const widgetItem = document.createElement('div');
                widgetItem.className = 'workflow-context-item has-submenu';
                widgetItem.textContent = 'Widgetek';
                const widgetSubmenu = document.createElement('div');
                widgetSubmenu.className = 'workflow-context-submenu';

                workflowWidgets.forEach(widget => {
                    const widgetOption = document.createElement('div');
                    widgetOption.className = 'workflow-context-item';
                    widgetOption.textContent = widget.name;
                    widgetOption.addEventListener('click', event => {
                        event.preventDefault();
                        event.stopPropagation();
                        insertWorkflowWidget(widget.id, position);
                    });
                    widgetSubmenu.append(widgetOption);
                });

                widgetItem.append(widgetSubmenu);
                submenu.append(widgetItem);
            }

            if (workflowWidgets.length && hasAnyScripts) {
                const divider = document.createElement('div');
                divider.className = 'workflow-context-divider';
                submenu.append(divider);
            }

            if (hasRootScripts) {
                const rootItem = document.createElement('div');
                rootItem.className = 'workflow-context-item has-submenu';
                rootItem.textContent = 'Gyökér';
                const rootSubmenu = document.createElement('div');
                rootSubmenu.className = 'workflow-context-submenu';
                appendScriptsToMenu(rootSubmenu, scriptTree.scripts, position);
                rootItem.append(rootSubmenu);
                submenu.append(rootItem);
            }

            appendDirectoryTreeToMenu(submenu, scriptTree.children, position);

            if (!workflowWidgets.length && !hasAnyScripts) {
                const empty = document.createElement('div');
                empty.className = 'workflow-context-item disabled';
                empty.textContent = 'Nincs elérhető elem';
                submenu.append(empty);
            }

            return submenu;
        }

        function buildScriptDirectoryTree() {
            const createNode = name => ({
                name,
                children: new Map(),
                scripts: []
            });

            const root = createNode('');

            availableScripts.forEach(script => {
                const normalizedPath = String(script.script || '').replace(/\\/g, '/');
                let relativePath = normalizedPath;
                if (relativePath.startsWith('scripts/')) {
                    relativePath = relativePath.slice('scripts/'.length);
                }

                const pathParts = relativePath.split('/').filter(Boolean);
                const directories = pathParts.slice(0, -1);
                const fileName = pathParts[pathParts.length - 1] || (script.display_name || script.script || script.id);

                let current = root;
                directories.forEach(segment => {
                    if (!current.children.has(segment)) {
                        current.children.set(segment, createNode(segment));
                    }
                    current = current.children.get(segment);
                });

                current.scripts.push({
                    data: script,
                    fileName
                });
            });

            return root;
        }

        function appendDirectoryTreeToMenu(parentMenu, childrenMap, position) {
            const sortedChildren = Array
                .from(childrenMap.values())
                .sort((childA, childB) => childA.name.localeCompare(childB.name));

            sortedChildren.forEach(child => {
                const hasNestedDirectories = child.children.size > 0;
                const scriptCount = child.scripts.length;

                if (!hasNestedDirectories && scriptCount === 1) {
                    const singleItem = document.createElement('div');
                    singleItem.className = 'workflow-context-item';
                    singleItem.textContent = child.name;
                    singleItem.addEventListener('click', event => {
                        event.preventDefault();
                        event.stopPropagation();
                        insertWorkflowScript(child.scripts[0].data.id, position);
                    });
                    parentMenu.append(singleItem);
                    return;
                }

                const dirItem = document.createElement('div');
                dirItem.className = 'workflow-context-item has-submenu';
                dirItem.textContent = child.name;
                const childSubmenu = document.createElement('div');
                childSubmenu.className = 'workflow-context-submenu';

                appendDirectoryTreeToMenu(childSubmenu, child.children, position);
                appendScriptsToMenu(childSubmenu, child.scripts, position);

                dirItem.append(childSubmenu);
                parentMenu.append(dirItem);
            });
        }

        function appendScriptsToMenu(menuElement, scripts, position) {
            const sortedScripts = scripts
                .slice()
                .sort((entryA, entryB) => {
                    const labelA = getScriptMenuLabel(entryA).toLowerCase();
                    const labelB = getScriptMenuLabel(entryB).toLowerCase();
                    return labelA.localeCompare(labelB);
                });

            sortedScripts.forEach(entry => {
                const scriptOption = document.createElement('div');
                scriptOption.className = 'workflow-context-item';
                scriptOption.textContent = getScriptMenuLabel(entry);
                scriptOption.addEventListener('click', event => {
                    event.preventDefault();
                    event.stopPropagation();
                    insertWorkflowScript(entry.data.id, position);
                });
                menuElement.append(scriptOption);
            });
        }

        function getScriptMenuLabel(entry) {
            if (!entry || !entry.data) {
                return '';
            }
            return entry.data.display_name || entry.fileName || entry.data.script || entry.data.id || '';
        }

        function calculateInsertIndex(position) {
            if (typeof workflowContextState.targetIndex !== 'number' || Number.isNaN(workflowContextState.targetIndex)) {
                return workflowSteps.length;
            }
            if (position === 'above') {
                return Math.max(0, Math.min(workflowContextState.targetIndex, workflowSteps.length));
            }
            return Math.max(0, Math.min(workflowContextState.targetIndex + 1, workflowSteps.length));
        }

        function insertWorkflowScript(scriptId, position) {
            const insertIndex = calculateInsertIndex(position);
            hideWorkflowContextMenu();
            addWorkflowStep(scriptId, insertIndex);
        }

        function insertWorkflowWidget(widgetId, position) {
            const insertIndex = calculateInsertIndex(position);
            hideWorkflowContextMenu();
            addWorkflowWidget(widgetId, insertIndex);
        }

        function initWorkflowModals() {
            const stepModalElement = document.getElementById('workflowStepModal');
            if (stepModalElement) {
                workflowStepModal = new bootstrap.Modal(stepModalElement);
                stepModalElement.addEventListener('shown.bs.modal', () => {
                    const searchInput = document.getElementById('workflowStepSearch');
                    if (searchInput) {
                        searchInput.value = '';
                        searchInput.focus();
                        populateWorkflowStepList('');
                    }
                });
            }

            const paramsModalElement = document.getElementById('workflowParamsModal');
            if (paramsModalElement) {
                workflowParamsModal = new bootstrap.Modal(paramsModalElement);
                paramsModalElement.addEventListener('hidden.bs.modal', () => {
                    selectedStepIndex = null;
                    selectedStepType = null;
                    selectedWidgetConfig = null;
                    const alertBox = document.getElementById('workflowParamsAlert');
                    if (alertBox) {
                        alertBox.classList.add('d-none');
                        alertBox.textContent = '';
                    }
                });
                const saveBtn = document.getElementById('workflowParamsSaveBtn');
                if (saveBtn) {
                    saveBtn.addEventListener('click', saveWorkflowParams);
                }
            }

            const saveModalElement = document.getElementById('workflowSaveModal');
            if (saveModalElement) {
                workflowSaveModal = new bootstrap.Modal(saveModalElement);
                const saveConfirmBtn = document.getElementById('workflowSaveConfirmBtn');
                if (saveConfirmBtn) {
                    saveConfirmBtn.addEventListener('click', saveWorkflowTemplateFromModal);
                }
            }
        }

        function initWorkflowKeyModal() {
            const modalElement = document.getElementById('workflowKeysModal');
            if (modalElement) {
                workflowKeysModal = new bootstrap.Modal(modalElement);
                modalElement.addEventListener('hidden.bs.modal', () => {
                    resetWorkflowKeyModal();
                    pendingWorkflowPayload = null;
                });
                const submitBtn = document.getElementById('workflowKeysSubmitBtn');
                if (submitBtn) {
                    submitBtn.addEventListener('click', saveWorkflowKeys);
                }
            }
        }

        async function loadWorkflowOptions(projectName) {
            const statusText = document.getElementById('workflowStatusText');
            const startButton = document.getElementById('startWorkflowBtn');
            resetWorkflowAutoSave();
            workflowAutoSaveEnabled = false;
            workflowSuppressAutoSave = true;
            try {
                const response = await fetch(`/api/workflow-options/${encodeURIComponent(projectName)}`);
                const result = await response.json();
                if (!response.ok || !result.success) {
                    throw new Error(result.error || 'Ismeretlen hiba');
                }

                availableScripts = result.scripts || [];
                workflowTemplates = result.templates || [];
                const defaults = result.defaults || {};

                const [savedState, defaultTemplateSteps] = await Promise.all([
                    loadProjectWorkflowState(),
                    loadDefaultWorkflowTemplate(workflowTemplates)
                ]);

                if (Array.isArray(defaultTemplateSteps)) {
                    defaultWorkflow = cloneSteps(defaultTemplateSteps);
                } else {
                    defaultWorkflow = cloneSteps(defaults.workflow || []);
                }

                let initialTemplateId = defaults.selected_template || currentTemplateId || (workflowTemplates.length ? workflowTemplates[0].id : null);
                let initialSteps;
                if (savedState && Array.isArray(savedState.steps)) {
                    initialSteps = cloneSteps(savedState.steps);
                    if (Object.prototype.hasOwnProperty.call(savedState, 'template_id')) {
                        initialTemplateId = savedState.template_id;
                    }
                } else {
                    initialSteps = cloneSteps(defaultWorkflow);
                }

                workflowSteps = initialSteps;
                workflowInitialized = true;
                currentTemplateId = initialTemplateId;
                workflowSuppressAutoSave = false;

                populateWorkflowTemplateSelect(currentTemplateId);

                renderWorkflowSteps();
                renderWorkflowStatus(result.latest_job);

                if (result.latest_job && ['queued', 'running', 'cancelling'].includes(result.latest_job.status)) {
                    currentWorkflowJobId = result.latest_job.job_id;
                    startWorkflowPolling(result.latest_job.job_id, true);
                }

                const hasScriptSteps = workflowSteps.some(step => step.type !== 'widget');
                const hasEnabledScripts = workflowSteps.some(step => step.type !== 'widget' && step.enabled !== false);
                const runnableSegment = collectScriptStepsForRun(0);
                if (statusText) {
                    if (!hasScriptSteps) {
                        statusText.textContent = 'Adj hozzá futtatható lépéseket az indításhoz.';
                    } else if (!hasEnabledScripts) {
                        statusText.textContent = 'Engedélyezz legalább egy lépést az indításhoz.';
                    } else if (!runnableSegment.length) {
                        statusText.textContent = 'Az első widget előtt nincs futtatható lépés. Használd a Continue gombot.';
                    } else {
                        statusText.textContent = 'Workflow készen áll az indításra.';
                    }
                }

                if (startButton) {
                    startButton.disabled = !runnableSegment.length;
                }

                workflowLastSavedSnapshot = JSON.stringify(buildWorkflowSnapshot());
                workflowAutoSaveEnabled = true;
            } catch (error) {
                console.error('Hiba a workflow opciók betöltésekor:', error);
                if (statusText) {
                    statusText.textContent = `Hiba: ${error.message}`;
                }
                if (startButton) {
                    startButton.disabled = true;
                }
                updateInfoBox('danger', `Nem sikerült betölteni a workflow opciókat: ${error.message}`);
            } finally {
                workflowSuppressAutoSave = false;
            }
        }

        function renderWorkflowSteps() {
            const tbody = document.getElementById('workflowStepsBody');
            if (!tbody) {
                return;
            }
            tbody.innerHTML = '';
            if (!workflowSteps.length) {
                const row = document.createElement('tr');
                row.className = 'text-muted';
                const cell = document.createElement('td');
                cell.colSpan = 5;
                cell.textContent = 'Még nem adtál hozzá lépéseket.';
                row.append(cell);
                tbody.append(row);
                updateMissingBadge();
                const startButtonEmpty = document.getElementById('startWorkflowBtn');
                if (startButtonEmpty) {
                    startButtonEmpty.disabled = true;
                }
                return;
            }

            workflowSteps.forEach((step, index) => {
                normalizeWorkflowStep(step);
                const isWidget = step.type === 'widget';
                const script = !isWidget ? findScriptById(step.script) : null;
                const widget = isWidget ? findWidgetById(step.widget) : null;
                const row = document.createElement('tr');
                row.classList.add('workflow-row');
                row.dataset.stepIndex = String(index);
                if (isWidget) {
                    row.classList.add('workflow-row-widget');
                }
                if (step.enabled === false) {
                    row.classList.add('workflow-row-disabled', 'text-muted');
                }
                const missing = (!isWidget && step.enabled !== false) ? getMissingParams(step, script) : [];
                if (missing.length) {
                    row.classList.add('workflow-row-missing');
                }

                const enabledCell = document.createElement('td');
                const enabledWrapper = document.createElement('div');
                enabledWrapper.className = 'form-check form-switch';
                const enabledCheckbox = document.createElement('input');
                enabledCheckbox.type = 'checkbox';
                enabledCheckbox.className = 'form-check-input';
                enabledCheckbox.checked = step.enabled !== false;
                enabledCheckbox.addEventListener('change', () => {
                    step.enabled = enabledCheckbox.checked;
                    markWorkflowDirty();
                    renderWorkflowSteps();
                });
                enabledWrapper.append(enabledCheckbox);
                enabledCell.append(enabledWrapper);
                row.append(enabledCell);

                const infoCell = document.createElement('td');
                if (isWidget) {
                    const title = document.createElement('div');
                    title.className = 'fw-semibold';
                    title.textContent = widget ? widget.name : 'Speciális widget';
                    infoCell.append(title);

                    if (widget && widget.description) {
                        const desc = document.createElement('div');
                        desc.className = 'small text-muted';
                        desc.textContent = widget.description;
                        infoCell.append(desc);
                    }

                    const buttonRow = document.createElement('div');
                    buttonRow.className = 'd-flex flex-wrap gap-2 mt-2';

                    const reviewBtn = document.createElement('button');
                    reviewBtn.type = 'button';
                    reviewBtn.className = 'btn btn-sm btn-outline-info';
                    reviewBtn.textContent = widget && widget.reviewLabel ? widget.reviewLabel : 'Review';
                    reviewBtn.disabled = step.enabled === false;
                    reviewBtn.addEventListener('click', () => {
                        const url = `/review/${encodeURIComponent(PROJECT_NAME)}`;
                        window.open(url, '_blank', 'noopener');
                    });

                    const continueBtn = document.createElement('button');
                    continueBtn.type = 'button';
                    continueBtn.className = 'btn btn-sm btn-success';
                    continueBtn.textContent = widget && widget.continueLabel ? widget.continueLabel : 'Continue';
                    const hasRemainingScripts = collectScriptStepsForRun(index + 1).length > 0;
                    continueBtn.disabled = step.enabled === false || !hasRemainingScripts;
                    if (!hasRemainingScripts) {
                        continueBtn.title = 'Nincs további futtatható lépés.';
                    }
                    continueBtn.addEventListener('click', () => handleWidgetContinue(index));

                    buttonRow.append(reviewBtn, continueBtn);
                    infoCell.append(buttonRow);

                    if (widget && Array.isArray(widget.parameters) && widget.parameters.length) {
                        const summary = describeWidgetParameters(widget, step);
                        if (summary) {
                            const summaryDiv = document.createElement('div');
                            summaryDiv.className = 'small text-muted mt-2';
                            summaryDiv.textContent = summary;
                            infoCell.append(summaryDiv);
                        }
                    }
                } else {
                    const titleWrap = document.createElement('div');
                    const titleRow = document.createElement('div');
                    titleRow.className = 'd-flex align-items-center gap-2 flex-wrap';
                    const title = document.createElement('div');
                    title.className = 'fw-semibold mb-0';
                    title.textContent = formatScriptDirectoryName(script, step);
                    titleRow.append(title);
                    if (script && script.api) {
                        const apiBadge = document.createElement('span');
                        apiBadge.className = 'badge bg-warning text-dark script-api-badge';
                        apiBadge.textContent = `${String(script.api).toUpperCase()} API`;
                        titleRow.append(apiBadge);
                    }
                    titleWrap.append(titleRow);

                    if (script && script.description) {
                        const desc = document.createElement('div');
                        desc.className = 'small text-muted';
                        desc.textContent = script.description;
                        titleWrap.append(desc);
                    }

                    infoCell.append(titleWrap);

                    const summary = document.createElement('div');
                    summary.className = 'small mt-1';
                    summary.textContent = describeStepParameters(step, script, missing);
                    infoCell.append(summary);

                    if (script && script.api) {
                        const apiInfoLine = document.createElement('div');
                        apiInfoLine.className = 'small mt-1 script-api-highlight';
                        apiInfoLine.textContent = `API használat: ${String(script.api).toUpperCase()}`;
                        infoCell.append(apiInfoLine);
                    }

                    if (script && script.required_keys && script.required_keys.length) {
                        const keyLine = document.createElement('div');
                        keyLine.className = 'small mt-1';
                        script.required_keys.forEach(key => {
                            const badge = document.createElement('span');
                            badge.className = 'badge bg-secondary me-1';
                            badge.textContent = key;
                            keyLine.append(badge);
                        });
                        infoCell.append(keyLine);
                    }
                }
                row.append(infoCell);

                const envCell = document.createElement('td');
                if (isWidget) {
                    const widgetBadge = document.createElement('span');
                    widgetBadge.className = 'badge workflow-env-badge';
                    widgetBadge.textContent = 'Widget';
                    envCell.append(widgetBadge);
                } else if (script && script.environment) {
                    const envBadge = document.createElement('span');
                    envBadge.className = 'badge workflow-env-badge';
                    envBadge.textContent = script.environment;
                    envCell.append(envBadge);
                } else {
                    envCell.innerHTML = '&mdash;';
                }
                row.append(envCell);

                const haltCell = document.createElement('td');
                if (isWidget) {
                    haltCell.innerHTML = '&mdash;';
                } else {
                    const haltWrapper = document.createElement('div');
                    haltWrapper.className = 'form-check form-switch';
                    const haltCheckbox = document.createElement('input');
                    haltCheckbox.type = 'checkbox';
                    haltCheckbox.className = 'form-check-input';
                    haltCheckbox.checked = step.halt_on_fail !== false;
                    haltCheckbox.addEventListener('change', () => {
                        step.halt_on_fail = haltCheckbox.checked;
                        markWorkflowDirty();
                        renderWorkflowSteps();
                    });
                    const haltLabel = document.createElement('label');
                    haltLabel.className = 'form-check-label small';
                    haltLabel.textContent = haltCheckbox.checked ? 'Megáll hibánál' : 'Tovább hiba után';
                    haltWrapper.append(haltCheckbox, haltLabel);
                    haltCell.append(haltWrapper);
                }
                row.append(haltCell);

                const actionsCell = document.createElement('td');
                actionsCell.className = 'text-end';
                if (!isWidget) {
                    const editBtn = document.createElement('button');
                    editBtn.type = 'button';
                    editBtn.className = 'btn btn-sm btn-outline-primary me-2';
                    editBtn.textContent = 'Paraméterek';
                    editBtn.addEventListener('click', () => openWorkflowParams(index));
                    actionsCell.append(editBtn);
                } else if (widget && Array.isArray(widget.parameters) && widget.parameters.length) {
                    const editBtn = document.createElement('button');
                    editBtn.type = 'button';
                    editBtn.className = 'btn btn-sm btn-outline-primary me-2';
                    editBtn.textContent = 'Paraméterek';
                    editBtn.addEventListener('click', () => openWorkflowWidgetParams(index));
                    actionsCell.append(editBtn);
                }

                const upBtn = document.createElement('button');
                upBtn.type = 'button';
                upBtn.className = 'btn btn-sm btn-outline-secondary me-1';
                upBtn.innerHTML = '&uarr;';
                upBtn.disabled = index === 0;
                upBtn.addEventListener('click', () => moveWorkflowStep(index, -1));

                const downBtn = document.createElement('button');
                downBtn.type = 'button';
                downBtn.className = 'btn btn-sm btn-outline-secondary me-1';
                downBtn.innerHTML = '&darr;';
                downBtn.disabled = index === workflowSteps.length - 1;
                downBtn.addEventListener('click', () => moveWorkflowStep(index, 1));

                const removeBtn = document.createElement('button');
                removeBtn.type = 'button';
                removeBtn.className = 'btn btn-sm btn-outline-danger';
                removeBtn.innerHTML = '&times;';
                removeBtn.addEventListener('click', () => removeWorkflowStep(index));

                actionsCell.append(upBtn, downBtn, removeBtn);
                row.append(actionsCell);

                tbody.append(row);
            });

            if (cycleState) {
                const widgetIndex = cycleState.widgetIndex;
                const currentIteration = cycleState.activeIteration !== null
                    ? cycleState.activeIteration
                    : Math.max(0, cycleState.nextIteration - 1);
                updateCycleDisplay(widgetIndex, currentIteration, cycleState.totalIterations);
            }

            updateMissingBadge();

            const startButton = document.getElementById('startWorkflowBtn');
            if (startButton) {
                const runnableSegment = collectScriptStepsForRun(0);
                startButton.disabled = runnableSegment.length === 0;
            }

            const statusText = document.getElementById('workflowStatusText');
            if (statusText && !currentWorkflowJobId) {
                const hasAnyScript = workflowSteps.some(step => step.type !== 'widget');
                const hasEnabledScripts = workflowSteps.some(step => step.type !== 'widget' && step.enabled !== false);
                const runnableSegment = collectScriptStepsForRun(0);
                if (!hasAnyScript) {
                    statusText.textContent = 'Adj hozzá futtatható lépéseket az indításhoz.';
                } else if (!hasEnabledScripts) {
                    statusText.textContent = 'Engedélyezz legalább egy lépést az indításhoz.';
                } else if (!runnableSegment.length) {
                    statusText.textContent = 'Az első widget előtt nincs futtatható lépés. Használd a Continue gombot.';
                } else {
                    statusText.textContent = 'Workflow készen áll az indításra.';
                }
            }
        }

        function openWorkflowStepPicker() {
            populateWorkflowStepList('');
            if (workflowStepModal) {
                workflowStepModal.show();
            }
        }

        function populateWorkflowStepList(filterText) {
            const list = document.getElementById('workflowStepList');
            if (!list) {
                return;
            }
            list.innerHTML = '';
            const term = (filterText || '').toLowerCase();
            const scripts = availableScripts
                .slice()
                .sort((a, b) => (a.display_name || a.script).localeCompare(b.display_name || b.script));
            const filtered = term
                ? scripts.filter(script =>
                    (script.display_name && script.display_name.toLowerCase().includes(term)) ||
                    (script.script && script.script.toLowerCase().includes(term)))
                : scripts;

            if (!filtered.length) {
                const empty = document.createElement('div');
                empty.className = 'list-group-item text-muted';
                empty.textContent = 'Nincs a keresésnek megfelelő szkript.';
                list.append(empty);
                return;
            }

            const normalizeScriptPath = (path) => (path || '').replace(/\\/g, '/');

            const createScriptListItem = (script) => {
                const item = document.createElement('div');
                item.className = 'list-group-item ps-4';
                const header = document.createElement('div');
                header.className = 'd-flex justify-content-between align-items-start gap-3';

                const titleWrap = document.createElement('div');
                const titleRow = document.createElement('div');
                titleRow.className = 'd-flex align-items-center gap-2 flex-wrap';
                const title = document.createElement('div');
                title.className = 'fw-semibold';
                title.textContent = script.display_name || script.script;
                titleRow.append(title);
                if (script.api) {
                    const apiBadge = document.createElement('span');
                    apiBadge.className = 'badge bg-warning text-dark script-api-badge';
                    apiBadge.textContent = `${String(script.api).toUpperCase()} API`;
                    titleRow.append(apiBadge);
                }
                titleWrap.append(titleRow);
                const subtitle = document.createElement('div');
                subtitle.className = 'small text-muted';
                subtitle.textContent = script.description || script.script;
                titleWrap.append(subtitle);

                if (script.description && script.script && script.description !== script.script) {
                    const pathInfo = document.createElement('div');
                    pathInfo.className = 'small text-muted';
                    pathInfo.textContent = script.script;
                    titleWrap.append(pathInfo);
                }

                const addBtn = document.createElement('button');
                addBtn.type = 'button';
                addBtn.className = 'btn btn-sm btn-primary';
                addBtn.textContent = 'Hozzáadás';
                addBtn.addEventListener('click', () => {
                    addWorkflowStep(script.id);
                    if (workflowStepModal) {
                        workflowStepModal.hide();
                    }
                });

                header.append(titleWrap, addBtn);
                item.append(header);

                if (script.environment) {
                    const envInfo = document.createElement('div');
                    envInfo.className = 'small mt-1';
                    envInfo.innerHTML = `<strong>Környezet:</strong> ${script.environment}`;
                    item.append(envInfo);
                }

                if (script.api) {
                    const apiInfo = document.createElement('div');
                    apiInfo.className = 'small mt-1 script-api-highlight';
                    apiInfo.innerHTML = `<strong>API:</strong> ${String(script.api).toUpperCase()}`;
                    item.append(apiInfo);
                }

                const requiredParams = (script.parameters || []).filter(param => param.required && !param.autofill);
                if (requiredParams.length) {
                    const reqInfo = document.createElement('div');
                    reqInfo.className = 'small mt-1';
                    reqInfo.innerHTML = `<strong>Kötelező paraméterek:</strong> ${requiredParams.map(param => param.name).join(', ')}`;
                    item.append(reqInfo);
                }

                if (script.required_keys && script.required_keys.length) {
                    const keyInfo = document.createElement('div');
                    keyInfo.className = 'small mt-1';
                    keyInfo.innerHTML = `<strong>Szükséges kulcsok:</strong> ${script.required_keys.join(', ')}`;
                    item.append(keyInfo);
                }

                if (script.notes) {
                    const notes = document.createElement('div');
                    notes.className = 'small mt-2 text-muted';
                    notes.textContent = script.notes;
                    item.append(notes);
                }

                return item;
            };

            const groupMap = new Map();
            filtered.forEach(script => {
                const normalizedPath = normalizeScriptPath(script.script);
                const lastSlashIndex = normalizedPath.lastIndexOf('/');
                const groupKey = lastSlashIndex > -1 ? normalizedPath.slice(0, lastSlashIndex) : '';
                if (!groupMap.has(groupKey)) {
                    groupMap.set(groupKey, []);
                }
                groupMap.get(groupKey).push(script);
            });

            const compareGroupNames = (a, b) => {
                if (a === b) {
                    return 0;
                }
                if (!a) {
                    return -1;
                }
                if (!b) {
                    return 1;
                }
                return a.localeCompare(b);
            };

            const groupedEntries = Array.from(groupMap.entries()).sort((entryA, entryB) => compareGroupNames(entryA[0], entryB[0]));

            groupedEntries.forEach(([groupName, scriptsInGroup]) => {
                const header = document.createElement('div');
                header.className = 'list-group-item list-group-item-secondary fw-semibold';
                header.textContent = groupName ? groupName : 'scripts/ (gyökér)';
                list.append(header);

                scriptsInGroup.forEach(script => {
                    list.append(createScriptListItem(script));
                });
            });
        }

        function addWorkflowStep(scriptId, insertIndex = workflowSteps.length) {
            const script = findScriptById(scriptId);
            if (!script) {
                alert(`Ismeretlen szkript: ${scriptId}`);
                return;
            }
            const currentMatch = workflowSteps.find(step => step && step.type !== 'widget' && step.script === script.id);
            const template = currentMatch || (defaultWorkflow || []).find(step => step.script === script.id);
            const newStep = {
                script: script.id,
                enabled: true,
                halt_on_fail: template ? (template.halt_on_fail !== undefined ? template.halt_on_fail : true) : true,
                params: template ? cloneObject(template.params) : {}
            };
            let targetIndex = parseInt(insertIndex, 10);
            if (Number.isNaN(targetIndex)) {
                targetIndex = workflowSteps.length;
            }
            targetIndex = Math.max(0, Math.min(targetIndex, workflowSteps.length));
            workflowSteps.splice(targetIndex, 0, newStep);
            markWorkflowDirty();
            renderWorkflowSteps();
            updateInfoBox('secondary', `${script.display_name || script.script} hozzáadva a workflow-hoz.`);
        }

        function addWorkflowWidget(widgetId, insertIndex = workflowSteps.length) {
            const widget = findWidgetById(widgetId);
            if (!widget) {
                alert(`Ismeretlen widget: ${widgetId}`);
                return;
            }
            const defaultParams = {};
            if (Array.isArray(widget.parameters)) {
                widget.parameters.forEach(param => {
                    if (param && param.name && param.default !== undefined) {
                        defaultParams[param.name] = param.default;
                    }
                });
            }
            const newStep = {
                type: 'widget',
                widget: widget.id,
                enabled: true,
                params: defaultParams
            };
            let targetIndex = parseInt(insertIndex, 10);
            if (Number.isNaN(targetIndex)) {
                targetIndex = workflowSteps.length;
            }
            targetIndex = Math.max(0, Math.min(targetIndex, workflowSteps.length));
            workflowSteps.splice(targetIndex, 0, newStep);
            markWorkflowDirty();
            renderWorkflowSteps();
            updateInfoBox('secondary', `${widget.name} widget hozzáadva a workflow-hoz.`);
        }

        async function handleWidgetContinue(widgetIndex) {
            if (currentWorkflowJobId) {
                updateInfoBox('warning', 'Már fut egy workflow. Várj a befejezésig.');
                return;
            }
            const widgetStep = workflowSteps[widgetIndex];
            if (!widgetStep || widgetStep.type !== 'widget') {
                return;
            }
            if (widgetStep.enabled === false) {
                updateInfoBox('info', 'Ez a widget le van tiltva.');
                return;
            }
            const widget = findWidgetById(widgetStep.widget);
            if (widget && widget.id === 'cycleWidget') {
                await startCycleSequence(widgetIndex, { auto: false });
                return;
            }
            const validation = validateWorkflowSegment(widgetIndex + 1);
            if (!validation.hasRunnableStep) {
                updateInfoBox('info', 'Nincs további futtatható lépés.');
                return;
            }
            if (!validation.valid) {
                const messages = [...validation.errors];
                validation.missingSummary.forEach(item => {
                    messages.push(`${item.script.display_name || item.script.script}: hiányzó paraméterek – ${item.missing.join(', ')}`);
                });
                updateInfoBox('warning', messages.join(' | '));
                updateMissingBadge();
                return;
            }

            const segment = collectWorkflowSegment(widgetIndex + 1);
            if (!segment.steps.length) {
                updateInfoBox('info', 'Nincs további futtatható lépés.');
                return;
            }
            const payload = buildRunPayload(widgetIndex + 1, segment);
            const context = {
                type: 'segment',
                startIndex: widgetIndex + 1,
                widgetIndex: segment.widgetIndex
            };

            try {
                const ready = await ensureWorkflowKeys(payload, context);
                if (!ready) {
                    return;
                }
                await executeWorkflow(payload, context);
            } catch (error) {
                console.error('Widget folytatási hiba:', error);
                alert('Nem sikerült folytatni a workflow-t: ' + error.message);
            }
        }

        function moveWorkflowStep(index, delta) {
            const newIndex = index + delta;
            if (newIndex < 0 || newIndex >= workflowSteps.length) {
                return;
            }
            const [step] = workflowSteps.splice(index, 1);
            workflowSteps.splice(newIndex, 0, step);
            markWorkflowDirty();
            renderWorkflowSteps();
        }

        function removeWorkflowStep(index) {
            const [removed] = workflowSteps.splice(index, 1);
            markWorkflowDirty();
            renderWorkflowSteps();
            if (removed) {
                let label = removed.script;
                if (removed.type === 'widget') {
                    const widget = findWidgetById(removed.widget);
                    label = widget ? widget.name : 'Widget';
                }
                updateInfoBox('secondary', `${label} eltávolítva a workflow-ból.`);
            }
        }

        function openWorkflowParams(index) {
            const step = workflowSteps[index];
            if (!step) {
                return;
            }
            if (step.type === 'widget') {
                return;
            }
            const script = findScriptById(step.script);
            if (!script) {
                alert(`Ismeretlen szkript: ${step.script}`);
                return;
            }
            selectedStepIndex = index;
            selectedStepType = 'script';
            selectedWidgetConfig = null;
            const titleEl = document.getElementById('workflowParamsTitle');
            if (titleEl) {
                titleEl.textContent = `${script.display_name || script.script} – paraméterek`;
            }
            renderWorkflowParamsForm(script, step);
            if (workflowParamsModal) {
                workflowParamsModal.show();
            }
        }

        function openWorkflowWidgetParams(index) {
            const step = workflowSteps[index];
            if (!step || step.type !== 'widget') {
                return;
            }
            const widget = findWidgetById(step.widget);
            if (!widget) {
                alert(`Ismeretlen widget: ${step.widget}`);
                return;
            }
            selectedStepIndex = index;
            selectedStepType = 'widget';
            selectedWidgetConfig = widget;
            const titleEl = document.getElementById('workflowParamsTitle');
            if (titleEl) {
                titleEl.textContent = `${widget.name} – beállítások`;
            }
            renderWidgetParamsForm(widget, step);
            if (workflowParamsModal) {
                workflowParamsModal.show();
            }
        }

        function updateWorkflowParamsHelp(source) {
            const helpBox = document.getElementById('workflowParamsHelp');
            if (!helpBox) {
                return;
            }
            let helpText = '';
            let isMarkdown = false;
            if (source && typeof source.help_markdown === 'string') {
                helpText = source.help_markdown.trim();
                isMarkdown = true;
            } else if (source && typeof source.help === 'string') {
                helpText = source.help.trim();
            }
            if (!helpText) {
                helpBox.classList.add('d-none');
                helpBox.innerHTML = '';
                return;
            }
            helpBox.classList.remove('d-none');
            helpBox.innerHTML = '';
            const title = document.createElement('h6');
            title.className = 'mb-2';
            title.textContent = 'Segédlet';
            const block = document.createElement('div');
            block.className = 'small bg-body-tertiary p-3 border rounded';
            if (isMarkdown) {
                let renderedHtml = '';
                const markedRef = window.marked;
                if (markedRef) {
                    if (typeof markedRef === 'function') {
                        try {
                            renderedHtml = markedRef(helpText);
                        } catch (err) {
                            console.warn('Markdown render hiba (function):', err);
                        }
                    } else if (typeof markedRef.parse === 'function') {
                        try {
                            renderedHtml = markedRef.parse(helpText);
                        } catch (err) {
                            console.warn('Markdown render hiba (parse):', err);
                        }
                    }
                }
                if (renderedHtml) {
                    block.classList.add('markdown-content');
                    block.innerHTML = renderedHtml;
                } else {
                    block.style.whiteSpace = 'pre-wrap';
                    block.style.fontFamily = 'var(--bs-body-font-family, inherit)';
                    block.textContent = helpText;
                }
            } else {
                block.style.whiteSpace = 'pre-wrap';
                block.style.fontFamily = 'var(--bs-body-font-family, inherit)';
                block.textContent = helpText;
            }
            helpBox.append(title, block);
        }

        function renderWorkflowParamsForm(script, step) {
            const container = document.getElementById('workflowParamsContainer');
            const alertBox = document.getElementById('workflowParamsAlert');
            if (alertBox) {
                alertBox.classList.add('d-none');
                alertBox.textContent = '';
            }
            if (!container) {
                updateWorkflowParamsHelp(script);
                return;
            }
            container.innerHTML = '';
            const params = script.parameters || [];
            const scriptDefaults = getScriptParamDefaults(script);
            if (!params.length) {
                const placeholder = document.createElement('div');
                placeholder.className = 'text-muted';
                placeholder.textContent = 'Ehhez a lépéshez nem szükséges beállítás.';
                container.append(placeholder);
                updateWorkflowParamsHelp(script);
                return;
            }
            params.forEach(param => {
                const group = document.createElement('div');
                const rawValue = step.params ? step.params[param.name] : undefined;
                const hasExplicitDefault = param && Object.prototype.hasOwnProperty.call(param, 'default');
                let defaultValue = hasExplicitDefault ? param.default : undefined;
                if ((defaultValue === undefined || defaultValue === null) && scriptDefaults.has(param.name)) {
                    defaultValue = scriptDefaults.get(param.name);
                }
                const hasDefault = defaultValue !== undefined && defaultValue !== null && !(typeof defaultValue === 'string' && defaultValue.trim() === '');
                const defaultString = hasDefault ? String(defaultValue) : '';
                if (param.autofill) {
                    group.className = 'border rounded p-2 bg-body-tertiary';
                    const label = document.createElement('div');
                    label.className = 'fw-semibold';
                    label.textContent = param.name;
                    const help = document.createElement('div');
                    help.className = 'small text-muted';
                    help.textContent = param.autofill === 'project_name'
                        ? 'Automatikus érték: projektnév'
                        : 'Automatikus érték: projekt könyvtár teljes elérési útja';
                    group.append(label, help);
                    container.append(group);
                    return;
                }

                if (param.type === 'flag') {
                    group.className = 'form-check form-switch';
                    const input = document.createElement('input');
                    input.type = 'checkbox';
                    input.className = 'form-check-input';
                    input.id = `workflow-param-${param.name}`;
                    input.dataset.param = param.name;
                    input.dataset.type = param.type;
                    const normalizeFlag = value => {
                        if (value === undefined || value === null) {
                            return undefined;
                        }
                        if (typeof value === 'string') {
                            const trimmed = value.trim().toLowerCase();
                            if (trimmed === 'true') {
                                return true;
                            }
                            if (trimmed === 'false') {
                                return false;
                            }
                            if (trimmed === '1') {
                                return true;
                            }
                            if (trimmed === '0') {
                                return false;
                            }
                            return trimmed.length > 0;
                        }
                        return Boolean(value);
                    };
                    const normalizedRaw = normalizeFlag(rawValue);
                    const defaultFlag = hasDefault ? normalizeFlag(defaultValue) : undefined;
                    if (normalizedRaw !== undefined) {
                        input.checked = normalizedRaw;
                    } else {
                        input.checked = false;
                    }
                    if (defaultFlag === undefined) {
                        input.dataset.defaultValue = 'none';
                    } else {
                        input.dataset.defaultValue = defaultFlag ? 'true' : 'false';
                    }
                    const label = document.createElement('label');
                    label.className = 'form-check-label';
                    label.setAttribute('for', input.id);
                    label.textContent = param.name;
                    group.append(input, label);
                    if (defaultFlag !== undefined) {
                        const defaultInfo = document.createElement('div');
                        defaultInfo.className = 'form-text';
                        defaultInfo.textContent = `Alapértelmezett: ${defaultFlag ? 'bekapcsolva' : 'kikapcsolva'}`;
                        group.append(defaultInfo);
                    }
                } else {
                    group.className = 'form-group';
                    const label = document.createElement('label');
                    label.className = 'form-label fw-semibold';
                    label.setAttribute('for', `workflow-param-${param.name}`);
                    label.textContent = param.name + (param.required ? ' *' : '');
                    group.append(label);
                    const input = document.createElement('input');
                    input.className = 'form-control';
                    input.id = `workflow-param-${param.name}`;
                    input.dataset.param = param.name;
                    input.dataset.type = param.type;
                    let helper = null;
                    let clearBtn = null;
                    if (param.secret) {
                        const storedValue = rawValue !== undefined && rawValue !== null ? String(rawValue) : '';
                        const hasExisting = storedValue.trim() !== '';
                        input.type = 'password';
                        input.autocomplete = 'off';
                        input.dataset.secret = 'true';
                        input.dataset.cleared = 'false';
                        input.dataset.hasExisting = hasExisting ? 'true' : 'false';
                        if (hasExisting) {
                            input.placeholder = '••••••';
                            input.dataset.original = storedValue;
                        } else {
                            input.placeholder = 'API kulcs';
                        }
                        input.value = '';
                        helper = document.createElement('div');
                        helper.className = 'form-text';
                        helper.textContent = hasExisting
                            ? 'Kulcs jelenleg el van mentve. Hagyd üresen, ha nem módosítod.'
                            : 'Adja meg az API kulcsot.';
                        if (hasExisting) {
                            clearBtn = document.createElement('button');
                            clearBtn.type = 'button';
                            clearBtn.className = 'btn btn-sm btn-outline-danger mt-2';
                            clearBtn.textContent = 'Kulcs törlése';
                            clearBtn.addEventListener('click', () => {
                                input.value = '';
                                input.placeholder = 'Kulcs törlésre jelölve';
                                input.dataset.cleared = 'true';
                                input.dataset.original = '';
                                input.dataset.hasExisting = 'false';
                                helper.textContent = 'Kulcs törlésre kerül mentéskor.';
                            });
                        }
                        input.addEventListener('input', () => {
                            const trimmed = input.value.trim();
                            if (trimmed.length === 0) {
                                if (input.dataset.cleared === 'true') {
                                    helper.textContent = 'Kulcs törlésre kerül mentéskor.';
                                } else if (input.dataset.hasExisting === 'true') {
                                    helper.textContent = 'Kulcs jelenleg el van mentve. Hagyd üresen, ha nem módosítod.';
                                } else {
                                    helper.textContent = 'Adja meg az API kulcsot.';
                                }
                            } else {
                                input.dataset.cleared = 'false';
                                helper.textContent = 'Új kulcs kerül mentésre.';
                            }
                        });
                    } else {
                        input.type = 'text';
                        if (rawValue !== undefined && rawValue !== null) {
                            input.value = String(rawValue);
                        } else {
                            input.value = '';
                            if (hasDefault) {
                                input.placeholder = defaultString;
                            }
                        }
                    }
                    group.append(input);
                    if (helper) {
                        group.append(helper);
                    }
                    if (clearBtn) {
                        group.append(clearBtn);
                    }
                }

                if (param.flags && param.flags.length) {
                    const flagInfo = document.createElement('div');
                    flagInfo.className = 'form-text';
                    flagInfo.textContent = `Kapcsolók: ${param.flags.join(', ')}`;
                    group.append(flagInfo);
                }

                container.append(group);
            });
            updateWorkflowParamsHelp(script);
        }

        function renderWidgetParamsForm(widget, step) {
            const container = document.getElementById('workflowParamsContainer');
            const alertBox = document.getElementById('workflowParamsAlert');
            if (alertBox) {
                alertBox.classList.add('d-none');
                alertBox.textContent = '';
            }
            if (!container) {
                updateWorkflowParamsHelp(widget);
                return;
            }
            container.innerHTML = '';
            const parameters = Array.isArray(widget && widget.parameters) ? widget.parameters : [];
            if (!parameters.length) {
                const placeholder = document.createElement('div');
                placeholder.className = 'text-muted';
                placeholder.textContent = 'Ehhez a widgethez nem szükséges beállítás.';
                container.append(placeholder);
                updateWorkflowParamsHelp(widget);
                return;
            }
            parameters.forEach(param => {
                if (!param || !param.name) {
                    return;
                }
                const group = document.createElement('div');
                group.className = 'mb-3';
                const label = document.createElement('label');
                label.className = 'form-label';
                label.setAttribute('for', `widgetParam_${param.name}`);
                label.textContent = param.label || param.name;
                group.append(label);

                const input = document.createElement('input');
                input.id = `widgetParam_${param.name}`;
                input.className = 'form-control';
                input.dataset.param = param.name;
                input.dataset.type = param.type || 'text';
                input.dataset.widget = 'true';
                if (param.type === 'number') {
                    input.type = 'number';
                    if (param.min !== undefined) {
                        input.min = String(param.min);
                    }
                    if (param.max !== undefined) {
                        input.max = String(param.max);
                    }
                    if (param.step !== undefined) {
                        input.step = String(param.step);
                    } else {
                        input.step = '1';
                    }
                } else {
                    input.type = 'text';
                }
                if (param.required) {
                    input.required = true;
                }
                const params = step && step.params ? step.params : {};
                const hasOwnValue = Object.prototype.hasOwnProperty.call(params, param.name);
                const value = hasOwnValue ? params[param.name] : param.default;
                if (value !== undefined && value !== null) {
                    input.value = String(value);
                } else {
                    input.value = '';
                }
                group.append(input);
                if (param.helper) {
                    const helper = document.createElement('div');
                    helper.className = 'form-text';
                    helper.textContent = param.helper;
                    group.append(helper);
                }
                container.append(group);
            });
            updateWorkflowParamsHelp(widget);
        }

        function saveWorkflowParams() {
            if (selectedStepIndex === null) {
                return;
            }
            const step = workflowSteps[selectedStepIndex];
            if (!step) {
                return;
            }
            if (selectedStepType === 'widget') {
                saveWidgetParams(step, selectedWidgetConfig || findWidgetById(step.widget));
                return;
            }
            if (step.type === 'widget') {
                return;
            }
            const script = findScriptById(step.script);
            if (!script) {
                return;
            }
            const container = document.getElementById('workflowParamsContainer');
            const alertBox = document.getElementById('workflowParamsAlert');
            if (!container) {
                return;
            }
            const inputs = container.querySelectorAll('[data-param]');
            const newParams = cloneObject(step.params);
            inputs.forEach(input => {
                const name = input.dataset.param;
                const type = input.dataset.type;
                if (type === 'flag') {
                    const defaultAttr = input.dataset.defaultValue || 'none';
                    let defaultValue;
                    if (defaultAttr === 'true') {
                        defaultValue = true;
                    } else if (defaultAttr === 'false') {
                        defaultValue = false;
                    } else {
                        defaultValue = undefined;
                    }
                    const checked = input.checked;
                    if (defaultValue !== undefined && checked === defaultValue) {
                        delete newParams[name];
                    } else {
                        newParams[name] = checked;
                    }
                } else {
                    const isSecret = input.dataset.secret === 'true';
                    const rawValue = input.value;
                    const trimmedValue = rawValue.trim();
                    if (isSecret) {
                        const cleared = input.dataset.cleared === 'true';
                        const hasExisting = input.dataset.hasExisting === 'true';
                        const originalValue = input.dataset.original || '';
                        if (cleared) {
                            delete newParams[name];
                        } else if (trimmedValue === '') {
                            if (hasExisting && originalValue) {
                                newParams[name] = originalValue;
                            } else {
                                delete newParams[name];
                            }
                        } else {
                            newParams[name] = trimmedValue;
                        }
                    } else {
                        if (trimmedValue === '') {
                            delete newParams[name];
                        } else {
                            newParams[name] = trimmedValue;
                        }
                    }
                }
            });

            const missing = getMissingParams({ ...step, params: newParams }, script);
            if (missing.length && alertBox) {
                alertBox.textContent = `Hiányzó kötelező mezők: ${missing.join(', ')}`;
                alertBox.classList.remove('d-none');
                return;
            }

            step.params = newParams;
            markWorkflowDirty();
            if (workflowParamsModal) {
                workflowParamsModal.hide();
            }
            renderWorkflowSteps();
        }

        function saveWidgetParams(step, widget) {
            const container = document.getElementById('workflowParamsContainer');
            const alertBox = document.getElementById('workflowParamsAlert');
            if (!container) {
                return;
            }
            const parameters = Array.isArray(widget && widget.parameters) ? widget.parameters : [];
            if (!parameters.length) {
                step.params = {};
                markWorkflowDirty();
                if (workflowParamsModal) {
                    workflowParamsModal.hide();
                }
                renderWorkflowSteps();
                return;
            }
            const newParams = {};
            const errors = [];
            parameters.forEach(param => {
                if (!param || !param.name) {
                    return;
                }
                const input = container.querySelector(`[data-param="${param.name}"]`);
                if (!input) {
                    return;
                }
                const rawValue = input.value ?? '';
                const trimmed = rawValue.trim();
                if (!trimmed) {
                    if (param.required) {
                        errors.push(param.label || param.name);
                        return;
                    }
                    if (param.default !== undefined) {
                        newParams[param.name] = param.default;
                    }
                    return;
                }
                if ((param.type || 'text') === 'number') {
                    if (!/^[-+]?\d+$/.test(trimmed)) {
                        errors.push(`${param.label || param.name} (érvénytelen szám)`);
                        return;
                    }
                    const numericValue = Number.parseInt(trimmed, 10);
                    if (param.min !== undefined && numericValue < param.min) {
                        errors.push(`${param.label || param.name} (min. ${param.min})`);
                        return;
                    }
                    if (param.max !== undefined && numericValue > param.max) {
                        errors.push(`${param.label || param.name} (max. ${param.max})`);
                        return;
                    }
                    newParams[param.name] = numericValue;
                } else {
                    newParams[param.name] = trimmed;
                }
            });
            if (errors.length) {
                if (alertBox) {
                    alertBox.textContent = `Ellenőrizd a következő mezőket: ${errors.join(', ')}`;
                    alertBox.classList.remove('d-none');
                }
                return;
            }
            step.params = newParams;
            markWorkflowDirty();
            if (workflowParamsModal) {
                workflowParamsModal.hide();
            }
            renderWorkflowSteps();
        }

        function validateWorkflowSegment(startIndex = 0) {
            const stepsToValidate = [];
            for (let i = startIndex; i < workflowSteps.length; i++) {
                const step = workflowSteps[i];
                if (step.type === 'widget') {
                    if (step.enabled !== false) {
                        break;
                    }
                    continue;
                }
                if (step.enabled === false) {
                    continue;
                }
                stepsToValidate.push(step);
            }
            return validateStepCollection(stepsToValidate);
        }

        async function startSegmentRun(startIndex = 0) {
            const segment = collectWorkflowSegment(startIndex);
            if (!segment.steps.length) {
                updateInfoBox('info', startIndex === 0
                    ? 'Nincs futtatható lépés az első widget előtt. Használd a Continue gombot.'
                    : 'Nincs további futtatható lépés a workflow-ban.');
                return false;
            }
            const payload = buildRunPayload(startIndex, segment);
            const context = {
                type: 'segment',
                startIndex,
                widgetIndex: segment.widgetIndex
            };
            try {
                const ready = await ensureWorkflowKeys(payload, context);
                if (!ready) {
                    return false;
                }
                await executeWorkflow(payload, context);
                return true;
            } catch (error) {
                console.error('Workflow indítási hiba:', error);
                alert('Workflow indítása sikertelen: ' + error.message);
                return false;
            }
        }

        function updateCycleDisplay(widgetIndex, iteration, total) {
            const row = document.querySelector(`tr[data-step-index="${widgetIndex}"]`);
            if (!row) {
                return;
            }
            const infoCell = row.querySelector('td:nth-child(2)');
            if (!infoCell) {
                return;
            }
            let display = infoCell.querySelector('.cycle-counter-display');
            if (!display) {
                display = document.createElement('div');
                display.className = 'cycle-counter-display';
                infoCell.append(display);
            }
            const safeIteration = Math.max(0, iteration);
            display.textContent = safeIteration === 0
                ? 'Ciklus előkészítése...'
                : `Ciklus: ${safeIteration}/${total}`;
        }

        function clearCycleDisplay(widgetIndex) {
            const row = document.querySelector(`tr[data-step-index="${widgetIndex}"]`);
            if (!row) {
                return;
            }
            const infoCell = row.querySelector('td:nth-child(2)');
            if (!infoCell) {
                return;
            }
            const display = infoCell.querySelector('.cycle-counter-display');
            if (display) {
                display.remove();
            }
        }

        function prepareCycleState(widgetIndex) {
            const widgetStep = workflowSteps[widgetIndex];
            if (!widgetStep || widgetStep.type !== 'widget') {
                return null;
            }
            const widget = findWidgetById(widgetStep.widget);
            if (!widget || widget.id !== 'cycleWidget') {
                return null;
            }
            const params = widgetStep.params || {};
            const repeatRaw = params.repeat_count;
            const stepBackRaw = params.step_back;
            const repeatCount = Number.parseInt(String(repeatRaw ?? ''), 10);
            const stepBackCount = Number.parseInt(String(stepBackRaw ?? ''), 10);
            if (!Number.isInteger(repeatCount) || repeatCount < 1) {
                updateInfoBox('warning', 'A ciklus ismétlésszámának legalább 1-nek kell lennie.');
                return null;
            }
            if (!Number.isInteger(stepBackCount) || stepBackCount < 1) {
                updateInfoBox('warning', 'A ciklus visszalépési értékének legalább 1-nek kell lennie.');
                return null;
            }
            const {
                steps: cycleSteps,
                collectedCount
            } = collectScriptStepsBefore(widgetIndex, stepBackCount);
            if (!cycleSteps.length) {
                updateInfoBox('info', 'Nincs futtatható lépés a widget előtt a ciklushoz.');
                return null;
            }
            if (collectedCount < stepBackCount) {
                updateInfoBox('warning', 'Nincs elegendő aktív lépés a widget előtt a megadott ciklushoz.');
                return null;
            }
            const validation = validateStepCollection(cycleSteps);
            if (!validation.hasRunnableStep) {
                updateInfoBox('info', 'Nincs futtatható lépés a widget előtt a ciklushoz.');
                return null;
            }
            if (!validation.valid) {
                const messages = [...validation.errors];
                validation.missingSummary.forEach(item => {
                    messages.push(`${item.script.display_name || item.script.script}: hiányzó paraméterek – ${item.missing.join(', ')}`);
                });
                updateInfoBox('warning', messages.join(' | '));
                updateMissingBadge();
                return null;
            }
            const runSteps = cycleSteps.map(step => buildRunStepFromWorkflowStep(step));
            return {
                widgetStep,
                widget,
                repeatCount,
                stepBackCount,
                runSteps
            };
        }

        async function startCycleSequence(widgetIndex, { auto = false } = {}) {
            if (cycleState) {
                return;
            }
            const state = prepareCycleState(widgetIndex);
            if (!state) {
                return;
            }
            cycleState = {
                widgetIndex,
                totalIterations: state.repeatCount,
                nextIteration: 1,
                runSteps: state.runSteps,
                stepBackCount: state.stepBackCount,
                autoTriggered: auto,
                active: false,
                activeIteration: null
            };
            updateCycleDisplay(widgetIndex, 0, state.repeatCount);
            updateInfoBox('secondary', `Ciklus indítása ${state.repeatCount} ismétléssel.`);
            try {
                await launchNextCycleIteration();
            } catch (error) {
                console.error('Ciklus indítási hiba:', error);
                updateInfoBox('danger', 'Nem sikerült elindítani a ciklust: ' + error.message);
                clearCycleDisplay(widgetIndex);
                cycleState = null;
            }
        }

        async function startCycleIterationExecution(payload, context) {
            if (!cycleState || cycleState.widgetIndex !== context.widgetIndex) {
                await executeWorkflow(payload, context);
                return;
            }
            cycleState.active = true;
            cycleState.activeIteration = context.iteration;
            updateCycleDisplay(context.widgetIndex, context.iteration, context.totalIterations);
            try {
                await executeWorkflow(payload, context);
                cycleState.nextIteration = Math.max(cycleState.nextIteration, context.iteration + 1);
            } catch (error) {
                cycleState.active = false;
                cycleState.activeIteration = null;
                throw error;
            }
        }

        async function launchNextCycleIteration() {
            if (!cycleState) {
                return;
            }
            if (cycleState.active) {
                return;
            }
            if (cycleState.nextIteration > cycleState.totalIterations) {
                finalizeCycleSequence(true);
                return;
            }
            const iteration = cycleState.nextIteration;
            const payload = {
                steps: cycleState.runSteps.map(step => ({
                    script: step.script,
                    enabled: true,
                    halt_on_fail: step.halt_on_fail !== false,
                    params: cloneObject(step.params)
                })),
                template_id: currentTemplateId,
                workflow_state: collectWorkflowState()
            };
            const context = {
                type: 'cycle',
                widgetIndex: cycleState.widgetIndex,
                iteration,
                totalIterations: cycleState.totalIterations
            };
            const ready = await ensureWorkflowKeys(payload, context);
            if (!ready) {
                return;
            }
            await startCycleIterationExecution(payload, context);
        }

        function finalizeCycleSequence(success) {
            if (!cycleState) {
                return;
            }
            const widgetIndex = cycleState.widgetIndex;
            clearCycleDisplay(widgetIndex);
            cycleState = null;
            if (success) {
                updateInfoBox('success', 'Ciklus futása befejeződött. Folytatás a következő lépésekkel.');
                setTimeout(() => {
                    startSegmentRun(widgetIndex + 1);
                }, 0);
            } else {
                updateInfoBox('danger', 'A ciklus futása megszakadt.');
            }
        }

        function autoTriggerWidget(widgetIndex) {
            const widgetStep = workflowSteps[widgetIndex];
            if (!widgetStep || widgetStep.type !== 'widget') {
                return;
            }
            const widget = findWidgetById(widgetStep.widget);
            if (!widget || widgetStep.enabled === false) {
                return;
            }
            if (widget.id === 'cycleWidget') {
                startCycleSequence(widgetIndex, { auto: true }).catch(error => {
                    console.error('Automatikus ciklus hiba:', error);
                });
            } else {
                updateInfoBox('info', `${widget.name} widgethez értünk. Használd a Continue gombot a folytatáshoz.`);
            }
        }

        function handleRunContextJobUpdate(job) {
            if (!job || !currentRunContext || currentRunContext.jobId !== job.job_id) {
                return;
            }
            if (currentRunContext.completionHandled) {
                return;
            }
            if (job.status === 'completed') {
                currentRunContext.completionHandled = true;
                if (currentRunContext.type === 'segment') {
                    const context = currentRunContext;
                    currentRunContext = null;
                    if (context.widgetIndex !== null && context.widgetIndex !== undefined) {
                        autoTriggerWidget(context.widgetIndex);
                    } else {
                        updateInfoBox('success', 'A workflow szakasz sikeresen lefutott.');
                    }
                } else if (currentRunContext.type === 'cycle') {
                    currentRunContext.completionHandled = true;
                    currentRunContext = null;
                    if (cycleState) {
                        cycleState.active = false;
                        cycleState.activeIteration = null;
                        setTimeout(() => {
                            launchNextCycleIteration().catch(error => {
                                console.error('Ciklus folytatás hiba:', error);
                                updateInfoBox('danger', 'Nem sikerült a ciklus következő futásának indítása.');
                                finalizeCycleSequence(false);
                            });
                        }, 0);
                    }
                } else {
                    currentRunContext = null;
                }
            } else if (job.status === 'failed' || job.status === 'cancelled') {
                currentRunContext.completionHandled = true;
                if (cycleState) {
                    cycleState.active = false;
                    cycleState.activeIteration = null;
                    finalizeCycleSequence(false);
                }
                currentRunContext = null;
            }
        }

        async function handleStartWorkflow() {
            const validation = validateWorkflowSegment(0);
            if (!validation.hasRunnableStep) {
                updateInfoBox('info', 'Nincs futtatható lépés az első widget előtt. Használd a Continue gombot a folytatáshoz.');
                return;
            }
            if (!validation.valid) {
                const messages = [...validation.errors];
                if (validation.missingSummary.length) {
                    validation.missingSummary.forEach(item => {
                        const script = item.script;
                        messages.push(`${script.display_name || script.script}: hiányzó paraméterek – ${item.missing.join(', ')}`);
                    });
                }
                updateInfoBox('warning', messages.join(' | '));
                updateMissingBadge();
                return;
            }

            const segment = collectWorkflowSegment(0);
            if (!segment.steps.length) {
                updateInfoBox('info', 'Nincs futtatható lépés az első widget előtt. Használd a Continue gombot a folytatáshoz.');
                return;
            }
            const payload = buildRunPayload(0, segment);
            const context = {
                type: 'segment',
                startIndex: 0,
                widgetIndex: segment.widgetIndex
            };
            try {
                const ready = await ensureWorkflowKeys(payload, context);
                if (!ready) {
                    return;
                }
                await executeWorkflow(payload, context);
            } catch (error) {
                console.error('Workflow indítási hiba:', error);
                alert('Workflow indítása sikertelen: ' + error.message);
            }
        }

        async function ensureWorkflowKeys(payload, context = null) {
            const response = await fetch(`/api/workflow-key-status/${encodeURIComponent(PROJECT_NAME)}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ steps: payload.steps })
            });
            const result = await response.json();
            if (!response.ok || !result.success) {
                throw new Error(result.error || 'Nem sikerült ellenőrizni az API kulcsokat.');
            }
            const missing = Object.entries(result.keys || {}).filter(([, info]) => info.required && !info.present);
            if (!missing.length) {
                pendingWorkflowPayload = null;
                pendingWorkflowContext = null;
                return true;
            }
            const missingList = missing.map(([key, info]) => ({ key, label: info.label || key }));
            prepareWorkflowKeyModal(missingList);
            pendingWorkflowPayload = payload;
            pendingWorkflowContext = context || null;
            if (workflowKeysModal) {
                workflowKeysModal.show();
            } else {
                alert('Hiányzó API kulcsok: ' + missingList.map(item => item.label).join(', '));
            }
            return false;
        }

        function prepareWorkflowKeyModal(missingList) {
            Object.entries(workflowKeyFieldMap).forEach(([key, cfg]) => {
                const wrapper = document.getElementById(cfg.wrapperId);
                const input = document.getElementById(cfg.inputId);
                if (wrapper) {
                    const isRequired = missingList.some(item => item.key === key);
                    wrapper.classList.toggle('d-none', !isRequired);
                }
                if (input) {
                    input.value = '';
                }
            });
            const info = document.getElementById('workflowKeysInfo');
            if (info) {
                const labels = missingList.map(item => item.label);
                info.textContent = 'A workflow indításához add meg a következő kulcsokat: ' + labels.join(', ');
            }
        }

        function resetWorkflowKeyModal() {
            Object.values(workflowKeyFieldMap).forEach(cfg => {
                const wrapper = document.getElementById(cfg.wrapperId);
                if (wrapper) {
                    wrapper.classList.add('d-none');
                }
                const input = document.getElementById(cfg.inputId);
                if (input) {
                    input.value = '';
                }
            });
            const info = document.getElementById('workflowKeysInfo');
            if (info) {
                info.textContent = 'A workflow indításához add meg a hiányzó API kulcsokat.';
            }
        }

        async function saveWorkflowKeys() {
            if (!pendingWorkflowPayload) {
                if (workflowKeysModal) {
                    workflowKeysModal.hide();
                }
                return;
            }
            const submitBtn = document.getElementById('workflowKeysSubmitBtn');
            const spinner = document.getElementById('workflowKeysSpinner');
            const payload = {};
            let firstEmpty = null;

            Object.values(workflowKeyFieldMap).forEach(cfg => {
                const wrapper = document.getElementById(cfg.wrapperId);
                if (wrapper && !wrapper.classList.contains('d-none')) {
                    const input = document.getElementById(cfg.inputId);
                    const value = (input ? input.value : '').trim();
                    if (!value) {
                        if (!firstEmpty && input) {
                            firstEmpty = input;
                        }
                    } else {
                        payload[cfg.payloadKey] = value;
                    }
                }
            });

            if (firstEmpty) {
                firstEmpty.focus();
                alert('Kérjük add meg az összes hiányzó kulcsot.');
                return;
            }
            if (!Object.keys(payload).length) {
                if (workflowKeysModal) {
                    workflowKeysModal.hide();
                }
                return;
            }

            if (submitBtn) {
                submitBtn.disabled = true;
            }
            if (spinner) {
                spinner.classList.remove('d-none');
            }

            try {
                const response = await fetch('/save-workflow-keys', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();
                if (!response.ok || !result.success) {
                    throw new Error(result.error || 'Nem sikerült menteni az API kulcsokat.');
                }
                const payloadToRun = pendingWorkflowPayload;
                const contextToRun = pendingWorkflowContext;
                pendingWorkflowPayload = null;
                pendingWorkflowContext = null;
                if (workflowKeysModal) {
                    workflowKeysModal.hide();
                }
                if (!payloadToRun) {
                    return;
                }
                if (contextToRun && contextToRun.type === 'cycle') {
                    await startCycleIterationExecution(payloadToRun, contextToRun);
                } else {
                    await executeWorkflow(payloadToRun, contextToRun || null);
                }
            } catch (error) {
                alert('API kulcs mentése sikertelen: ' + error.message);
            } finally {
                if (submitBtn) {
                    submitBtn.disabled = false;
                }
                if (spinner) {
                    spinner.classList.add('d-none');
                }
            }
        }

        async function executeWorkflow(payload, context = null) {
            const statusText = document.getElementById('workflowStatusText');
            const startButton = document.getElementById('startWorkflowBtn');
            const spinner = document.getElementById('workflowSpinner');
            const stopButton = document.getElementById('stopWorkflowBtn');
            const stopSpinner = document.getElementById('stopWorkflowSpinner');
            const stopLabel = document.getElementById('stopWorkflowLabel');
            const logContent = document.getElementById('workflowLogContent');
            const logLink = document.getElementById('workflowLogLink');

            if (context) {
                currentRunContext = {
                    ...context,
                    jobId: null,
                    completionHandled: false
                };
            } else {
                currentRunContext = null;
            }

            currentWorkflowJobId = null;
            stopLogPolling(true);

            if (startButton) {
                startButton.disabled = true;
                startButton.classList.add('btn-processing');
            }
            if (spinner) {
                spinner.classList.remove('d-none');
            }
            if (statusText) {
                statusText.textContent = 'Workflow indítása...';
            }
            updateInfoBox('secondary', 'Workflow indítása folyamatban. Az első lépés néhány másodpercig eltarthat.');

            if (stopButton) {
                stopButton.classList.remove('d-none');
                stopButton.disabled = true;
            }
            if (stopSpinner) {
                stopSpinner.classList.add('d-none');
            }
            if (stopLabel) {
                stopLabel.textContent = 'Workflow megszakítása';
            }
            if (logLink) {
                logLink.innerHTML = '';
            }
            if (logContent) {
                logContent.textContent = 'Log inicializálása...';
            }
            updateLogStatus('Workflow indítása... várakozás a logra.', 'muted');

            try {
                const response = await fetch(`/api/run-workflow/${encodeURIComponent(PROJECT_NAME)}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();
                if (!response.ok || !result.success) {
                    throw new Error(result.error || 'Ismeretlen hiba a workflow indításakor.');
                }
                if (context) {
                    currentRunContext = {
                        ...context,
                        jobId: result.job_id,
                        completionHandled: false
                    };
                } else {
                    currentRunContext = null;
                }
                if (statusText) {
                    statusText.textContent = 'Workflow elindult, állapot frissítése folyamatban...';
                }
                startWorkflowPolling(result.job_id);
            } catch (error) {
                console.error('Workflow indítási hiba:', error);
                if (statusText) {
                    statusText.textContent = `Hiba: ${error.message}`;
                }
                if (startButton) {
                    startButton.disabled = false;
                    startButton.classList.remove('btn-processing');
                }
                if (spinner) {
                    spinner.classList.add('d-none');
                }
                if (stopButton) {
                    stopButton.classList.add('d-none');
                    stopButton.disabled = false;
                }
                updateInfoBox('danger', `Workflow indítása sikertelen: ${error.message}`);
                updateLogStatus('A log a workflow indítása után jelenik meg.', 'muted');
                currentRunContext = null;
            }
        }

        function startWorkflowPolling(jobId, triggerImmediate = true) {
            stopWorkflowPolling();
            currentWorkflowJobId = jobId;
            if (triggerImmediate) {
                pollWorkflowStatus();
            }
            workflowPollInterval = setInterval(pollWorkflowStatus, 5000);
        }

        function stopWorkflowPolling() {
            if (workflowPollInterval) {
                clearInterval(workflowPollInterval);
                workflowPollInterval = null;
            }
        }

        async function pollWorkflowStatus() {
            if (!currentWorkflowJobId) {
                return;
            }
            try {
                const response = await fetch(`/api/workflow-status/${currentWorkflowJobId}`);
                const result = await response.json();
                if (!response.ok || !result.success) {
                    throw new Error(result.error || 'Nem sikerült lekérdezni az állapotot.');
                }
                const job = result.job;
                renderWorkflowStatus(job);
                if (['completed', 'failed', 'cancelled'].includes(job.status)) {
                    stopWorkflowPolling();
                    stopLogPolling();
                    currentWorkflowJobId = null;
                }
            } catch (error) {
                console.error('Állapot lekérdezési hiba:', error);
                stopWorkflowPolling();
                stopLogPolling();
                currentWorkflowJobId = null;
            }
        }

        function renderWorkflowStatus(job) {
            const badge = document.getElementById('workflowStatusBadge');
            const statusText = document.getElementById('workflowStatusText');
            const logLink = document.getElementById('workflowLogLink');
            const startButton = document.getElementById('startWorkflowBtn');
            const startSpinner = document.getElementById('workflowSpinner');
            const stopButton = document.getElementById('stopWorkflowBtn');
            const stopSpinner = document.getElementById('stopWorkflowSpinner');
            const stopLabel = document.getElementById('stopWorkflowLabel');
            const hint = document.getElementById('workflowStatusHint');

            const statusLabels = {
                queued: 'Sorban áll',
                running: 'Folyamatban',
                completed: 'Kész',
                failed: 'Hiba',
                cancelling: 'Megszakítás folyamatban',
                cancelled: 'Megszakítva'
            };

            if (!job) {
                if (badge) {
                    badge.textContent = 'Nincs aktív feladat';
                    setWorkflowBadge(null);
                }
                if (statusText) {
                    statusText.textContent = collectScriptStepsForRun(0).length ? 'Workflow még nem futott ezen a projekten.' : 'Adj hozzá lépéseket az indításhoz.';
                }
                if (logLink) {
                    logLink.innerHTML = '';
                }
                if (startButton) {
                    startButton.disabled = collectScriptStepsForRun(0).length === 0;
                    startButton.classList.remove('btn-processing');
                }
                if (startSpinner) {
                    startSpinner.classList.add('d-none');
                }
                if (stopButton) {
                    stopButton.classList.add('d-none');
                    stopButton.disabled = false;
                }
                if (hint) {
                    hint.textContent = 'Állítsd össze a futtatandó lépéseket, konfiguráld a paramétereket, majd indítsd a workflow-t.';
                }
                updateLogStatus('A log a workflow indítása után jelenik meg.');
                return;
            }

            if (badge) {
                badge.textContent = statusLabels[job.status] || job.status || 'Ismeretlen';
                setWorkflowBadge(job.status);
            }

            const activeStatuses = ['queued', 'running', 'cancelling'];
            const isActive = activeStatuses.includes(job.status);

            if (isActive) {
                if (startButton) {
                    startButton.disabled = true;
                    startButton.classList.add('btn-processing');
                }
                if (startSpinner) {
                    startSpinner.classList.remove('d-none');
                }
                if (stopButton) {
                    stopButton.classList.remove('d-none');
                    stopButton.disabled = Boolean(job.cancel_requested);
                }
                if (stopSpinner) {
                    stopSpinner.classList.toggle('d-none', Boolean(job.cancel_requested));
                }
                if (stopLabel) {
                    stopLabel.textContent = job.cancel_requested ? 'Megszakítás kérése folyamatban...' : 'Workflow megszakítása';
                }
                const activeJobId = currentWorkflowJobId || job.job_id;
                if (activeJobId) {
                    startLogPolling(activeJobId);
                }
            } else {
                if (startButton) {
                    startButton.disabled = collectScriptStepsForRun(0).length === 0;
                    startButton.classList.remove('btn-processing');
                }
                if (startSpinner) {
                    startSpinner.classList.add('d-none');
                }
                if (stopButton) {
                    stopButton.classList.add('d-none');
                    stopButton.disabled = false;
                }
                if (stopSpinner) {
                    stopSpinner.classList.add('d-none');
                }
                if (stopLabel) {
                    stopLabel.textContent = 'Workflow megszakítása';
                }
                stopLogPolling();
            }

            if (statusText) {
                const stepInfo = job.current_step && job.current_step.display_name
                    ? `${job.current_step.index}/${job.current_step.total} – ${job.current_step.display_name}`
                    : '';
                statusText.textContent = [job.message || '', stepInfo].filter(Boolean).join(' ');
            }

            if (hint) {
                if (job.status === 'queued') {
                    hint.textContent = 'Feladat sorban áll – néhány másodpercen belül indul.';
                } else if (job.status === 'running') {
                    hint.textContent = 'Folyamatban lévő workflow – a logban követheted a lépéseket.';
                } else if (job.status === 'cancelling') {
                    hint.textContent = 'Megszakítás folyamatban – várakozás a folyamat leállítására.';
                } else if (job.status === 'failed') {
                    hint.textContent = 'Hiba történt – nyisd meg a logot és ellenőrizd, melyik lépés állt le.';
                } else if (job.status === 'cancelled') {
                    hint.textContent = 'Workflow megszakítva – szükség esetén indíts új feldolgozást.';
                } else if (job.status === 'completed') {
                    hint.textContent = 'Workflow sikeresen lefutott – a fájlok a projekt könyvtárban találhatók.';
                }
            }

            if (logLink) {
                if (job.log && job.log.url) {
                    logLink.innerHTML = `<a href="${job.log.url}" target="_blank" rel="noopener">Log megnyitása</a>`;
                } else {
                    logLink.innerHTML = '';
                }
            }

            if (job.status === 'failed') {
                updateLogStatus('A workflow hibával leállt. Ellenőrizd a logot.', 'danger');
            } else if (job.status === 'cancelled') {
                updateLogStatus('A workflow megszakítva.', 'danger');
            } else if (job.status === 'completed') {
                updateLogStatus('A workflow befejeződött.', 'success');
            } else if (isActive) {
                updateLogStatus('A workflow fut – a log folyamatosan frissül.', 'info');
            }

            handleRunContextJobUpdate(job);
        }

        function setWorkflowBadge(status) {
            const badge = document.getElementById('workflowStatusBadge');
            if (!badge) return;
            badge.classList.remove('bg-secondary', 'bg-primary', 'bg-success', 'bg-danger', 'bg-warning', 'bg-info');
            switch (status) {
                case 'queued':
                    badge.classList.add('bg-info');
                    break;
                case 'running':
                    badge.classList.add('bg-primary');
                    break;
                case 'completed':
                    badge.classList.add('bg-success');
                    break;
                case 'failed':
                    badge.classList.add('bg-danger');
                    break;
                case 'cancelling':
                case 'cancelled':
                    badge.classList.add('bg-warning');
                    break;
                default:
                    badge.classList.add('bg-secondary');
                    break;
            }
        }

        function updateInfoBox(level, message) {
            const infoBox = document.getElementById('workflowInfo');
            if (!infoBox) {
                return;
            }
            infoBox.classList.remove('alert-info', 'alert-secondary', 'alert-warning', 'alert-danger', 'alert-success');
            const classMap = {
                info: 'alert-info',
                success: 'alert-success',
                warning: 'alert-warning',
                danger: 'alert-danger',
                secondary: 'alert-secondary'
            };
            infoBox.classList.add(classMap[level] || 'alert-secondary');
            if (message !== undefined) {
                infoBox.textContent = message;
            }
            infoBox.classList.remove('d-none');
        }

        function updateLogStatus(text, tone = 'muted') {
            const statusEl = document.getElementById('workflowLogStatus');
            if (!statusEl) return;
            statusEl.textContent = text;
            statusEl.classList.remove('text-muted', 'text-danger', 'text-success', 'text-info');
            const toneClass = {
                muted: 'text-muted',
                danger: 'text-danger',
                success: 'text-success',
                info: 'text-info'
            }[tone] || 'text-muted';
            statusEl.classList.add(toneClass);
        }

        function startLogPolling(jobId, immediate = false) {
            stopLogPolling();
            currentLogJobId = jobId;
            if (immediate) {
                fetchWorkflowLog();
            }
            workflowLogInterval = setInterval(fetchWorkflowLog, 4000);
        }

        function stopLogPolling(silent = false) {
            if (workflowLogInterval) {
                clearInterval(workflowLogInterval);
                workflowLogInterval = null;
            }
            if (!silent) {
                currentLogJobId = null;
            }
        }

        async function fetchWorkflowLog() {
            if (!currentWorkflowJobId && !currentLogJobId) {
                return;
            }
            const jobId = currentWorkflowJobId || currentLogJobId;
            try {
                const response = await fetch(`/api/workflow-log/${jobId}`);
                const result = await response.json();
                if (!response.ok || !result.success) {
                    throw new Error(result.error || 'Nem sikerült beolvasni a logot.');
                }
                const logContent = document.getElementById('workflowLogContent');
                if (logContent) {
                    logContent.textContent = result.log || '—';
                }
                updateLogStatus(result.completed ? 'A workflow befejeződött.' : 'A log folyamatosan frissül.', result.completed ? 'success' : 'info');
            } catch (error) {
                console.error('Log olvasási hiba:', error);
                updateLogStatus('Nem sikerült frissíteni a logot.', 'danger');
            }
        }

        async function stopWorkflow() {
            if (!currentWorkflowJobId) {
                return;
            }
            const stopButton = document.getElementById('stopWorkflowBtn');
            const stopSpinner = document.getElementById('stopWorkflowSpinner');
            const stopLabel = document.getElementById('stopWorkflowLabel');
            const statusText = document.getElementById('workflowStatusText');

            if (stopButton) {
                stopButton.disabled = true;
            }
            if (stopSpinner) {
                stopSpinner.classList.remove('d-none');
            }
            if (stopLabel) {
                stopLabel.textContent = 'Megszakítás kérve...';
            }

            try {
                const response = await fetch(`/api/stop-workflow/${currentWorkflowJobId}`, {
                    method: 'POST'
                });
                const result = await response.json();
                if (!response.ok || !result.success) {
                    throw new Error(result.error || 'Ismeretlen hiba a megszakítás során.');
                }
                if (statusText) {
                    statusText.textContent = result.message || 'Megszakítás kérve. Várakozás a leállásra...';
                }
                updateLogStatus('Megszakítás kérve. Várakozás a folyamat leállítására.', 'info');
            } catch (error) {
                console.error('Workflow megszakítási hiba:', error);
                alert('Nem sikerült megszakítani a workflow-t: ' + error.message);
                if (stopButton) {
                    stopButton.disabled = false;
                }
                if (stopSpinner) {
                    stopSpinner.classList.add('d-none');
                }
                if (stopLabel) {
                    stopLabel.textContent = 'Workflow megszakítása';
                }
            }
        }


        function showTranscribeModal(projectName, fileName) {
            document.getElementById('transcribeProjectName').value = projectName;
            document.getElementById('transcribeFileName').value = fileName;
            const modal = new bootstrap.Modal(document.getElementById('transcribeModal'));
            modal.show();
        }

        function runTranscription() {
            const modal = bootstrap.Modal.getInstance(document.getElementById('transcribeModal'));
            modal.hide();

            const payload = {
                auto_chunk: document.getElementById('autoChunk').checked,
                chunk_seconds: document.getElementById('chunkSeconds').value,
                max_pause: document.getElementById('maxPause').value,
                timestamp_padding: document.getElementById('timestampPadding').value,
                max_segment_duration: document.getElementById('maxSegmentDuration').value,
                diarization: document.getElementById('enableDiarization').checked,
                language: document.getElementById('transcribeLanguage').value,
                temperature: document.getElementById('temperature').value,
                beam_size: document.getElementById('beamSize').value,
                device: document.getElementById('transcribeDevice').value
            };

            const projectName = document.getElementById('transcribeProjectName').value;
            const buttonId = 'transcribeBtn';
            setButtonLoading(buttonId, true);

            fetch(`/api/transcribe/${projectName}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(payload)
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert('Sikeres beolvasás!');
                    location.reload();
                } else {
                    alert('Hiba: ' + data.error);
                }
            })
            .catch(error => {
                console.error('Hiba:', error);
                alert('Hiba történt a beolvasás során');
            })
            .finally(() => {
                setButtonLoading(buttonId, false);
            });
        }

        function setButtonLoading(buttonId, isLoading) {
            const btn = document.getElementById(buttonId);
            if (btn) {
                if (isLoading) {
                    btn.classList.add('btn-loading');
                    btn.disabled = true;
                } else {
                    btn.classList.remove('btn-loading');
                    btn.disabled = false;
                    btn.classList.remove('btn-processing');
                }
            }
        }

        function runAudioExtraction(projectName, button) {
            if (!button.classList.contains('btn-processing')) {
                button.classList.add('btn-processing');
            }

            const keepChannelsToggle = document.getElementById('extractKeepChannels');
            const keepChannels = keepChannelsToggle ? keepChannelsToggle.checked : false;

            fetch(`/api/extract-audio/${projectName}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    keep_channels: keepChannels
                })
            })
            .then(response => response.json())
            .then(data => {
                button.classList.remove('btn-processing');
                if (data.success) {
                    alert('Sikeres audio kivonás!');
                    location.reload();
                } else {
                    alert('Hiba: ' + data.error);
                }
            })
            .catch(error => {
                button.classList.remove('btn-processing');
                console.error('Hiba:', error);
                alert('Hiba történt az audio kivonás során');
            });
        }

        function handleTranscribeClick(projectName, button) {
            if (!button.classList.contains('btn-processing')) {
                button.classList.add('btn-processing');
            }

            const audioElements = document.querySelectorAll('#speechAudioList audio source');
            if (audioElements.length > 0) {
                const fileName = audioElements[0].src.split('/').pop();
                showTranscribeModal(projectName, fileName);
            } else {
                button.classList.remove('btn-processing');
                alert('Nincs audió fájl a listában!');
            }
        }

        function showSeparateModal(projectName, fileName, button) {
            document.getElementById('separateProjectName').value = projectName;
            const modalElement = document.getElementById('separateModal');
            const modal = new bootstrap.Modal(modalElement);

            modal.show();

            modalElement.addEventListener('hidden.bs.modal', function () {
                if (button) {
                    button.classList.remove('btn-processing');
                }
            }, { once: true });
        }

        function runSeparation() {
            const projectName = document.getElementById('separateProjectName').value;
            const device = document.getElementById('separateDevice').value;
            const keepFullAudio = document.getElementById('keepFullAudio').checked;
            const nonSpeechSilence = document.getElementById('nonSpeechSilence').checked;
            const chunkSize = document.getElementById('chunkSize').value;
            const model = document.getElementById('separateModel').value;

            const modal = bootstrap.Modal.getInstance(document.getElementById('separateModal'));
            modal.hide();

            fetch(`/api/separate-audio/${projectName}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    device: device,
                    keep_full_audio: keepFullAudio,
                    non_speech_silence: nonSpeechSilence,
                    chunk_size: chunkSize,
                    model: model
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert('Sikeres szétválasztás!');
                    location.reload();
                } else {
                    alert('Hiba: ' + data.error);
                }
            })
            .catch(error => {
                console.error('Hiba:', error);
                alert('Hiba történt a szétválasztás során');
            });
        }

        function runAudioSeparation(projectName, fileName, button) {
            showSeparateModal(projectName, fileName, button || document.getElementById('separateBtn'));
        }

        document.addEventListener('DOMContentLoaded', () => {
            initPreviewModals();
            if (window.AudioTrimmer && typeof AudioTrimmer.init === 'function') {
                AudioTrimmer.init({
                    projectName: PROJECT_NAME,
                    buildWorkdirUrl: buildWorkdirUrl,
                    refreshDirectory: refreshDirectory,
                    reloadFileBrowser: reloadFileBrowser,
                    cssEscape: cssEscape
                });
            }
            initProjectFileActions();
            initFileBrowser();
            initWorkflowModals();
            initWorkflowButtons();
            initWorkflowContextMenu();
            initWorkflowKeyModal();
            const refreshLogBtn = document.getElementById('refreshWorkflowLogBtn');
            if (refreshLogBtn) {
                refreshLogBtn.addEventListener('click', () => fetchWorkflowLog());
            }
            loadWorkflowOptions(PROJECT_NAME);
        });
    </script>
</head>
<body>
    {% macro render_file_tree(entries) -%}
        <ul class="file-browser-tree list-unstyled mb-0">
            {%- for entry in entries %}
                <li>
                    {%- if entry.type == 'directory' %}
                        <details class="file-browser-directory{% if entry.highlight_class %} {{ entry.highlight_class }}{% endif %}" data-path="{{ entry.path }}"{% if entry.highlight_class %} data-highlight="{{ entry.highlight_class }}"{% endif %}>
                            <summary class="file-browser-summary">
                                <span class="file-browser-label">{{ entry.name }}</span>
                                <div class="file-browser-actions">
                                    <button type="button" class="btn btn-sm btn-outline-secondary file-upload-trigger" data-path="{{ entry.path }}" title="Fájl feltöltése ebbe a mappába">Feltöltés</button>
                                    <button type="button" class="btn btn-sm btn-outline-danger file-directory-clear-btn" data-path="{{ entry.path }}" title="Könyvtár tartalmának törlése">Tartalom törlése</button>
                                </div>
                            </summary>
                            <div class="file-browser-children">
                                {%- if entry.children %}
                                    {{ render_file_tree(entry.children) }}
                                {%- endif %}
                            </div>
                        </details>
                    {%- else %}
                        {%- set extension = '' %}
                        {%- if '.' in entry.name %}
                            {%- set extension = '.' + entry.name.rsplit('.', 1)[1].lower() %}
                        {%- endif %}
                        <div class="file-browser-item"
                             data-file-path="{{ entry.path }}"
                             data-file-name="{{ entry.name }}"
                             data-file-extension="{{ extension }}"
                             {% if entry.duration_from_name is defined and entry.duration_from_name is not none %}data-duration-from-name="{{ '%.6f'|format(entry.duration_from_name) }}"{% endif %}
                             {% if entry.duration_actual is defined and entry.duration_actual is not none %}data-duration-actual="{{ '%.6f'|format(entry.duration_actual) }}"{% endif %}
                             {% if entry.duration_display is defined and entry.duration_display %}data-duration-display="{{ entry.duration_display }}"{% endif %}
                             {% if entry.failed_original_text is defined and entry.failed_original_text is not none %}data-failed-original-text="{{ entry.failed_original_text }}"{% endif %}
                             {% if entry.failed_original_text_display is defined and entry.failed_original_text_display %}data-failed-original-text-display="{{ entry.failed_original_text_display }}"{% endif %}
                             {% if entry.enable_failed_move %}data-enable-failed-move="true"{% endif %}>
                            <a class="file-browser-link" href="{{ url_for('serve_workdir', filename=project.name + '/' + entry.path) }}" target="_blank" rel="noopener">
                                {{ entry.name }}
                            </a>
                            {% if entry.duration_display is defined and entry.duration_display %}
                                <span class="file-browser-meta small text-muted">{{ entry.duration_display }}</span>
                            {% endif %}
                            {% if entry.failed_original_text_display is defined and entry.failed_original_text_display %}
                                <span class="file-browser-note small text-muted">{{ entry.failed_original_text_display }}</span>
                            {% endif %}
                            <div class="file-browser-actions">
                                <button type="button" class="btn btn-sm btn-outline-danger file-delete-btn" title="Fájl törlése">Törlés</button>
                                {%- if entry.enable_failed_move and extension == '.wav' %}
                                    <button type="button" class="btn btn-sm btn-outline-primary file-move-to-translated-btn" title="Áthelyezés a fordított szegmensek közé">Áthelyezés</button>
                                {%- endif %}
                            </div>
                        </div>
                    {%- endif %}
                </li>
            {%- endfor %}
        </ul>
    {%- endmacro %}
    <div class="theme-controls">
        <button class="theme-toggle" onclick="toggleTheme()" aria-label="Téma váltása">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16">
            <path d="M8 11a3 3 0 1 1 0-6 3 3 0 0 1 0 6zm0 1a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z"/>
        </svg>
        </button>
    </div>

    <div class="container mt-4">
        <div class="d-flex flex-wrap align-items-center justify-content-between gap-2 mb-4">
            <h1 class="mb-0">Projekt: {{ project.name }}</h1>
            <a href="/" class="btn btn-secondary">Vissza a főoldalra</a>
        </div>

        <div class="card mb-4">
            <div class="card-header d-flex flex-column flex-lg-row align-items-lg-center justify-content-lg-between gap-2">
                <div class="d-flex align-items-center gap-2 flex-wrap">
                    <h5 class="mb-0">Moduláris AI workflow</h5>
                    <span id="workflowStatusBadge" class="badge bg-secondary">Nincs aktív feladat</span>
                </div>
                <small id="workflowStatusHint" class="text-muted">Állítsd össze a futtatandó lépéseket, konfiguráld a paramétereket, majd indítsd a workflow-t.</small>
            </div>
            <div class="card-body">
                <div class="alert alert-info small mb-3" role="alert" id="workflowInfo">
                    Válaszd ki a scripts mappában elérhető lépéseket, állítsd be a paramétereket egyenként, majd indítsd el a kívánt munkafolyamatot. A projektnév automatikusan kitöltésre kerül minden lépésnél.
                </div>
                <div class="d-flex flex-column gap-2 mb-3">
                    <div class="d-flex flex-wrap align-items-center gap-2">
                        <label for="workflowTemplateSelect" class="form-label mb-0">Mentett workflow</label>
                        <select class="form-select form-select-sm" id="workflowTemplateSelect" style="min-width: 220px;"></select>
                        <button type="button" class="btn btn-outline-success btn-sm" id="saveWorkflowBtn">Mentés sablonként</button>
                        <button type="button" class="btn btn-outline-secondary btn-sm" id="resetWorkflowBtn">Alapértelmezés visszaállítása</button>
                    </div>
                    <div class="d-flex flex-wrap align-items-center gap-2">
                        <span class="text-muted small">Jobb klikk a táblázatban a lépések beszúrásához.</span>
                        <span class="badge bg-warning text-dark d-none" id="workflowMissingBadge">Hiányzó paraméterek</span>
                    </div>
                </div>
                <div class="table-responsive">
                    <table class="table table-sm align-middle workflow-table" id="workflowStepsTable">
                        <thead>
                            <tr>
                                <th scope="col" style="width: 70px;">Aktív</th>
                                <th scope="col">Lépés</th>
                                <th scope="col" style="width: 140px;">Környezet</th>
                                <th scope="col" style="width: 150px;">Hiba esetén</th>
                                <th scope="col" style="width: 220px;">Műveletek</th>
                            </tr>
                        </thead>
                        <tbody id="workflowStepsBody">
                            <tr class="text-muted">
                                <td colspan="5">Még nem adtál hozzá lépéseket.</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <div class="d-flex flex-wrap align-items-center gap-2 mt-3">
                    <button type="button" class="btn btn-success d-flex align-items-center gap-2" id="startWorkflowBtn">
                        <span class="spinner-border spinner-border-sm d-none" role="status" aria-hidden="true" id="workflowSpinner"></span>
                        <span>Workflow indítása</span>
                    </button>
                    <button type="button" class="btn btn-outline-danger d-flex align-items-center gap-2 d-none" id="stopWorkflowBtn">
                        <span class="spinner-border spinner-border-sm d-none" role="status" aria-hidden="true" id="stopWorkflowSpinner"></span>
                        <span id="stopWorkflowLabel">Workflow megszakítása</span>
                    </button>
                    <span id="workflowStatusText" class="text-muted small flex-grow-1">Állapot frissítése folyamatban...</span>
                </div>
                <div class="log-panel mt-4">
                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <h6 class="mb-0">Workflow log</h6>
                        <button type="button" class="btn btn-sm btn-outline-secondary" id="refreshWorkflowLogBtn">Frissítés</button>
                    </div>
                    <div id="workflowLogStatus" class="small text-muted mb-2">
                        A log a workflow indítása után jelenik meg.
                    </div>
                    <div id="workflowLogLink" class="small mb-2"></div>
                    <pre id="workflowLogContent" class="log-viewer">—</pre>
                </div>
                <div id="workflowTips" class="small text-muted mt-3">
                    Tipp: a lépések paraméterei egyenként módosíthatók. A logban minden végrehajtott parancs kimenete megjelenik.
                </div>
            </div>
        </div>

        <!-- Workflow Step Picker Modal -->
        <div class="modal fade" id="workflowStepModal" tabindex="-1" aria-hidden="true">
            <div class="modal-dialog modal-lg modal-dialog-scrollable">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">Új workflow lépés hozzáadása</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <div class="mb-3">
                            <input type="search" class="form-control" id="workflowStepSearch" placeholder="Szűrés név alapján...">
                        </div>
                        <div class="list-group" id="workflowStepList">
                            <div class="list-group-item text-muted">Betöltés folyamatban...</div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Bezárás</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Workflow Parameters Modal -->
        <div class="modal fade" id="workflowParamsModal" tabindex="-1" aria-hidden="true">
            <div class="modal-dialog modal-lg modal-dialog-scrollable">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="workflowParamsTitle">Paraméterek szerkesztése</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <div id="workflowParamsAlert" class="alert alert-warning small d-none"></div>
                        <form id="workflowParamsForm">
                            <div id="workflowParamsContainer" class="vstack gap-3"></div>
                        </form>
                        <div id="workflowParamsHelp" class="mt-4 d-none"></div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Mégse</button>
                        <button type="button" class="btn btn-primary" id="workflowParamsSaveBtn">Mentés</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="card mb-4">
            <div class="card-header d-flex flex-column flex-lg-row align-items-lg-center justify-content-lg-between gap-2">
                <h5 class="mb-0">Projekt fájlok</h5>
                <small class="text-muted">A lista a workdir/{{ project.name }} könyvtár aktuális tartalmát mutatja.</small>
            </div>
            <div class="card-body">
                <div class="d-flex flex-wrap gap-2 mb-3">
                    <button type="button" class="btn btn-outline-primary btn-sm" id="rootUploadBtn">Fájl feltöltése a gyökérbe</button>
                    <button type="button" class="btn btn-outline-secondary btn-sm" id="refreshFileBrowserBtn">Lista frissítése</button>
                </div>
                <div id="failedGenerationLegend" class="file-browser-legend small{% if not has_failed_generation_highlights %} d-none{% endif %}">
                    <span class="file-browser-legend-swatch" aria-hidden="true"></span>
                    <span class="text-muted">Jelölt almappák: találtunk egyező fordított szegmenst a {{ config['PROJECT_SUBDIRS']['translated_splits'] }} mappában.</span>
                </div>
                <input type="file" id="projectFileUploadInput" class="d-none">
                {% if project_tree %}
                    <div class="file-browser" id="projectFileBrowser">
                        {{ render_file_tree(project_tree) }}
                    </div>
                {% else %}
                    <p class="mb-0">A projekt mappa üres.</p>
                {% endif %}
            </div>
        </div>

        <div class="d-flex justify-content-end gap-2 my-3">
            <button type="button" class="btn btn-outline-info" data-bs-toggle="modal" data-bs-target="#projectHelpModal">
                Súgó
            </button>
            <a href="/" class="btn btn-secondary">Vissza a főoldalra</a>
        </div>
    </div>

    <div class="modal fade" id="projectHelpModal" tabindex="-1" aria-labelledby="projectHelpModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg modal-dialog-scrollable">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="projectHelpModalLabel">AI Dubbing projektoldal súgó</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Bezárás"></button>
                </div>
                <div class="modal-body">
                    <p class="mb-3">
                        Ez az oldal a projekt teljes kezelését biztosítja: itt állíthatod össze és futtathatod a workflow-kat, követheted az állapotukat, és hozzáférsz a projektfájlokhoz.
                    </p>
                    <h6 class="fw-bold">Általános munkafolyamat</h6>
                    <ul class="mb-4">
                        <li>Válaszd ki a futtatni kívánt lépéseket a moduláris workflow táblázatban.</li>
                        <li>Töltsd ki a szükséges paramétereket a lépsekhez kapcsolódó űrlapokon.</li>
                        <li>Használd a futtatási vezérlőket a folyamat indításához, megállításához vagy folytatásához.</li>
                        <li>Ellenőrizd a naplókat és az állapotjelzőket, hogy nyomon kövesd a végrehajtást.</li>
                    </ul>
                    <h6 class="fw-bold">Widgetek részletes leírása</h6>
                    <ul class="mb-4">
                        <li>
                            <strong>Review + Continue</strong>: Megállítja a futást egy ellenőrzési pontnál, ahol áttekintheted a korábbi lépéseket, módosíthatod a paramétereket, majd a megfelelő gombbal folytathatod vagy újrafuttathatod a workflow-t. A widget folyamata addig szünetel, amíg döntést nem hozol.
                        </li>
                        <li>
                            <strong>Ciklus</strong>: Ismétlődő futtatást tesz lehetővé. A beállított ismétlésszám szerint egymás után újra lefuttatja az előtte szereplő, engedélyezett szkripteket. A "Visszalépés lépéseinek száma" értékkel adhatod meg, hány korábbi futtatható lépést építsen vissza a ciklusba. Ideális olyan feladatoknál, ahol többször kell azonos előkészítést vagy feldolgozást végezni.
                        </li>
                    </ul>
                    <h6 class="fw-bold">Workflow szekció</h6>
                    <ul class="mb-4">
                        <li>A badge jelzi, fut-e aktív feladat; a segítő szöveg összegzi az aktuális teendőt.</li>
                        <li>A sablonválasztóval betöltheted mentett workflow-kat, a gombokkal pedig elmentheted vagy visszaállíthatod az alapértelmezett lépéslistát.</li>
                        <li>A táblázatban kapcsolhatod az egyes lépéseket, megadhatod az execution környezetet és dönthetsz arról, mi történjen hiba esetén.</li>
                        <li>A táblázat melletti vezérlők indítják, leállítják vagy folytatják a futtatást, továbbá itt érhetők el a napló- és státusznézetek.</li>
                        <li>A workflow paraméterpanelen megjelenő figyelmeztetések segítenek a kötelező mezők kitöltésében.</li>
                    </ul>
                    <h6 class="fw-bold">Projektfájlok</h6>
                    <ul class="mb-4">
                        <li>A fájlkezelő a projekt könyvtárának teljes struktúráját mutatja, a kijelzett jelölések pedig a fordított szegmenseket emelik ki.</li>
                        <li>Az eszköztárból tölthetsz fel új fájlokat a gyökérbe, illetve frissítheted a listát a háttérben végzett módosítások után.</li>
                        <li>Az egyes elemeknél gyorsműveletek érhetők el: megnyitás új lapon, törlés vagy – ahol elérhető – áthelyezés a fordított tartományba.</li>
                    </ul>
                    <h6 class="fw-bold">Előnézeti és segédablakok</h6>
                    <ul class="mb-0">
                        <li>Az audió, videó és JSON előnézetek külön modális ablakban jelennek meg, ahol a trim funkciókkal testre szabhatod a fájlokat vagy áttekintheted a tartalmat.</li>
                        <li>A "Szétválasztás" és "Beolvasás" párbeszédablakok a feldolgozási paraméterek megadását segítik, és a projekt nevével együtt készítik elő a futtatható feladatot.</li>
                        <li>A workflow mentésekor, API kulcsok megadásakor vagy paraméterek összeállításakor ugyanilyen modális felület segít a strukturált adatbevitelben.</li>
                    </ul>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Bezárás</button>
                </div>
            </div>
        </div>
    </div>

    <!-- File Preview Modals -->
    <div class="modal fade" id="audioPreviewModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-lg modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="audioPreviewTitle">Audió szerkesztése</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Bezárás"></button>
                </div>
                <div class="modal-body">
                    <div class="audio-waveform mb-3">
                        <div id="audioWaveform"></div>
                        <div id="audioWaveformLoading" class="waveform-loading-overlay d-none">Betöltés...</div>
                    </div>
                    <div class="small text-muted">
                        Húzd az egeret a hullámformán a kijelöléshez, vagy állítsd a csúszkákkal a kezdő és záró pontot.
                    </div>
                    <div class="audio-trim-info d-flex flex-wrap align-items-center gap-3 mt-3">
                        <div>Kezdet: <span id="trimStartDisplay">—</span></div>
                        <div>Vége: <span id="trimEndDisplay">—</span></div>
                        <div>Hossz: <span id="trimDurationDisplay">—</span></div>
                    </div>
                    <div class="mt-3">
                        <label for="trimStartRange" class="form-label mb-1">Kezdőpont</label>
                        <input type="range" class="form-range" id="trimStartRange" min="0" max="0" step="0.01" value="0" disabled>
                    </div>
                    <div class="mt-3">
                        <label for="trimEndRange" class="form-label mb-1">Végpont</label>
                        <input type="range" class="form-range" id="trimEndRange" min="0" max="0" step="0.01" value="0" disabled>
                    </div>
                    <div class="d-flex flex-wrap gap-2 align-items-center mt-3">
                        <button type="button" class="btn btn-outline-secondary btn-sm" id="trimResetSelectionBtn" disabled>Teljes fájl kijelölése</button>
                        <span class="small text-muted">Mentéskor az eredeti fájl felülíródik.</span>
                    </div>
                    <div class="alert alert-danger py-2 px-3 small mt-3 d-none" id="trimErrorAlert"></div>
                </div>
                <div class="modal-footer">
                    <div class="me-auto d-flex align-items-center gap-2">
                        <div class="spinner-border spinner-border-sm text-primary d-none" role="status" id="trimSaveSpinner"></div>
                        <span class="small text-muted" id="trimStatusText"></span>
                    </div>
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Bezárás</button>
                    <button type="button" class="btn btn-primary" id="trimSaveBtn" disabled>Mentés</button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal fade" id="videoPreviewModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-xl modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="videoPreviewTitle">Videó lejátszása</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Bezárás"></button>
                </div>
                <div class="modal-body">
                    <video id="videoPreviewPlayer" class="w-100" controls preload="metadata" playsinline style="max-height: 70vh;"></video>
                </div>
            </div>
        </div>
    </div>

    <div class="modal fade" id="jsonPreviewModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-lg modal-dialog-scrollable">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="jsonPreviewTitle">Fájl előnézete</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Bezárás"></button>
                </div>
                <div class="modal-body">
                    <pre id="jsonPreviewContent" class="json-preview"></pre>
                </div>
            </div>
        </div>
    </div>

    <!-- Separate Audio Modal -->
    <div class="modal fade" id="separateModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Szétválasztás paraméterei</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <form id="separateForm">
                        <input type="hidden" id="separateProjectName">
                        <div class="mb-3">
                            <label for="separateDevice" class="form-label">Eszköz</label>
                            <select class="form-select" id="separateDevice">
                                <option value="cuda">CUDA (GPU)</option>
                                <option value="cpu">CPU</option>
                            </select>
                        </div>
                        <div class="mb-3 form-check">
                            <input type="checkbox" class="form-check-input" id="keepFullAudio">
                            <label class="form-check-label" for="keepFullAudio">Teljes audio fájl megtartása</label>
                        </div>
                        <div class="mb-3 form-check">
                            <input type="checkbox" class="form-check-input" id="nonSpeechSilence">
                            <label class="form-check-label" for="nonSpeechSilence">Csak csend a non_speech fájlban</label>
                        </div>
                        <div class="mb-3">
                            <label for="chunkSize" class="form-label">Darabolás hossza (perc)</label>
                            <input type="number" class="form-control" id="chunkSize" value="5" min="1">
                        </div>
                        <div class="mb-3">
                            <label for="separateModel" class="form-label">Modell</label>
                            <select class="form-select" id="separateModel">
                                <option value="htdemucs_ft" selected>htdemucs_ft</option>
                                <option value="htdemucs">htdemucs</option>
                                <option value="hdemucs_mmi">hdemucs_mmi</option>
                                <option value="mdx">mdx</option>
                                <option value="mdx_extra">mdx_extra</option>
                            </select>
                        </div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Mégse</button>
                    <button type="button" class="btn btn-primary" onclick="runSeparation()">Futtatás</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Transcribe Modal -->
    <div class="modal fade" id="transcribeModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Beolvasás paraméterei</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <form id="transcribeForm">
                        <input type="hidden" id="transcribeProjectName">
                        <input type="hidden" id="transcribeFileName">
                        <div class="mb-3 form-check">
                            <input type="checkbox" class="form-check-input" id="autoChunk" checked>
                            <label class="form-check-label" for="autoChunk">Automatikus chunk-méret kalibráció</label>
                        </div>
                        <div class="mb-3">
                            <label for="chunkSeconds" class="form-label">Fix chunk-méret (másodperc)</label>
                            <input type="number" class="form-control" id="chunkSeconds" value="30" min="1">
                            <small class="text-muted">Csak akkor kerül felhasználásra, ha az automatikus kalibráció ki van kapcsolva.</small>
                        </div>
                        <div class="mb-3">
                            <label for="maxPause" class="form-label">Maximális szünet a mondatok között (másodperc)</label>
                            <input type="number" class="form-control" id="maxPause" value="0.6" min="0" step="0.1">
                        </div>
                        <div class="mb-3">
                            <label for="timestampPadding" class="form-label">Időbélyeg kiterjesztés (másodperc)</label>
                            <input type="number" class="form-control" id="timestampPadding" value="0.2" min="0" step="0.1">
                        </div>
                        <div class="mb-3">
                            <label for="maxSegmentDuration" class="form-label">Mondatszegmens maximális hossza (másodperc)</label>
                            <input type="number" class="form-control" id="maxSegmentDuration" value="11.5" min="0" step="0.5">
                            <small class="text-muted">Állítsd 0-ra, ha nem szeretnéd korlátozni a szegmens hosszát.</small>
                        </div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Mégse</button>
                    <button type="button" class="btn btn-primary" onclick="runTranscription()">Futtatás</button>
                </div>
                </div>
            </div>
        </div>

        <!-- Workflow Save Modal -->
        <div class="modal fade" id="workflowSaveModal" tabindex="-1" aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">Workflow sablon mentése</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Bezárás"></button>
                    </div>
                    <div class="modal-body">
                        <div id="workflowSaveError" class="alert alert-danger small d-none"></div>
                        <div class="mb-3">
                            <label for="workflowSaveName" class="form-label">Sablon neve</label>
                            <input type="text" class="form-control" id="workflowSaveName" placeholder="Pl. Alap beállítások">
                        </div>
                        <div class="mb-3">
                            <label for="workflowSaveDescription" class="form-label">Leírás (opcionális)</label>
                            <textarea class="form-control" id="workflowSaveDescription" rows="2" placeholder="Rövid megjegyzés a sablonhoz"></textarea>
                        </div>
                        <div class="form-check mb-2">
                            <input type="checkbox" class="form-check-input" id="workflowSaveOverwrite">
                            <label class="form-check-label" for="workflowSaveOverwrite">Aktuális sablon felülírása</label>
                        </div>
                        <div class="small text-muted d-none" id="workflowSaveOverwriteInfo"></div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Mégse</button>
                        <button type="button" class="btn btn-primary" id="workflowSaveConfirmBtn">Mentés</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Workflow API Keys Modal -->
        <div class="modal fade" id="workflowKeysModal" tabindex="-1" aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">API kulcsok megadása</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Bezárás"></button>
                </div>
                <div class="modal-body">
                    <div class="alert alert-warning small" id="workflowKeysInfo">
                        A workflow indításához add meg a hiányzó API kulcsokat.
                    </div>
                    <div class="mb-3 d-none" id="workflowKeyFieldChatgpt">
                        <label for="workflowKeyChatgpt" class="form-label">OpenAI / ChatGPT API kulcs</label>
                        <input type="password" class="form-control" id="workflowKeyChatgpt" placeholder="sk-..." autocomplete="off">
                    </div>
                    <div class="mb-3 d-none" id="workflowKeyFieldDeepl">
                        <label for="workflowKeyDeepl" class="form-label">DeepL API kulcs</label>
                        <input type="password" class="form-control" id="workflowKeyDeepl" placeholder="DeepL API kulcs" autocomplete="off">
                    </div>
                    <div class="mb-3 d-none" id="workflowKeyFieldHuggingface">
                        <label for="workflowKeyHuggingface" class="form-label">Hugging Face token</label>
                        <input type="password" class="form-control" id="workflowKeyHuggingface" placeholder="hf_..." autocomplete="off">
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Mégse</button>
                    <button type="button" class="btn btn-primary d-flex align-items-center gap-2" id="workflowKeysSubmitBtn">
                        <span class="spinner-border spinner-border-sm d-none" id="workflowKeysSpinner" role="status" aria-hidden="true"></span>
                        <span id="workflowKeysSubmitLabel">Mentés és indítás</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script src="{{ url_for('static', filename='vendor/bootstrap/bootstrap.bundle.min.js') }}"></script>
</body>
</html>
